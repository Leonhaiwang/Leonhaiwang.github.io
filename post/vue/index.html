<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>vue | Leon</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://Leonhaiwang.github.io/favicon.ico?v=1618581232325">
<link rel="stylesheet" href="https://Leonhaiwang.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="vue
MVC模式：模型（js变量）--视图（HTML，css）--控制器（通过DOM对象绑定事件，将变量进行修改）
MVVM模式---基于mvc框架无control
Model：负责数据储存
View：负责页面展示
View Model:..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://Leonhaiwang.github.io">
        <img src="https://Leonhaiwang.github.io/images/avatar.png?v=1618581232325" class="site-logo">
        <h1 class="site-title">Leon</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      It is always day one !
    </div>
    <div class="site-footer">
       <a href="https://github.com/Leonhaiwang" target="_blank">Leon github</a> | <a class="rss" href="https://Leonhaiwang.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">vue</h2>
            <div class="post-date">2021-03-25</div>
            
            <div class="post-content" v-pre>
              <h1 id="vue">vue</h1>
<p>MVC模式：模型（js变量）--视图（HTML，css）--控制器（通过DOM对象绑定事件，将变量进行修改）</p>
<h2 id="mvvm模式-基于mvc框架无control">MVVM模式---基于mvc框架无control</h2>
<p>Model：负责数据储存</p>
<p>View：负责页面展示</p>
<p>View Model:负责业务逻辑，对数据进行加工后交给视图展示</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 视图 --&gt;
    &lt;div id=&quot;app&quot;&gt;
        {{ message }}
      &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;./lib/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var app = new Vue({
    el: '#app',
    //模型部分
    data: {
        message: 'Hello Vue!'
    }
    })
    console.log(app)
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>上面的这种方式效率低，而且容易被用户在浏览器情况下看到未经渲染的数据。用户体验不好，所以还有其他的渲染方式</p>
<h2 id="虚拟dom">虚拟DOM</h2>
<p>传统的DOM开发，是利用jQuery操作DOM，非常耗资源。</p>
<p>在JS内存里面构建类似于DOM的对象，去拼装数据，拼装完整后，把数据整体解析。一次性插入到html中去，----&gt;形成了虚拟Dom</p>
<h2 id="条件渲染">条件渲染</h2>
<h3 id="v-if-and-v-else"><strong>v-if</strong>   and  <strong>v-else</strong></h3>
<p>可以写boolean表达式</p>
<p>v-if和v-else中间不能 有其他的元素</p>
<p><strong>v-if-else</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
  
&lt;/head&gt;
&lt;body&gt;
  
    &lt;div id=&quot;app&quot;&gt;
       &lt;h1&gt;用户名：{{username}}&lt;/h1&gt;

       &lt;h2 v-if = &quot;isVip&quot;&gt;用户类型：VIP&lt;/h2&gt;
       &lt;!-- v-if和v-else中间不能有其他的元素 --&gt;
       &lt;h3 v-else = &quot;else&quot;&gt;else显示&lt;/h3&gt;

       &lt;br&gt;

       &lt;h1&gt;用户允许登录的时间&lt;/h1&gt;
       &lt;h3 v-if = &quot;age &gt; 14&quot;&gt;24hour&lt;/h3&gt;
       &lt;h3 v-else-if = &quot;isMiddle&quot;&gt;8hour&lt;/h3&gt;
       &lt;h3 v-else&gt;2hour&lt;/h3&gt;

      &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;./lib/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var app = new Vue({
    el: '#app',
    data: {
       username:&quot;张三&quot;,
       isVip:true,
       else:false,
       isAdult:true,
       isMiddle:false,
       age:16
    }
    })
    console.log(app)
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="v-show"><strong>v-show</strong></h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
  &lt;style&gt;
      #inner{
          color: chartreuse;
          background-color: cornflowerblue;
          font: 24px;
          width: 200px;
          height: 200px;
      }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
       
        &lt;div id=&quot;inner&quot; v-show = &quot;isShow&quot;&gt;
                helloVue
        &lt;/div&gt;
        &lt;button @click = &quot;show&quot;&gt;
            切换显示内容
        &lt;/button&gt;
      &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;./lib/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var app = new Vue({
    el: '#app',
    data: {
      isShow:false
    },
    methods:{
        show:function(){
            app.isShow = !app.isShow
        }
    }
    })
    
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="v-if-和-v-show的区别">v-if 和 v-show的区别</h3>
<p>v-if：不显示的时候，第一次直接不渲染，如果此时内容已经设置为显示，那么直接将内容从DOM去除，</p>
<p>v-show：不显示的时候，会改为display：none。 但是会渲染</p>
<p><strong>反复需要切换的内容用v-show;只是渲染一次的内容用v-if</strong></p>
<h2 id="列表渲染">列表渲染</h2>
<p>绑定key值，是String不用:</p>
<p>可以在v-for里面加上v-if判断条件</p>
<p>绑定的key值和后面要展示的元素是一一对应的。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
  
&lt;/head&gt;
&lt;body&gt;
  
    &lt;div id=&quot;app&quot;&gt;
        &lt;ul id=&quot;example-1&quot;&gt;
            &lt;li v-for=&quot;item,key in items&quot; :key=&quot;item.name&quot;&gt;
             {{key}} {{ item.name }} {{item.message}}
            &lt;/li&gt;
          &lt;/ul&gt;

          &lt;h3&gt;循环对象&lt;/h3&gt;
          &lt;ul&gt;
              &lt;li v-for = &quot;item,key in items[0]&quot;&gt;
              key:{{key}}  value:{{item}}
              &lt;/li&gt;
          &lt;/ul&gt;
          
          &lt;h3&gt;条件+循环渲染&lt;/h3&gt;
          &lt;ol&gt;
            &lt;li v-for = &quot;item,index in items&quot;  v-if = &quot;item.age%2==0&quot; :key = &quot;index&quot;&gt;
             {{index}}   {{item.age}} {{item.name}}
            &lt;/li&gt;
          &lt;/ol&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;./lib/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var app = new Vue({
    el: '#app',
    data: {
        items: [
      { message: 'Foo' ,name:'name1',age:12},
      { message: 'Bar' ,name:'name2',age:11}
    ]
    }
    })
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h2 id="模板语法">模板语法</h2>
<p>v-once只是插入一次不再更新。一次性插入不再修改</p>
<p>v-html：使得插入的html格式文本生效。</p>
<p>tips：使用v-html的时候，容易受到<mark>xss攻击</mark>（html里面的String容易会有执行命令的Demo，对网站造成攻击）</p>
<p>v:bind：绑定</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
  &lt;style&gt;
      #login{
          background-color: pink;
      }
      #register{
          background-color: cornflowerblue;
      }
      .name{
        background-color: cornflowerblue;
      }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  
    &lt;div id=&quot;app&quot;&gt;
       &lt;h1&gt;{{msg}}&lt;/h1&gt;
       &lt;h1 v-once&gt;{{msg}}&lt;/h1&gt;
       &lt;h1 v-html = &quot;html&quot;&gt;{{html}}&lt;/h1&gt;
       &lt;div :id = &quot;idName&quot;&gt;页面&lt;/div&gt;
        &lt;!-- 模板语言的表达式应用 --&gt;
        &lt;div&gt;
            {{firstName+lastName}}
        &lt;/div&gt;
        &lt;!-- 三元运算符 --&gt;
        &lt;div&gt;
            {{isVip?&quot;yes&quot;:&quot;no&quot;}}
        &lt;/div&gt;
        &lt;!-- 事件的绑定 --&gt;
        &lt;div class=&quot;name&quot;&gt;
            &lt;button v-on:click = &quot;changBG&quot;&gt;按钮&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;./lib/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var app = new Vue({
    el: '#app',
    data: {
       msg:&quot;String&quot;,
       html:'&lt;span&gt;1&lt;/span&gt;',
       idName:&quot;login&quot;,
       firstName:&quot;Z&quot;,
       lastName:&quot;SSS&quot;,
       isVip:true
    },
    methods:{
        changBG:function(){
            document.body.style.background = &quot;pink&quot;
        }
    }
    })
   
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h2 id="计算属性">计算属性</h2>
<p>conputed:将计算之后的结果返回再使用，计算的结果会放在缓存中提高效率</p>
<p>set，get</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;div&gt;
            {{firstName+lastName}}
        &lt;/div&gt;
       &lt;div&gt;
            {{fullname}}
       &lt;/div&gt;
       &lt;div&gt;
           &lt;!-- 逆序显示单词 --&gt;
           &lt;h1&gt;{{word.split(&quot;&quot;).reverse().join('')}}&lt;/h1&gt;
           &lt;h1&gt;{{reverseWord}}&lt;/h1&gt;
       &lt;/div&gt;
       &lt;div&gt;
           &lt;h1&gt;{{oddStudents}}&lt;/h1&gt;
       &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;./lib/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var app = new Vue({
    el: '#app',
    data: {
       firstName:&quot;Z&quot;,
       lastName:&quot;SSS&quot;,
        word:'music',
        items: [
      { message: 'Foo' ,name:'name1',age:12},
      { message: 'Bar' ,name:'name2',age:11}
    ]
    },
    computed:{
        fullname:function(){
            //会将计算的结果进行缓存
            return this.firstName+this.lastName
        },
        reverseWord:{
            get:function(){
                return this.word.split(&quot;&quot;).reverse().join(&quot;&quot;)
            },
            set:function(value){
                this.msg = value.split(&quot;&quot;).reverse().join(&quot;&quot;)
            }
        },
        oddStudents:function(){
            let result  = this.items.filter((item,i)=&gt;{
                return item.age%2==0
            })
            return result
        }
    }
    })
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="computed中的set和get方法">computed中的set和get方法</h3>
<p>一般没有set方法，是一个只读属性。</p>
<p>set参数（newValue），重新赋值。</p>
<pre><code class="language-js">computed: {
        // fullname:function () {
        //     return this.firstName + ' ' + this.lastName
        // }
        fullname:{
            set:function(newValue){
                console.log('----',newValue)
                const names = newValue.spilt(' '),
                this.firstName = names[0]
                this.lastName = names[1]
            },
            get:function(){
                return this.firstName + this.lastName
            }
        }
</code></pre>
<h3 id="method和computed的区别">method和computed的区别</h3>
<p>computed有内部缓存机制不会被频繁的调用，method每次都会被调用</p>
<h2 id="侦听器">侦听器</h2>
<p>监听数据变化的事件</p>
<p>不要滥用wacth：会影响效率内存</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
  &lt;style&gt;
      #login{
          background-color: pink;
      }
      #register{
          background-color: cornflowerblue;
      }
      .name{
        background-color: cornflowerblue;
      }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  
    &lt;div id=&quot;app&quot;&gt;
       
        &lt;div&gt;
            {{msg}}
            &lt;ul&gt;
                &lt;li v-for = 'item in arr'&gt;{{item}}&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;./lib/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var app = new Vue({
    el: '#app',
    data: {
      msg:&quot;信息&quot;,
      arr:[
          'x','y','z','z'
      ]
    },
    
    watch:{
        msg:function(val){
            console.log(val)
        },
        arr:function(val){
            console.log(val)
        }
    }
    })
   
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h2 id="class与style绑定">class与style绑定</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
  &lt;style&gt;
      .active{
          width: 200px;
          height: 200px;
          background-color: cornflowerblue;
      }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  
    &lt;div id=&quot;app&quot;&gt;
      &lt;div class =&quot;page&quot; :class = &quot;{active:isTrue}&quot;&gt;
        &lt;div class=&quot;page&quot; :class = &quot;styObj&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;./lib/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var app = new Vue({
    el: '#app',
    data: {
      isTrue:true,
      styObj:{
          active:true,lao:true
      }
    },
    methods:{
      
    }
    })
   
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h2 id="事件修饰符">事件修饰符</h2>
<p>阻止一些默认的事件：冒泡……</p>
<pre><code class="language-vue">&lt;!-- 阻止单击事件继续传播 --&gt;
&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;

&lt;!-- 提交事件不再重载页面 --&gt;
&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;

&lt;!-- 修饰符可以串联 --&gt;
&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;

&lt;!-- 只有修饰符 --&gt;
&lt;form v-on:submit.prevent&gt;&lt;/form&gt;

&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;
&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;
&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;

&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;
&lt;!-- 即事件不是从内部元素触发的 --&gt;
&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;
</code></pre>
<p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击。</p>
<h2 id="表单绑定">表单绑定</h2>
<p>v-model：一般负责监听用户的输入事件以更新数据</p>
<h2 id="生命周期函数">生命周期函数</h2>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/3868852-b190121b7014e0ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img" loading="lazy"></figure>
<p>beforeCreate</p>
<p>data方法和事件方法methods还未绑定到实例对象上</p>
<p>created---网络请求</p>
<p>数据和方法已经初始化完成，绑定在对象上</p>
<p>beforeMount</p>
<p>渲染之前，根据数据生成的DOM对象是拿不到的，</p>
<p>mounted</p>
<p>渲染之后，可以拿到根据数据生成的dom对象</p>
<p>beforeUpdate</p>
<p>数据更改，但内容未更改之前</p>
<p>updated</p>
<p>数据更改，内容更改完毕</p>
<p>beforeDestory</p>
<p>destroyed、</p>
<figure data-type="image" tabindex="2"><img src="C:%5CUsers%5C13799%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200925194104274.png" alt="image-20200925194104274" loading="lazy"></figure>
<p>const常量，不可以再次赋值</p>
<p>常量的含义是指向的对象不能修改，但是可以改变对象内部的属性。</p>
<h2 id="对象字面量的一个增强的写法">对象字面量的一个增强的写法</h2>
<pre><code class="language-js">    &lt;script&gt;
        // const obj = {
        //     name:&quot;why&quot;,
        //     age:12,
        //     run:function(){

        //     },   
        // }
        //属性的增强写法
        const name = &quot;why&quot;;
        const age = 12;           
        const obj = {
            name:name,
            age:age
        }
        //es6
        const obj = {
            name,
            age
        }
        //函数的增强写法
        //es6
        const obj  = {
            run(){},
            o(){}
        }
    &lt;/script&gt;
</code></pre>
<h2 id="哪些数组的方法是响应式的">哪些数组的方法是响应式的</h2>
<p>push() ,</p>
<p>pop()删除数组中的最后一位元素,</p>
<p>shift()-删除数组中的第一位元素,</p>
<p>unshift()-在数组最前面添加元素,</p>
<p>splice(start，要删除几个元素/),删除</p>
<p>splice(start，替换的个数，用来要替换的元素)  替换</p>
<p>splice(start，0，要插入的元素)  删除</p>
<p>sort(),排序</p>
<p>reverse()，数组内容反转</p>
<p><strong>通过索引值直接来修改不是响应式的</strong></p>
<pre><code>Vue.set.(this.letter,0,'bbbb')
</code></pre>
<h2 id="编程方式命令式编程声明式编程"><strong>编程方式：命令式编程/声明式编程</strong></h2>
<p>面向对象编程（第一公民：对象）/函数式编程（第一公民：函数）链式编程</p>
<h2 id="js中的高阶函数">js中的高阶函数</h2>
<p>函数式编程</p>
<pre><code class="language-js">	&lt;script&gt;
       const nums = [1,2,3,4,566,757,78]
      //  filter中的回调函数，必须要返回一个boolean值，返回true函数内部将会将这次回调的n加入到新的数组中 ，返回false时函数内部会过滤掉这次的n
      let newnums =  nums.filter(function (n) {
        return n &lt; 100
      })
      //map函数遍历函数返回值----返回函数的所有的值
      let newnums2 =  newnums.map(function (n){
        return n * 2 
      })
      //reduce对数组中所有内容进行汇总--两个参数
      newnums2.reduce((preValue,n)=&gt;{
        return preValue+n 
      },0)

      let total = nums.filter(function (n) {
        return n &lt; 100
      }).map(function(n){
        return n * 2
      }).reduce(function (perValue,n) {
        return perValue+n
      },0)
	//****************************************************************************
      let total = nums.filter(n =&gt; n &lt; 100).map(n =&gt; n * 2).reduce((per,n) =&gt; per+n)
    &lt;/script&gt;
</code></pre>
<h2 id="组件化">组件化</h2>
<p>将一个页面完成一个一个的小的功能块。</p>
<h2 id="vue组件化">vue组件化</h2>
<ul>
<li>任何应用都会抽象成一颗组件树</li>
<li>抽象的，可以开发出一个个独立的小组件来构造应用</li>
</ul>
<h3 id="组件的三个使用步骤">组件的三个使用步骤</h3>
<ol>
<li>创建组件构造器  vue.extend()</li>
<li>注册组件 vue.components()</li>
<li>使用组件、</li>
</ol>
<h3 id="全局组件和局部组件">全局组件和局部组件</h3>
<p>全局组件---可以在多个Vue‘实例下面使用</p>
<pre><code class="language-js">//创建组件构造器对象
    const cpn = Vue.extend({
      template:`
        &lt;div&gt;
          &lt;h2&gt;标题&lt;/h2&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;h2&gt;标题&lt;/h2&gt; 
        &lt;/div&gt;
        `
    })
    //注册组件
    Vue.component('my-cpn',cpn)
</code></pre>
<p>局部组件</p>
<pre><code class="language-js">    //创建组件构造器对象
    const cpnC = Vue.extend({
      template:`
        &lt;div&gt;
          &lt;h2&gt;标题&lt;/h2&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;h2&gt;标题&lt;/h2&gt; 
        &lt;/div&gt;
        `
    })
    //注册组件
    //Vue.component('my-cpn',cpn)

    const app = new Vue({
    el: '#app',
    data: {
      msg:&quot;msg&quot;,
    },
    components:{
      //cpn使用组件的标签名
      cpn: cpnC
    }
    })
</code></pre>
<h3 id="父组件和子组件">父组件和子组件</h3>
<pre><code class="language-js">&lt;script&gt;
    //创建第一个组件-----子组件
    const cpnC1 = Vue.extend({
      template:`
        &lt;div&gt;
          &lt;h2&gt;标题11&lt;/h2&gt; 
        
        &lt;/div&gt;
        `
    })
    //创建第二个  -----父组件
    const cpnC2 = Vue.extend({
      template:`
        &lt;div&gt;
          &lt;cpn1&gt;&lt;/cpn1&gt;
          &lt;h2&gt;标题22&lt;/h2&gt; 
        &lt;/div&gt;
        `,
        components:{
          cpn1:cpnC1
        }
    })
    //root组件
    const app = new Vue({
    el: '#app',
    data: {
      msg:&quot;msg&quot;,
    },
    components:{
      cpn2:cpnC2
    }
    })
&lt;/script&gt;
</code></pre>
<p>当在vue中使用父组件的时候，内部会编译好，在解析模板的过程中会解析到子组件，编译完成后就是一个完整的Demo形式</p>
<h3 id="组件的语法糖注册方式">组件的语法糖注册方式</h3>
<pre><code class="language-js">&lt;script&gt;
    //全局组件
    Vue.components('cpn1',
    {
      template:`
        &lt;div&gt;
          &lt;h2&gt;标题11&lt;/h2&gt; 
        &lt;/div&gt;
        `
    })
    const app = new Vue({
    el: '#app',
    data: {
      msg:&quot;msg&quot;,
    },
    components:{
      cpn2:{
        //局部组件语法糖
        template:`
          &lt;div&gt;
            &lt;cpn1&gt;&lt;/cpn1&gt;
            &lt;h2&gt;标题22&lt;/h2&gt; 
          &lt;/div&gt;
          `
    }
    }
    })
&lt;/script&gt;
</code></pre>
<h3 id="组件模板抽离">组件模板抽离</h3>
<p>引用script标签来引入</p>
<pre><code class="language-js">&lt;script type=&quot;text/x-template&quot; id=&quot;cpn&quot;&gt;
    &lt;div&gt;
      &lt;h2&gt;标题11&lt;/h2&gt; 
    &lt;/div&gt;
&lt;/script&gt;
</code></pre>
<p>template标签使用</p>
<pre><code class="language-js">&lt;template id=&quot;cpn&quot;&gt;
  &lt;div&gt;
    &lt;h2&gt;标题22&lt;/h2&gt; 
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>组件内部不能直接访问Vue实例的数据data。</p>
<h3 id="vue组件中存取数据的data">vue组件中存取数据的data</h3>
<p>组件中的data应该是一个<mark>函数类型</mark>？？</p>
<p>函数每次调用都会返回一个新的对象，data中的数据在不同的组件调用的时候不会产生连锁反应。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;cpn&gt;&lt;/cpn&gt;
    {{title}}
  &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;../lib/vue.js&quot;&gt;&lt;/script&gt;
&lt;template id=&quot;w1&quot;&gt;
  &lt;div&gt;
    &lt;h1&gt;{{title}}&lt;/h1&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  Vue.component(&quot;cpn&quot;,{
    template:&quot;#w1&quot;,
    data() {
      return {
        title:'标题'
      }
    },
  })
  const app  = new Vue({
    el:'#app',
    data:{
      title:'组件中标题'
    }
  })
&lt;/script&gt;
&lt;/html&gt;

</code></pre>
<h3 id="父子组件通信">父子组件通信</h3>
<p>父---&gt;子 props</p>
<p>props可以使用不同的形式</p>
<p>类型限制</p>
<p>提供默认值</p>
<h4 id="props中的驼峰标识v-bind不支持驼峰驼峰标识要转成-连接的形式cmoive-c-movie">props中的驼峰标识：v-bind：不支持驼峰，驼峰标识要转成   -   连接的形式cMoive  --&gt;  c-Movie</h4>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;cpn :c-Movie = 'movies' :cmessage = &quot;message&quot;&gt;&lt;/cpn&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;template id=&quot;w1&quot;&gt;
  &lt;div&gt;
    &lt;h1&gt;Zi&lt;/h1&gt;
    &lt;ul&gt;
      &lt;li v-for = &quot;item in cMovie&quot; :key = &quot;item&quot;&gt;{{item}}&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;{{cmessage}}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script src=&quot;../lib/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  const cpn = {
   template:'#w1',
  //  props:['cmovie','cmessage'],
    props:{
      //类型显示
      //提供默认值
      // cmovie:Array,
      // cmessage:String
      cMovie:{
        type:Array,
        default:[],
        required:false
      },
      cmessage:{
        type:String,
        default:'aaaa',
        required:true
      }
    },
   data(){
     return {}
   }
  }
  const app  = new Vue({
    el:'#app',
    data:{
      message:&quot;hello world!&quot;,
      movies:[1,2,3,4,5]
    },
    components:{
      cpn
    }
  })
&lt;/script&gt;
&lt;/html&gt;

</code></pre>
<p>子----&gt;父 $emit Events</p>
<p>使用自定义事件来进行子--&gt;父之间数据的传递</p>
<p>在子组件里面自定义一个事件，使用v-on绑定监听这个事件，发动事件的对象，在父组件中绑定监听这个事件，在父组件的方法中，使用一个事件函数来接受传递的这个值。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!-- 父组件模板 --&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;cpn @itemclick = &quot;cpnClick&quot;&gt;&lt;/cpn&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;!-- //子组件模板 --&gt;
&lt;template id=&quot;w1&quot;&gt;
  &lt;div&gt;
    &lt;button v-for = 'item in categories' 
            @click = &quot;btnClick(item)&quot;&gt;
      {{item.name}}
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script src=&quot;../lib/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  //子组件
  const cpn = {
    template:'#w1',
    data(){
      return {
        categories:[
          {id:'aaa',name:&quot;热门推荐&quot;},
          {id:'bbb',name:&quot;家电家电&quot;},
          {id:'ccc',name:&quot;火锅火锅&quot;},
          {id:'ddd',name:&quot;热门们门&quot;},
          {id:'eee',name:&quot;热门推荐&quot;},
        ]
      }
    },
    methods:{
      btnClick(item){
        //发射   -----自定义事件   v-on可以用于组件间的自定义事件
        this.$emit('itemclick',item)
      }
    }
  }
  const app  = new Vue({
    el:'#app',
    data:{
      message:&quot;hello world!&quot;,
      movies:[1,2,3,4,5]
    },
    methods:{
      cpnClick(item){
        console.log(&quot;ddd&quot;,item)
      }
    },    components:{
      cpn
    }
  })
&lt;/script&gt;
&lt;/html&gt;

</code></pre>
<h3 id="vue中子组件有很多的标签的时候必须包含一个根div">vue中子组件有很多的标签的时候必须包含一个根div</h3>
<h3 id="父子组件访问方式">父子组件访问方式</h3>
<p>$children  通过下标去获取值，不稳定</p>
<p>$refs  给调用的组件加一个ref属性值</p>
<pre><code>&lt;cpn ref = &quot;a&quot;&gt;&lt;/cpn&gt;
this.$refs.a   
</code></pre>
<p>$parent  访问父组件</p>
<p>$root  访问根组件</p>
<h2 id="slot插槽">slot插槽</h2>
<p>扩展性</p>
<p>让使用者决定组件内部的一些内容展示什么</p>
<p>有的页面有很多的不同也有很多的不一样的，</p>
<p>抽取共性，保留不同</p>
<p>基本使用</p>
<p>默认值</p>
<p>如果有多个值替换，所有的值都会替换</p>
<pre><code> &lt;slot&gt; &lt;button&gt;案件&lt;/button&gt;&lt;/slot&gt;
</code></pre>
<pre><code>&lt;cpn&gt;&lt;button&gt;案例1&lt;/button&gt; &lt;/cpn&gt;
</code></pre>
<h3 id="具名插槽的使用">具名插槽的使用</h3>
<pre><code>&lt;slot&gt;left&lt;/slot&gt;
&lt;slot name = &quot;center&quot;&gt;middle&lt;/slot&gt;
&lt;slot&gt;right&lt;/slot&gt;
</code></pre>
<pre><code>  &lt;cpn&gt;&lt;span slot=&quot;center&quot;&gt;myname&lt;/span&gt;&lt;/cpn&gt;
</code></pre>
<h3 id="作用域插槽">作用域插槽</h3>
<p>父组件替换插槽的标签，但是内容由子组件来提供</p>
<pre><code>      &lt;template slot-scope = &quot;slot&quot;&gt;
        &lt;span v-for = &quot;item in slot.data &quot;&gt;{{item}} - &lt;/span&gt;   
        &lt;span&gt;{{slot.data.join(' - ')}}&lt;/span&gt;
      &lt;/template&gt;
</code></pre>
<pre><code>&lt;template id=&quot;wrap&quot;&gt;
  &lt;div&gt;
  &lt;slot :data = &quot;pLanguage&quot;&gt;
    &lt;ul&gt;
      &lt;li v-for = &quot;item in pLanguages&quot;&gt;{{item}}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/slot&gt;
  &lt;/div&gt;
 v                                                                                                                           &lt;/template&gt;
</code></pre>
<h2 id="模块化开发">模块化开发</h2>
<p>CommonJS</p>
<p>核心：导出导入</p>
<h2 id="webpack">webpack</h2>
<p>是一个现代的js应用的静态<strong>模块打包</strong>工具---前端模块化打包工具---更加强调模块化</p>
<p>会自动处理成浏览器都可以识别的代码，并且处理各种依赖</p>
<p>核心：我们可以进行模块化开发，并且帮助我们处理模块间的各种依赖关系</p>
<p>依赖node环境，</p>
<p>安装</p>
<pre><code>npm install webpack@3.6.0
</code></pre>
<h2 id="loader">loader</h2>
<h2 id="cli-脚手架">CLI---脚手架</h2>
<p>CommendLine Interface</p>
<p>可以快速搭建Vue开发环境和对应的Webpack配置</p>
<h2 id="路由">路由</h2>
<p>通过互联的网络把信息从源地址传输到目的地址的活动</p>
<p>路由映射表：[内网ip：电脑MAC地址]</p>
<p>路由和转送：</p>
<p>路由：决定数据包从来源到目的地的路径</p>
<p>转送：将输入端的数据转移到合适的输出端</p>
<h3 id="前端渲染后端渲染">前端渲染后端渲染</h3>
<h4 id="后端渲染由服务器渲染">后端渲染：由服务器渲染</h4>
<p>后端路由阶段：后端处理页面和url之间的关系，一个页面对应一个网址url，url发送到服务器，通过正则对该url进行匹配，最后交给Controller处理，最终生成HTML，css，返回给前端</p>
<p>后端路由缺点：</p>
<ul>
<li>所有的东西都是有后端来做的</li>
<li>html和java代码会混在一起，后期维护较麻烦</li>
</ul>
<h4 id="前后端分离阶段">前后端分离阶段：</h4>
<p>后端只负责提供数据，前端通过Ajax获取数据，并且可以通过js将数据渲染在页面中</p>
<p>前端渲染：浏览器中显示的网页中的大部分代码，都是由前端写的js代码在浏览器中执行，最终渲染出来的网页</p>
<p>优点：</p>
<ul>
<li>责任清晰</li>
<li>后端不必关心多端的接口不同</li>
</ul>
<h4 id="单页面富应用阶段">单页面富应用阶段</h4>
<p>SPA：在前后端分离的基础上加了一层前端路由，前端来维护一套路由规则</p>
<p>整个页面只有一个index.html页面，</p>
<p><strong>前端路由</strong>：配置映射关系，不同的url从全部资源中抽取出需要的资源页面数据展示。<mark>改变url的时候，页面不进行新的刷新</mark></p>
<h3 id="url中的hash">url中的hash</h3>
<p>location.hash('aaa') 页面不会刷新</p>
<p>h5中history改变</p>
<p>history.pushState({},'',home)</p>
<p>history.repalceState({},'',home)</p>
<p>pushState和repalceState区别：replaceState不能保存返回，直接替换</p>
<p>history.go（）  = history.back()   ---- 路由跳转</p>
<h3 id="安装配置router">安装配置router</h3>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2020/10/23/EhDxNZOa9W3oMq1.png" alt="image-20201023165527622" loading="lazy"></figure>
<h3 id="配置路由的映射关系">配置路由的映射关系</h3>
<ol>
<li>创建路由组件</li>
<li>配置路由映射，组件和路由映射之间的关系</li>
<li>使用router-view确定位置</li>
</ol>
<p>router-view决定之后渲染出来的东西在哪，占位，</p>
<h3 id="路由的默认值和history模式">路由的默认值和history模式</h3>
<p>路由的默认定向：重定向</p>
<pre><code class="language-js">{
    path:'/',
    redirect:'/home'
  },
</code></pre>
<p>将hash模式改成history模式</p>
<pre><code class="language-js">const router = new VueRouter({
  routes,
  mode:'history',
  linkActiveClass:'acticeClass'
})
</code></pre>
<p>router-link其他的一些属性</p>
<img src="https://i.loli.net/2020/10/23/zwfIQtcoVuOmpxk.png" alt="image-20201023185453517" style="zoom: 67%;" />
<h3 id="代码实现路由跳转">代码实现路由跳转</h3>
<pre><code class="language-js">this.$router.push('/home')
</code></pre>
<pre><code class="language-js">this.$router.repalce('/home')
</code></pre>
<p>vue中尽量不要通过非路由以外的方法解决</p>
<h3 id="动态路由的使用">动态路由的使用</h3>
<p>在某些情况下，页面的路由path可能是不确定的，</p>
<pre><code class="language-js">{
    path:'/user/:id',
    component:User,
}
</code></pre>
<pre><code class="language-js"> &lt;router-link :to=&quot;'/user/'+id&quot;&gt;&lt;/router-link&gt;
</code></pre>
<p>this.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>i</mi><mi>d</mi><mo>=</mo><mo>=</mo><mo>=</mo><mo>=</mo><mi mathvariant="normal">》</mi></mrow><annotation encoding="application/x-tex">route.params.id  ====》</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord">.</span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">》</span></span></span></span>route拿到活跃对象---- 拿到动态路由后面的绑定值id</p>
<pre><code class="language-js">$route.params.id
</code></pre>
<h3 id="打包文件的说明">打包文件的说明</h3>
<p>app.js当前应用程序开发的所有代码（业务代码</p>
<p>vendor.js 引用第三方的js</p>
<p>manifest：为打包的代码做底层支撑</p>
<h3 id="路由的懒加载">路由的懒加载</h3>
<p>打包程序的时候配置文件非常大，会影响页面加载，<mark>用到时再加载</mark></p>
<p>主要作用就是将路由对应的组件打包成一个个的js代码块，只有在这个路由被访问到的时候，才加载对应的组件</p>
<p>写法：</p>
<pre><code class="language-js">const user  = () =&gt; import('../components/user.vue')
</code></pre>
<pre><code class="language-js">{
    path: '/look',
    component:() =&gt; import('../components/look')
  }
</code></pre>
<img src="https://i.loli.net/2020/10/23/9lRtybiquWpeGST.png" alt="image-20201023194310777" style="zoom:67%;" />
<h3 id="路由的嵌套">路由的嵌套</h3>
<ul>
<li>创建对应的子组件配置</li>
<li>在组件内部使用router-view</li>
</ul>
<pre><code class="language-js">{
    path:'/index',
    component:index,
    children:[{
      path:'Home',
      component:Home
    },
    {
      path:'look',
      component:look
    }
    ]
  },
</code></pre>
<h3 id="路由传参">路由传参</h3>
<h4 id="params简单的值">params：简单的值</h4>
<p>this.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>i</mi><mi>d</mi><mo>=</mo><mo>=</mo><mo>=</mo><mo>=</mo><mi mathvariant="normal">》</mi></mrow><annotation encoding="application/x-tex">route.params.id  ====》</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord">.</span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">》</span></span></span></span>route拿到活跃对象---- 拿到动态路由后面的绑定值id</p>
<pre><code class="language-js">$route.params.id
</code></pre>
<p>配置路由格式:/router/:id</p>
<p>传递的方式:在path后面跟上对应的值</p>
<p>传递后形成的路径：/router/213</p>
<h4 id="query可以传入对象">query:可以传入对象</h4>
<p>传递方式：对象中使用query的key作为传递方式</p>
<p>传递后形成的路径：/router?id =123</p>
<pre><code class="language-js">&lt;router-link :to=&quot;{path:'/profile',query:{name:'1'}}&quot;&gt;&lt;/router-link&gt;
</code></pre>
<p>$route.query.name</p>
<pre><code class="language-js">this.$router.push({path:'/profile',query:{name:'kobe',age:18}})
</code></pre>
<h3 id="url">URL</h3>
<p>协议://主机:端口/路径？查询</p>
<p>scheme://host:port/path?query#fragment</p>
<h3 id="router和route">router和route</h3>
<p>$router：是VueRouter的一个对象，通过Vue.use(VueRouter)和VueRouter构造函数得到一个router的实例对象，这个对象中是一个<mark>全局</mark>的对象，他包含了所有的路由包含了许多关键的对象和属性。</p>
<p>$route：是一个跳转的路由对象，每一个路由都会有一个route对象，是一个<mark>局部</mark>的对象，可以获取对应的name,path,params,query等</p>
<p>所有的组件都继承自vue的原型</p>
<h3 id="全局导航守卫">全局导航守卫</h3>
<pre><code class="language-js">//前置守卫（回调hook）
router.beforeEach((to,from,next) =&gt; {
	//从from跳to
	document.title = to.matched[0].meta.title 
	next()//必须调用
})
</code></pre>
<pre><code class="language-js">//后置钩子---已经跳转完
router.afterEach((to,from) =&gt; {
	
})
</code></pre>
<h3 id="路由独享守卫">路由独享守卫</h3>
<pre><code class="language-js">{
    path:'/test',
    component:test,
    beforeEnter: (to, from, next) =&gt; {
      console.log('----')
    }
</code></pre>
<h3 id="组件内导航">组件内导航</h3>
<pre><code class="language-js">beforeRouteLeave((to,from,next){
	this.path = this.$route.path
})
</code></pre>
<h3 id="keep-alive">keep-alive</h3>
<p>是Vue内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染----保持组件不被频繁的销毁</p>
<p>属性</p>
<p>exclude：字符串或正则表达式，任何匹配的组件都不会被缓存</p>
<p>include:只有匹配的组件会被缓存</p>
<pre><code>destoryed() {
	
}
</code></pre>
<pre><code class="language-html">&lt;keep-alive exclude = &quot;profile,user&quot;&gt;
  &lt;router-view&gt;&lt;/router-view&gt;  
&lt;/keep-alive&gt;
</code></pre>
<h4 id="activated和deactivated">activated和deactivated</h4>
<p>只有在keep-alive之下才能执行，只有该组件被保持了状态的时候才有效</p>
<h2 id="promise">Promise</h2>
<p>是<mark>异步</mark>编程的一种解决方案</p>
<p>应用场景，异步操作，网络请求，封装一个网络请求的函数，不能立即拿到结果，往往会传入另外一个函数，在数据请求成功时，将数据通过传入的函数回调出去，如果是一个简单的请求，不会带来麻烦，但是可能会带来回调地狱</p>
<p>异步操作，对即将进行的异步操作进行Promise封装</p>
<p>步骤</p>
<ul>
<li>构造函数，保存状态信息，执行传入的参数，在执行的时候会传入两个参数，resolve，reject</li>
</ul>
<pre><code class="language-js">    new Promise((resolve,reject) =&gt; {
     //网络请求
        setTimeout(() =&gt; {
        resolve(&quot;ninin&quot;)
      },1000)
    }).then((data)=&gt;{
      //处理
      console.log(data)
      return new Promise((resolve,reject)=&gt;{
        setTimeout(()=&gt;{
          //resolve()
            reject('err message')
        },1000)
      }).then(()=&gt;{
        //处理
      }).catch(err =&gt; {
          //reject‘处理
          console.log(err)
      })
    })
</code></pre>
<p>逻辑清晰，请求代码都放在一个Promise里面</p>
<h3 id="promise三种状态">Promise三种状态</h3>
<p>sync 同步    async 异步</p>
<p>pending：等待状态----&gt;正在进行网络请求的时候</p>
<p>fullfill：满足状态 ----&gt;主动调用了resolve</p>
<p>reject：拒绝状态----&gt;主动调用了reject</p>
<pre><code class="language-js"> new Promise((resolve,reject)=&gt;{
        setTimeout(()=&gt;{
          //resolve()
            reject('err message')
        },1000)
      }).then(()=&gt;{
       	//resolve
      },()=&gt;{
      	//reject
      })
</code></pre>
<pre><code>
</code></pre>
<p>其他的两种简写</p>
<pre><code class="language-js">new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        resolve('111')
      }, 100)
    }).then(res =&gt; {
      return Promise.resolve(res+'222')
    })
</code></pre>
<pre><code class="language-js">new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        resolve('111')
      }, 100)
    }).then(res =&gt; {
      return res+'222'
    })
</code></pre>
<p>reject的使用</p>
<pre><code class="language-js">    new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        resolve('111')
        // reject('mes')
      }, 100)
    }).then(res =&gt; {
      return Promise.reject('msg')
      throw console.error(&quot;mesg&quot;);
    })
</code></pre>
<h3 id="promise的all方法的调用">Promise的all方法的调用</h3>
<p>多个请求才能满足需求</p>
<p>all()方法里面传入一个数组，数组里面传入不同的请求，每个请求都会对应不同的结果，Promise会把不同的结果在.then函数中results保存起来调用</p>
<pre><code class="language-js">    Promise.all([
      new Promise((resolve,reject)=&gt;{
        $ajax({
          url:'1',
          success:(data)=&gt;{
            resolve(data)
          }
        })
      }),
      new Promise((resolve,reject)=&gt;{
        $ajax({
          url:'2',
          success:(data)=&gt;{
            resolve(data)
          }
        })
      })
    ]).then(results =&gt; {
      results[0]
      results[1]
    })
</code></pre>
<h2 id="vuex">vuex</h2>
<p>是一个专门为vue.js应用程序开发的状态管理工具</p>
<p>集中式储存管理应用的所有组件的状态，并且以相应的规则保证状态以一种可预测的方式发生变化</p>
<p><strong>响应式的状态的管理的工具</strong></p>
<p>多个组件之间需要共享一个状态---&gt;多个组件共享的变量全部存在一个对象里面</p>
<h3 id="什么样的状态在vuex中">什么样的状态在vuex中</h3>
<ul>
<li>用户的登录状态token，用户的信息等</li>
<li>状态信息</li>
<li>需要在多个页面中共享的状态</li>
</ul>
<h3 id="配置vuex">配置vuex</h3>
<pre><code class="language-js">import Vue from 'vue'
import Vuex from 'vuex'
//安装插件
Vue.use(Vuex)
//导出创建的对象
export default new Vuex.Store({
  state: {
      counter:1000
  },
  mutations: {
  },
  actions: {
  },
  modules: {
  }
})

</code></pre>
<pre><code class="language-js">$store.state.counter//取出vuex中的值
</code></pre>
<h3 id="全局单例模式">全局单例模式</h3>
<p>将共享的状态抽取出来，统一进行管理，之后每个视图，按照<mark>规定好的规定</mark>，进行访问和修改</p>
<h3 id="vuex状态管理图例">Vuex状态管理图例</h3>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2020/10/27/jmzDIgH971rlaot.png" alt="image-20201027215249768" loading="lazy"></figure>
<h3 id="state数据源存放地">state：数据源存放地</h3>
<p>state单一状态树：单一数据源，即使有很多的信息需要划分，也推荐使用单一数据源管理。将所有需要管理的信息统一放在一个store里面。</p>
<p>vue使用单一状态树来管理，应用层级的全部状态。可以最直接的找到某个状态的片段，在之后的维护调试中都非常的方便</p>
<h3 id="getters数据经过变化以后获取的数据">getters:数据经过变化以后获取的数据</h3>
<pre><code class="language-js"> getters:{
    powerCounter(state){
      return state.counter * state.counter
    },
    more20stu(state) {
      return state.student.filter(s =&gt; s.age &gt; 11)
    },
    more20stuLength(state,getters){
      return getters.more20stu.length
    },
    //传入参数
    moreAgeStu(state){
      return function (age){
        return state.student.filter(s =&gt; s.age &gt; 20)
      }
    }
  },
</code></pre>
<h3 id="mutations">mutations</h3>
<p>mutation中的方法必须是同步的方法，否则跟踪不到</p>
<p>mutation主要包括两部分</p>
<ul>
<li>字符串的事件类型</li>
<li>一个回调函数，该回调函数的第一个参数就是state</li>
</ul>
<pre><code class="language-js">mutations: {
    //方法
    increment(state) {
      state.counter++
    },
    decrement(state) {
      state.counter--
    },
    //传入参数
    incrementCount(state,count){
      state.counter += count
    },
    addStuObj(state,stu) {
      state.student.push(stu)
    }
  },
</code></pre>
<p>在methods中调用this.$store.commit</p>
<p>提交时候可以使用一些参数</p>
<pre><code class="language-js">  methods: {
    addition(){
      this.$store.commit('increment')
    },
    addCount(count){
      //负载
      this.$store.commit('increment',count)
    },
    addStu(){
      const stu = {id:3,name:'name',age:14}
      this.$store.commit('addStuObj',stu)
    }
  },
</code></pre>
<p>mutation提交风格</p>
<p>特殊的提交风格的传入的参数会变成一个对象</p>
<pre><code class="language-js"> addCount(count){
      //负载
      this.$store.commit('incrementCount',count)
      //特殊提交
      this.$store.commit({
        type:'incrementCount',
        count:count
      }) 
    },
</code></pre>
<pre><code class="language-js">incrementCount(state,payload){
      state.counter += payloadcount
    },
</code></pre>
<p>Mutation响应规则</p>
<p>vuex-数据的响应式原理</p>
<p>属性一开始就已经被定义，就会被加入到响应式系统中，响应式系统会监听属性的变化，当属性变化时，会通知所有的界面中用到该属性的地方改变值。</p>
<p>使用Vue的方法操作使数据响应式</p>
<pre><code class="language-js">Vue.set(state.info,&quot;address&quot;,&quot;洛杉矶&quot;)
//该方式做不到响应式
//delete state.info.age
Vue.delete(state.info,'age')
</code></pre>
<p>类型常量</p>
<p>在写mutation的时候，把变量方法名等，统一的放在一个js文件里面再导出为一个常量，这样可以避免写错带来的问题</p>
<pre><code>import {
  INCREMENT
} from '../store/mutatoins-type'
</code></pre>
<pre><code>export const INCREMENT = 'increment'
</code></pre>
<pre><code class="language-js">[INCREMENT](state) {
      state.counter++
    },
</code></pre>
<h3 id="actions">actions</h3>
<p>有异步操作的话都在actions里面进行</p>
<p>actions传入的默认参数是context，操作用context中的commit方法调用上面的方法</p>
<p>action可以返回一个Promise，可以在调用方法中调用Promise中的resolve</p>
<pre><code class="language-js">actions: {
    //context上下文
    aUpdateInfo(context,payload) {
      return new Promise((resolve,reject)=&gt;{
        setTimeout(()=&gt;{
          //用commit
          context.commit('UpdateInfo')
          payload()
          resolve('1111')
        },1000)
      })
    }
</code></pre>
<p>在调用的方法中使用dispatch方法调用action中的方法</p>
<pre><code class="language-js">UpdateInfo() {
      this
      .$store.dispatch('aUpdateInfo','message')
      .then(res =&gt; {
        console.log(res)
      })
    }
</code></pre>
<h3 id="modules">modules</h3>
<p>vuex将store分割成模块，每个模块里面有自己的mutations，actions，getters，state。</p>
<p>模块里面的state使用$store.state.a.name,modules中的state作为a（名字）放在state中</p>
<p>mutations中提交的时候还是按照最普通的方式进行提交，提交的时候会先在store中进行 寻找，没有的话就会去模块中进行寻找</p>
<pre><code class="language-js">const moduleA = {
  state:{
    name:'kobe'
  },
  actions:{
      //对象的解构
    aUpdateName({state,commit,rootstate}){
      // commit只会调用自己模块中的一些东西
      setTimeout(()=&gt;{
        context.commit('updateName','wanglu')
      },1000)
    }
  },
  mutations:{
    updateNAME(state,payload){
      state.name = payload
    }
  },
  getters:{
    fullname(state){
      return state.name + &quot; &quot;
    },
    //rootState指的是根store中的数据
    fullname1(state,rootState){
      return fullname+rootState
    }
  }
}
</code></pre>
<h2 id="axios">Axios</h2>
<ul>
<li>传统的Ajax，比较麻烦，</li>
<li>使用jQuery-Ajax，引入代码量较大</li>
<li>Vue-rosource不再更新</li>
</ul>
<h3 id="基本使用">基本使用</h3>
<p>安装</p>
<pre><code>cnpm i axios --save
</code></pre>
<p>main.js中导入</p>
<p>默认只传一个url是get请求</p>
<pre><code class="language-js">axios({
  url:'httpbin.org/',
  params:{
    type:'pop',
    page:1
  },
  method:'GET'
}).then(res =&gt;{
  console.log(res)
})
</code></pre>
<h3 id="发送并发请求">发送并发请求</h3>
<p>使用axios.all，可以放入多个请求的数组</p>
<p>axios.all([]) 返回的结果是一个数组，使用axios.spread可将数组[res1,res2]展开为res1，res2</p>
<pre><code class="language-js">axios.all([axios({
  url:&quot;http://152.136.185.210:8000/api/w6/home/data&quot;
}), axios({
  url:'http://152.136.185.210:8000/api/w6/home/data',
  method:'GET',
  params:{
    type:'sell',
    page:3
  }
})]).then(
  axios.spread((res1,res2)=&gt;{
    console.log(res1)
    console.log(res2)
  })
)
</code></pre>
<h3 id="axios全局配置在进行网络请求">axios全局配置在进行网络请求</h3>
<pre><code>axios.defaults.baseURL = &quot;&quot;
axios.defaults.timeout = 5000
</code></pre>
<h3 id="配置信息">配置信息</h3>
<figure data-type="image" tabindex="5"><img src="https://i.loli.net/2020/10/29/ArpUky5l9EsOv4a.png" alt="image-20201029175236371" loading="lazy"></figure>
<p>为了应对服务器不在一个IP地址</p>
<p>创建对应的axios实例</p>
<pre><code class="language-js">const instance = axios.create({
  baseURL:'http://152.136.185.210:8000/api/w6',
  timeout:5000
})
instance({
  url:'/home/multi'
}).then(res=&gt;{
  console.log(res)
})
</code></pre>
<h3 id="封装axios">封装axios</h3>
<p>方法一方法二都是回调函数的方式</p>
<p>方法一</p>
<pre><code class="language-js">import axios from 'axios'
export function request(config,success,failure){
  //创建实例
  const instance = axios.create({
    baseURL:'http://152.136.185.210:8000/api/w6',
    timeout:5000
  })
  //发送真正的网络请求
  instance(config)
    .then(res =&gt; {
      success(res)
    })
    .catch(err =&gt; {
      failure(err)
    })
}
</code></pre>
<p>调用</p>
<pre><code class="language-js">import {request} from './network/request'
request({
  url:'/home'
},res =&gt;{
  console.log(res)
},err =&gt; {
  console.log(err)
})
</code></pre>
<p>方法二</p>
<pre><code class="language-js">import axios from 'axios'
export function request(config){
  //创建实例
  const instance = axios.create({
    baseURL:'http://152.136.185.210:8000/api/w6',
    timeout:5000
  })
  //发送真正的网络请求
  instance(config.baseConfig)
    .then(res =&gt; {
      config.success(res)
    })
    .catch(err =&gt; {
      config.failure(err)
    })
}
</code></pre>
<pre><code class="language-js">request({
  baseConfig:{
    url:&quot;&quot;
  },
  success:res =&gt; {

  },
  failure:err =&gt; {

  }
})
</code></pre>
<p>方法三-Promise</p>
<pre><code class="language-js">import axios from 'axios'
export function request(config){
  return new Promise((resolve,reject) =&gt; {
    const instance = axios.create({
      baseURL:'http://152.136.185.210:8000/api/w6',
      timeout:5000
    })
    instance(config)
      .then(res =&gt; {
        resolve(res)
      })
      .catch(err =&gt; {
        reject(err)
      })
  })
}
 
</code></pre>
<pre><code class="language-js">request({
  url:''
}).then(res =&gt; {
  console.log(res)
}).catch(err =&gt; {
  console.log(err)
})
</code></pre>
<p>方法四</p>
<p>instance内部的.then.catch，已经是一个Promise对象，不需要再额外的进行包装Promise。</p>
<pre><code class="language-js">export function request(config){
    const instance = axios.create({
      baseURL:'http://152.136.185.210:8000/api/w6',
      timeout:5000
    })
    return instance(config)//返回一个Promise
}
</code></pre>
<p>axios拦截器的使用</p>
<h3 id="拦截器">拦截器</h3>
<ul>
<li>响应拦截</li>
<li>请求拦截</li>
</ul>
<p>拦截到以后要进行一些操作，然后return回去res</p>
<pre><code class="language-js">import axios from 'axios'
export function request(config){
    //创建axios实例
    const instance = axios.create({
      baseURL:'http://152.136.185.210:8000/api/w6',
      timeout:5000
    })
    //axios拦截器
    //请求拦截
    instance.interceptors.request.use(config =&gt; {
      //操作
      //config中的信息不符合服务器要求
      //每次发送请求的时候都显示一个请求图标
      //某些网络请求必须携带特殊的信息，先登录
      return config
    },err =&gt; {
      console.log(err)
    })
    //响应拦截
    instance.interceptors.response.use(res =&gt; {
      return res.data
    },err =&gt; {
      console.log(err)
    })
    //发送真正的网络请求
    return instance(config)
}
 
</code></pre>
<h2 id="git">git</h2>
<pre><code>1、git init   

    2、git add .

    3、git commit -m &quot;提交描述&quot;

    4、git remote add origin https://github.com/MyJoanna/test.git   （这里的 https://github.com/MyJoanna/test.git 是你的仓库地址）

    5、git push -u origin main
</code></pre>
<h2 id="新项目">新项目</h2>
<h3 id="划分目录结构">划分目录结构</h3>
<figure data-type="image" tabindex="6"><img src="https://i.loli.net/2020/10/30/jvGx4fR5bH8WQ6g.png" alt="image-20201030120210228" loading="lazy"></figure>
<h3 id="统一css文件">统一css文件</h3>
<p>github搜索normalize。下载引入normalcss文件，并且在项目中引入</p>
<p>vue.comfig.js 和 .editorconfig</p>
<p>项目模块的划分，tabbar--&gt;路由映射关系</p>
<pre><code class="language-js">&lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;
</code></pre>
<p>&lt;%= BASE_URL %&gt;动态获取当前文件路径</p>
<p>函数调用 -&gt; 压入函数栈(保存函数调用过程中所有变量)</p>
<p>函数调用结束 -&gt; 弹出函数栈(释放函数所有的变量)</p>
<p>再次调用，变量重新创建，调用结束以后释放所有的变量</p>
<p>Better-scroll</p>
<p>指定某一区域滚动</p>
<pre><code class="language-css">.content{
    background-color: blue;
    height: 150px;
    overflow: hidden;
    overflow-y: scroll;
  }
</code></pre>
<pre><code class="language-vue">&lt;template&gt;
&lt;div&gt;
    &lt;div class=&quot;wrapper&quot; ref=&quot;aaa&quot;&gt;
    &lt;ul class=&quot;content&quot;&gt;
     &lt;li&gt;lo1&lt;/li&gt;
     &lt;li&gt;lo2&lt;/li&gt;
     &lt;li&gt;lo3&lt;/li&gt;
     &lt;li&gt;lo4&lt;/li&gt;
     &lt;li&gt;lo5&lt;/li&gt;
     &lt;li&gt;lo6&lt;/li&gt;
    &lt;/ul&gt;
 &lt;/div&gt;
&lt;/div&gt;

&lt;/template&gt;

&lt;script&gt;
import BScroll from 'better-scroll'

  export default {
    name: &quot;Category&quot;,
    data() {
      return {
        scroll:null
      }
    },
    mounted() {
      this.scroll = new BScroll(this.$refs.aaa,{
      })
    },
  }
&lt;/script&gt;

&lt;style scoped&gt;
  .wrapper{
    background-color: blue;
    height: 150px;
     overflow: hidden;
    /* overflow-y: scroll; */
  }
&lt;/style&gt;

</code></pre>
<p>绑定ref</p>
<p>this.$refs.aaa</p>
<p>ref如果绑定在组件 中，<mark>this.$refs.refname</mark>那么获取到的是一个组件对象，</p>
<p>ref如果绑定在普通的元素中，<mark>this.$refs.refname</mark>那么获取到的是一个元素对象，</p>
<p>vh  viewpoint-height</p>
<p>视口高度</p>
<p>组件不能直接监听点击，如果想要监听点击，需要click.native 监听组件根元素的原生事件</p>
<p>.native 当需要监听一个组件的原生事件时，必须给组件加上.native来监听</p>
<h3 id="事件总线">事件总线</h3>
<p>管理事件。</p>
<p>this.$bus.emit(aaa)</p>
<p>发射事件到事件总线，在其他的位置监听发射的时间aaa，（）=&gt;{}</p>
<pre><code>Vue.prototype.$bus = new Vue()

this.$bus.$emit('事件名称'，参数)

this.$bus.$on('事件名称'，回调函数)
</code></pre>
<h3 id="防抖节流">防抖/节流</h3>
<p>debounce/throttle</p>
<p>防抖函数起作用的过程，</p>
<ul>
<li>如果直接执行refresh函数，会执行30次</li>
<li>可以将refresh函数传入到debounce中，生成一个新的函数</li>
</ul>
<p>settimeout永远放在最后执行，加载到下一次事件循环的尾部执行</p>
<p>如何将时间戳转成时间格式化String</p>
<ul>
<li>将时间戳转成date对象</li>
<li>const date  = new Date() -----*1000</li>
<li>将date进行格式化转成对应的字符串</li>
</ul>
<p>FormatString转成字符串</p>
<h3 id="mixin">mixin</h3>
<p>this.$nextTick(()=&gt;{</p>
<p>})</p>
<p>根据最新的数据</p>
<p>vuex</p>
<p>mapgetters</p>
<p>filter</p>
<p>reduce</p>
<p>fastclick减小点击的延迟</p>
<p>解决移动端300ms延迟的效果</p>
<p>import FastClick from 'fastclick'</p>
<p>FastClick.attach(document.body)</p>
<p>图片的懒加载</p>
<p>图片需要显示在屏幕上时再加载</p>
<p>lazyload</p>
<pre><code>npm i vue-lazyload --S
</code></pre>
<pre><code>import VueLazyLoad from 'vue-lazyload'
Vue.use(VueLazyLoad)
</code></pre>
<ul>
<li>
<p>使用</p>
<pre><code>v-lazy=&quot;showImage&quot;
</code></pre>
</li>
</ul>
<p>图片懒加载占位图</p>
<pre><code>Vue.use(VueLazyLoad,{
  loading:require('./assets/img/tabbar/category.svg')
})
</code></pre>
<p>将所有的px改成vw</p>
<pre><code>npm i postcss-px-to-viewport --save-dev
</code></pre>
<pre><code>module.exports = {
  plugins: {
    autoprefixer: {},
    &quot;postcss-px-to-viewport&quot;: {
      viewportWidth: 375, //视口的宽度，对应的时设计稿的宽度/2，一般为750
      viewportHeight: 667, //视口的高度，对应的是设计稿的高度（也可以不配置）
      unitPrecision: 5, //指定‘px’转换为视口单位值的小数位数（很多时候无法整除）
      viewportUnit: 'vw', //指定需要转换成的视口单位，建议使用vw
      selectorBlankList: ['ignore', 'tab-bar'], //指定不需要转换的类
      minPixelValue: 1, //小于或等于‘1px’不转换为视口单位
      mediaQuery: false,//允许在媒体查询中转换为‘px’
      exclude:[/Tabbar/]  //不需要转化的组件文件名正则，必须是正则表达式
    }
  }
}
</code></pre>
<p>yarn</p>
<h3 id="nginx项目部署">nginx项目部署</h3>
<p>服务器：为用户提供服务。24h</p>
<ul>
<li>window-&gt;nginx</li>
<li>远程部署</li>
</ul>
<h3 id="vue的响应式原理">Vue的响应式原理</h3>
<ul>
<li>
<p>数据发生改变，界面跟着更新，不是理所当然的</p>
</li>
<li>
<p>Vue内部是如何监听data数据改变的</p>
</li>
</ul>
<p>Object.defineProperty -&gt; 监听对象属性的改变</p>
<p>当新建一个Vue对象的时候，把data中的数据挂载到Vue中，遍历循环数据，用defineProperty 方法监听对象属性的变化，defineProperty 中有get和set方法</p>
<pre><code class="language-js">Object.keys(obj).forEach(key =&gt; {
    Object.defineProperty(obj,key,{
        set(newValue) {
        //监听key改变
            value = newValue
            //值发生改变调用--update
            dep.notify()
        },
        get(){
        //获取值
            return value
        }
    })
})
    
</code></pre>
<ul>
<li>当数据发生改变，Vue是如何知道需要通知什么部分页面刷新</li>
</ul>
<p>发布订阅者模式</p>
<pre><code class="language-js">存储对属性有依赖的东西
//发布者
class Dependence{
	constructor() {
        this.subs = []//记录谁要订阅属性，
    },
     addSub(watcher) {
         this.subs.push(watcher)
     },
     notify() {
         //找到所有的订阅者
         this.subs.forEach(item =&gt; {
             item.update()
         })
     }
}
//订阅者
class Watcher{
    constructor() {
        this.name = name
    }
    update() {
        //订阅者更新
        console.log(this.name + &quot;update&quot;)
    }
}
const dep = new Dependence()
const watcher = new Watcher(&quot;订阅者&quot;)
const watcher1 = new Watcher(&quot;订阅者1&quot;)
dep.addSub(watcher)//将订阅者放在数组中

dep.notify()
	
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://i.loli.net/2020/11/13/UgHZd5Eok4qK3rY.png" alt="image-20201113131617496" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://i.loli.net/2020/11/13/tcOjsb5MhNvHxoG.png" alt="image-20201113135203740" loading="lazy"></figure>

            </div>
            
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
