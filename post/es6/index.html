<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>ES6 | Leon</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://Leonhaiwang.github.io/favicon.ico?v=1618991219381">
<link rel="stylesheet" href="https://Leonhaiwang.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="
[toc]
1.1 什么是ECMA
ECMA（European Computer Manufacturers Association）中文名：欧洲计算机制造商协会
1.2 什么是ECMAScript



版本
更新




ES5
引入..." />
    <meta name="keywords" content="前端" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://Leonhaiwang.github.io">
        <img src="https://Leonhaiwang.github.io/images/avatar.png?v=1618991219381" class="site-logo">
        <h1 class="site-title">Leon</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      It is always day one !
    </div>
    <div class="site-footer">
       <a href="https://github.com/Leonhaiwang" target="_blank">Leon github</a> | <a class="rss" href="https://Leonhaiwang.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">ES6</h2>
            <div class="post-date">2021-03-25</div>
            
            <div class="post-content" v-pre>
              <!-- more -->
<p>[toc]</p>
<h1 id="11-什么是ecma">1.1 什么是ECMA</h1>
<p>ECMA（European Computer Manufacturers Association）中文名：欧洲计算机制造商协会</p>
<h1 id="12-什么是ecmascript">1.2 什么是ECMAScript</h1>
<table>
<thead>
<tr>
<th>版本</th>
<th>更新</th>
</tr>
</thead>
<tbody>
<tr>
<td>ES5</td>
<td>引入严格模式、JSON，扩展对象,bind。数组、原型、字符串、日期方法</td>
</tr>
<tr>
<td>ES6</td>
<td>let、const 变量声明、模块化、面向对象语法、Promise、箭头函数、数组解构赋值等等</td>
</tr>
<tr>
<td>ES7</td>
<td>幂运算符、数组扩展、Async/await 关键字</td>
</tr>
</tbody>
</table>
<h1 id="21-严格模式的理解es5">2.1 严格模式的理解——ES5</h1>
<h2 id="概念">概念</h2>
<p><strong>理解</strong>：除了正常运行模式（混杂模式），ES5添加了第二种运行模式：“严格模式”（strict mode）。</p>
<p>顾名思义，这种模式使得 JavaScript 在更严格的语法条件下运行</p>
<p><strong>目的：</strong></p>
<ul>
<li>消除JavaScript语法的一些不合理、不严谨之处，减少一些怪异行为。</li>
<li>消除代码运行的一些不安全之处，伪代码的安全运行保驾护航</li>
<li>为未来新版本的JavaScript做好铺垫</li>
</ul>
<h2 id="使用">使用</h2>
<ul>
<li>针对整个脚本文件：将 <code>&quot;use strict&quot;</code> 放在脚本文件的第一行，则整个脚本文件将以严格模式运行。</li>
<li>针对单个函数：将<code>&quot;use strict&quot;</code>放在函数体的第一行，则整个函数以严格模式运行</li>
</ul>
<h2 id="语法和行为改变">语法和行为改变</h2>
<ul>
<li>必须要声明变量
<ul>
<li>可以是<code>var ab = 10</code>，但不能是<code>ab = 10</code>（当然已经声明了ab的可以改变ab的值）</li>
</ul>
</li>
<li>禁止自定义的函数中的this指向window</li>
<li>创建eval作用域</li>
<li>对象不能有重名的属性</li>
</ul>
<h1 id="22-严格模式和普通模式的区别es5">2.2 严格模式和普通模式的区别——ES5</h1>
<p>下面列举几条严格模式的内容</p>
<h2 id="全局变量显示声明">全局变量显示声明</h2>
<p>在<strong>正常模式</strong>中，如果一个变量没有声明就付诸，默认是全局变量。</p>
<p>在<strong>严格模式</strong>中，禁止这种用法，全局变量必须显示声明。</p>
<h2 id="禁止this关键字指向全局对象">禁止this关键字指向全局对象</h2>
<pre><code class="language-JavaScript">function abc(){
  console.log(this);
}

abc()
</code></pre>
<p>在<strong>正常模式</strong>中，打印的是window。</p>
<p>在<strong>严格模式</strong>中，打印的是undefined。</p>
<h2 id="禁止使用with语句">禁止使用with语句</h2>
<p>因为with语句无法在编译时就确定，属性到底归属哪个对象</p>
<h2 id="构造函数必须通过new实例化对象">构造函数必须通过new实例化对象</h2>
<p>构造函数必须通过 new 实例化对象，否则报错。因为this为undefined，此时无法设置属性。</p>
<p>比如说：</p>
<pre><code class="language-javascript">function Student(){
  this.name = &quot;小红&quot;
  this.age = 18
  this.gender = 0
}

var s1 = new Student()//严格模式下的正确创建创建对象方法

var s2 = Student();//严格模式下报错
</code></pre>
<h1 id="31-json对象es5">3.1 JSON对象——ES5</h1>
<p>1、js对象（数组）--&gt;json对象（数组）：</p>
<pre><code>	JSON.stringfy(obj/arr)
</code></pre>
<p>2、json对象（数组）--&gt;js对象（数组）</p>
<pre><code class="language-javascript">	JSON.parse(json)
</code></pre>
<p>上面两个方法是 ES5 中提供的。</p>
<p>&quot;json字符串&quot;只有两种：<strong>json对象、json数组</strong></p>
<p><code>typeof json字符串</code>的返回结果是string</p>
<h1 id="41-object的扩展es5">4.1 Object的扩展——ES5</h1>
<p>ES5给Object扩展了一些静态的方法，常用的有2 个</p>
<h2 id="方法一-objectcreate">方法一 Object.create</h2>
<pre><code class="language-javascript">Object.create(prototype,[descriptors])
</code></pre>
<p>作用：以指定对象作为原型，创建新的对象。同时第二个参数可以为新的对象添加新的属性，并对此属性进行描述。</p>
<p><strong>举例1</strong>（没有第二个参数时）</p>
<pre><code class="language-JavaScript">var a = {
    username :&quot;admin&quot;,
    password:&quot;123456&quot;
}

// 不传第二个参数 Object.create(a)
var b = Object.create(a)

console.log(a,&quot;a&quot;);
console.log(b,&quot;b&quot;);
</code></pre>
<p>输出以下结果：</p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5CMaMing%5CDesktop%5Cdemo%5CES6~ES11%5C01README.assets%5Cimage-20200918082752774.png" alt="image-20200918082752774" loading="lazy"></figure>
<p>我们发现输出b里面什么都没有，但我们打开它的<code>__proto__</code>原型就会发现：</p>
<figure data-type="image" tabindex="2"><img src="C:%5CUsers%5CMaMing%5CDesktop%5Cdemo%5CES6~ES11%5C01README.assets%5Cimage-20200918083032836.png" alt="image-20200918083032836" loading="lazy"></figure>
<p><strong>a对象成为了b的原型</strong></p>
<hr>
<p><strong>举例2：</strong>(有第二个参数)<br>
第二个参数可以给新对象添加新的属性。例如：</p>
<p>把 a 对象设为 c 的原型的同时给 c 附加三个属性：name、gender、age</p>
<pre><code class="language-javascript">var a = {
    username :&quot;admin&quot;,
    password:&quot;123456&quot;
}
var c =Object.create(a,{
    name:{//添加name属性
        value :&quot;老王&quot;,//通过value关键字设置name的属性值
        writable:true,//是否可修改
        configurable:true,//是否可删除
        enumerable:true//是否可被迭代
    },
    
    gender:{//添加gender属性
        value :&quot;1&quot;,
        writable:false,
        configurable:true,
        enumerable:true
    },
    
    age:{//添加gender属性
        value :&quot;45&quot;,
        writable:true,
        configurable:true,
        enumerable:true
    },
})

// delete(c.gender)     ----------&gt; 	删除属性的方式

console.log(c , &quot;c&quot;);
</code></pre>
<p>运行结果：</p>
<figure data-type="image" tabindex="3"><img src="C:%5CUsers%5CMaMing%5CDesktop%5Cdemo%5CES6~ES11%5C01README.assets%5Cimage-20200918084223539.png" alt="image-20200918084223539" loading="lazy"></figure>
<p>上方代码中，</p>
<p>我们通过<code>Object.create(prototype,[descriptors])</code>的第二个参数给 <code>c</code> 设置了<code>name</code>、<code>gender</code>、<code>age</code>属性，但是要通过<code>value</code>来设置属性值，属性值默认是不可修改的，要通过<code>writable</code>来设置，这几个关键字解释如下：</p>
<ul>
<li><code>value</code>:设置属性值。</li>
<li><code>writable</code>：表示当前属性值是否可修改。默认为false。</li>
<li><code>configurable</code>:表示当前属性是否可以被删除。默认为false。</li>
<li><code>enumerable</code>表示当前属性是否能用 <code>for in</code>枚举，默认为false</li>
</ul>
<p><code>Object.create(prototype,[descriptors])</code>也是一种继承方式，例如：</p>
<pre><code class="language-javascript">student = {
    school:&quot;二小&quot;,
    learn:function(){
        console.log(&quot;俺会学习&quot;);
    },
}
var monitor = Object.create(student,{
    type:{
        value:&quot;班长&quot;,
        writable:true,
        configurable:true,
        enumerable:true
    },
    age:{
        value:&quot;20&quot;,
        writable:true,
        configurable:true,
        enumerable:true
    },
})
console.log(monitor);
</code></pre>
<h2 id="方法二-objectdefineproperty和objectdefineproperties">方法二 Object.defineProperty和Object.defineProperties</h2>
<p><strong>单独设置属性</strong></p>
<p><code>Object.defineProperty(obj, prop, descriptor)</code></p>
<p>参数说明：</p>
<pre><code>1 obj：必需。目标对象
2 prop：必需。需定义或修改的属性的名字
3 descriptor：必需。目标属性所拥有的特性
</code></pre>
<p>该方法可以（单独）重新定义或修改对象的属性</p>
<pre><code class="language-javascript">Object.defineProperty(monitor,&quot;type&quot;,{
    value:&quot;副班长&quot;,
    writable:true,
    configurable:true,
    enumerable:true
})
</code></pre>
<p><strong>设置属性并了解get 和 set</strong></p>
<p><code>Object.defineProperties(object,descriptors)</code></p>
<p>如果想给一个属性和某些数据绑定，就可以用到<code>get</code>和<code>set</code>,</p>
<p>在了解 get 和 set 前我们先了解一下什么是<strong>存取描述符</strong>和<strong>数据属性描述符</strong></p>
<ul>
<li>
<p><strong>存取描述符</strong>指可以控制数据如何存放和去除或者是否可以存放和取出的，是宏观上的。</p>
</li>
<li>
<p><strong>数据属性描述符</strong>指可以控制当前数据的值的属性和内容的，是微观的。</p>
</li>
<li>
<p>而<strong>存取描述符和数据属性描述符不能同时出现</strong>，</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>存取描述符</th>
<th>数据属性描述符</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>writable</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>configurable</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>enumerable</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>get</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>set</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody>
</table>
<p>也就是说有<code>value/writable</code>不能有<code>get/set</code>，有<code>get/set</code>不能有<code>value/writable</code></p>
<ul>
<li>get和set以函数的名义出现。</li>
<li>get函数----&gt;每次获取属性值时会调用该函数</li>
<li>set函数-----&gt;每次 设置/改变 属性值时会调用该函数</li>
</ul>
<pre><code class="language-javascript">        var user = {
            firstName:&quot;Peter&quot;,
            lastName: &quot;Parker&quot;,
            // fullName:firstName+lastName
        }

        Object.defineProperties(user, {
            fullName: {
                // 获取属性值时调用的函数
                get: function () {
                    return this.firstName + &quot;-&quot; + this.lastName
                },
                // 设置属性值时调用的函数
                set: function (data) {
                    console.log(&quot;被设置为了&quot; + data);
                    var arr = data.split(&quot;-&quot;);
                    console.log(arr);
                    if (arr.length == 2) {
                        this.firstName = arr[0]
                        this.lastName = arr[1]
                    } else {
                        console.log(&quot;输入不规范&quot;);
                    }
                }
            }
        })

        console.log(user);
</code></pre>
<h1 id="51-数组的扩展es5">5.1 数组的扩展——ES5</h1>
<h2 id="方法1-indexof">方法1 ：indexof</h2>
<pre><code>	Array.prototype.indexof(value)
</code></pre>
<p>获取value在数组中的第一个下标，如果没有返回-1</p>
<figure data-type="image" tabindex="4"><img src="https://upload-images.jianshu.io/upload_images/7047608-5bc57863d5d35991.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/228/format/webp" alt="img" loading="lazy"></figure>
<h2 id="方法2lastindexof">方法2：lastIndexOf</h2>
<pre><code>	Array.prototype.lastIndexOf(value)
</code></pre>
<p>获取value在数组中的最后一个下标，如果没有返回-1</p>
<h2 id="方法3foreach">方法3：forEach</h2>
<pre><code>Array.prototype.forEach(function(item,index,arr){})		//参数index，arr可选
</code></pre>
<p>作用：遍历当前数组，参数为一个回调函数，回调有三个值：</p>
<ol>
<li>当前元素，2. 当前元素索引值，3. 整个数组</li>
</ol>
<h2 id="方法4map">方法4：map</h2>
<pre><code>Array.prototype.map(function(item,index,arr){})			//参数index，arr可选
</code></pre>
<p>作用：遍历数组返回一个新的数组，返回的是<strong>加工之后</strong>的新数组</p>
<pre><code class="language-javascript">        var arr = [1,5,7,6,4,6,12,6,46,9,4,3,1,4,61,23,1,4,6,456]
        var newArr = arr.map(function(item){
            return item+&quot;个傻X&quot;
        })
        console.log(arr);
        console.log(newArr);
</code></pre>
<p>运行结果：</p>
<figure data-type="image" tabindex="5"><img src="C:%5CUsers%5CMaMing%5CDesktop%5Cdemo%5CES6~ES11%5C01README.assets%5Cimage-20200918180149615.png" alt="image-20200918180149615" loading="lazy"></figure>
<h2 id="方法5-filter">方法5： filter</h2>
<pre><code>Array.prototype.filter(function(item,index){})		//参数2，3可选
</code></pre>
<p>作用：遍历过滤出一个新的子数组，<strong>返回条件为true的值</strong></p>
<pre><code class="language-JavaScript">        var arr = [1,5,7,6,4,6,12,6,46,9,4,3,1,4,61,23,1,4,6,456]
        var newArr  = arr.filter(function(element){
            return element&gt;10
        }) 
        console.log(arr);
        console.log(newArr);
</code></pre>
<p>运行结果：</p>
<figure data-type="image" tabindex="6"><img src="C:%5CUsers%5CMaMing%5CDesktop%5Cdemo%5CES6~ES11%5C01README.assets%5Cimage-20200918183825258.png" alt="image-20200918183825258" loading="lazy"></figure>
<h2 id="方法6every">方法6：every</h2>
<pre><code>Array.prototype.every(function(element,index,array){});
</code></pre>
<p>作用：判断函数的回调函数是否<strong>全部</strong>都符合条件。</p>
<p>所有函数的回调函数都返回true则返回true，否则返回false</p>
<pre><code class="language-JavaScript">        var arr = [1,5,7,6,4,6,12,6,46,9,4,3,1,4,61,23,1,4,6,456]

        var result1 = arr.every(function(ele){
            return ele &lt; 500
        })

        var result2 = arr.every(function(ele){
            return ele &gt; 10 
        })

        console.log(result1);//true
        console.log(result2);//false
</code></pre>
<p>运行结果：</p>
<p>true</p>
<p>false</p>
<h2 id="方法7-some">方法7 ：some</h2>
<pre><code>Array.prototype.some(function(element,index,array){});
</code></pre>
<p>作用：判断回调中是否存在<strong>一个或以上</strong>符合条件。</p>
<p>存在一个函数的回调函数返回true则返回true，否则返回false</p>
<pre><code class="language-JavaScript">            var arr = [1,5,7,6,4,6,12,6,46,9,4,3,1,4,61,23,1,4,6,456]
            var result1 = arr.some(function(ele){
                return ele == 9
            })
            var result2 = arr.some(function(ele){
                return ele == 100
            })

            console.log(result1);	//true
            console.log(result2);	//false
</code></pre>
<p>运行结果：</p>
<p>true</p>
<p>false</p>
<h2 id="方法8reduce">方法8：reduce</h2>
<pre><code>Array.prototype.reduce(function(prev,curr,index,arr){})
</code></pre>
<p>跳过第一项，<strong>从第二项开始遍历</strong></p>
<p><strong>不要被这个方法的名字迷惑了</strong>，reduce的中文意思是减少的意思，但事实上<code>reduce</code>进行的操作大多不是用来进行减法运算，我们举个例子，来看一下这四个参数到底是干什么的</p>
<pre><code class="language-JavaScript">        var arr = [1,2,3,4,5]
        var result1 = arr.reduce(function(prev,cur,index,arr){
            console.log(prev,cur,index,arr);

            return prev + cur
        })
        console.log(result1);
</code></pre>
<p>运行结果：</p>
<figure data-type="image" tabindex="7"><img src="C:%5CUsers%5CMaMing%5CDesktop%5Cdemo%5CES6~ES11%5C01README.assets%5Cimage-20200919085223262.png" alt="image-20200919085223262" loading="lazy"></figure>
<ol>
<li>prev: 第一项的值或上一次叠加的结果值</li>
<li>cur: 当前会参与叠加的项</li>
<li>index： 当前值的索引</li>
<li>arr: 数组本身</li>
</ol>
<p><strong>prev并不是当前项的上一项</strong>，prev表示每次叠加之后的结果</p>
<p>如果我们就是想从第一项开始遍历怎么办，但是从第一项开始遍历的话，第一项就不具备 prev 的值了，</p>
<p>这时候我们就可以传另外一个参数。末尾添加一个<code>value</code> ，这里我们拿 0 举例，</p>
<p>这个0表示的就是第一项的 prev 的值</p>
<pre><code class="language-JavaScript">        var result1 = arr.reduce(function (prev, cur, index, arr) {
            console.log(prev, cur, index, arr);

            return prev + cur
        },0)
</code></pre>
<h1 id="61函数function的扩展es5">6.1函数function的扩展——ES5</h1>
<p>ES5 中新增了<code>bind()</code>函数来<strong>改变this的指向</strong></p>
<p>类似的函数还有<code>call()</code>、<code>apply()</code></p>
<p>那么这三个函数<code>call()</code>、<code>apply()</code>和<code>bind()</code>都怎么使用呢，又都有什么区别呢</p>
<p><strong>例1：</strong></p>
<pre><code class="language-JavaScript">        var name = &quot;老王&quot;
        var age = 45
        var obj = {
            name:&quot;老马&quot;,
            objAge:this.age,//this指向window
            objFun:function(){
                console.log(this.name+&quot;年龄&quot;+this.age);//this指向obj
            }
        }      
</code></pre>
<pre><code class="language-JavaScript">obj.objAge	 //45
obj.objFun();   //老马年龄undefined
</code></pre>
<p><strong>例2：</strong></p>
<pre><code class="language-JavaScript">        var foo = &quot;老张&quot;
        function shows(){
            console.log(this.foo);//this指向window
        }
</code></pre>
<pre><code>        shows();    //老张
</code></pre>
<p>很明显，例1中 obj.objFun()里的<code>this</code>指向obj，而 例2中 shows的<code>this</code>指向window</p>
<p>要想改变这一点，我们可以使用call()、apply()、bind()</p>
<p><strong>1，call()、apply()、bind() 都是用来重定义 this 这个对象的</strong></p>
<pre><code class="language-javascript">        var name = &quot;老王&quot;
        var age = 45
        var obj = {
            name:&quot;老马&quot;,
            objAge:this.age,		//this指向window
            objFun:function(){
                console.log(this.name+&quot;年龄&quot;+this.age);//this指向obj
            }
        }
        
        var another = {
            name:&quot;老傻X&quot;,
            age:&quot;99&quot;
        }
</code></pre>
<pre><code class="language-javascript">		obj.objFun.call(another)    //老傻X年龄99
        obj.objFun.apply(another)   //老傻X年龄99
        obj.objFun.bind(another)()  //老傻X年龄99
</code></pre>
<p>除了bind()方法后面多了一个<code>()</code>，其他都一样，返回结果也是相同的。</p>
<p>这是因为</p>
<p><code>call()</code>和<code>apply()</code>是<strong>立即调用函数</strong>，</p>
<p>而<code>bind()</code>绑定完this之后，不会立即调用当前函数，而是<strong>将函数返回</strong>，因此后面还需要加()来能使用</p>
<p><strong>2，对比call() 、bind() 、 apply()传参情况下</strong></p>
<p>当我们需要给函数传递参数时，call() 、bind() 、 apply()也能做到</p>
<pre><code class="language-javascript">        var name = &quot;老王&quot;
        var age = 45
        var obj = {
            name:&quot;老马&quot;,
            objAge:this.age, 
            objFun:function(a,b){//需要传递参数 a,b 
                console.log(this.name+&quot;年龄&quot;+this.age+&quot;,来自：&quot;+ a +&quot;，去往：&quot;+b);
            }
        }
</code></pre>
<pre><code class="language-javascript">        obj.objFun.call(another,&quot;河北&quot;,&quot;山西&quot;)    	//老傻X年龄99,来自：河北，去往：山西
        obj.objFun.apply(another,[&quot;河北&quot;,&quot;山西&quot;])   //老傻X年龄99,来自：河北，去往：山西
        obj.objFun.bind(another,&quot;河北&quot;,&quot;山西&quot;)()  	//老傻X年龄99,来自：河北，去往：山西   

		//错误传法
		obj.objFun.call(another,[&quot;河北&quot;,&quot;山西&quot;])    //老傻X年龄99,来自：河北,山西，去往：undefined
		obj.objFun.bind(another,[&quot;河北&quot;,&quot;山西&quot;])()  //老傻X年龄99,来自：河北,山西，去往：undefined   
</code></pre>
<p>从上面代码可以看出，</p>
<p>call()传参的方式和bind()传参的方式是相同的，</p>
<p>而apply传参需要把所有的参数放到一个数组里才可以</p>
<p>总结：<code>call()</code>、<code>apply()</code>和<code>bind()</code>的区别</p>
<ul>
<li>都能改变this的指向</li>
<li>call()/apply() 是<strong>立即调用函数</strong></li>
<li>bind()：绑定完this后，不会立即调用当前函数，而是<strong>将函数返回</strong>，因此后面还需要加（）才能调用</li>
<li>bind()传参和call()一样（单个单个的传）</li>
<li>apply() 传参需要把所有参数放到一个数组里</li>
</ul>
<h1 id="71-es6-的变量声明">7.1 ES6  的变量声明</h1>
<p>ES6中新增了<code>let</code>和<code>const</code>来定义变量：</p>
<ul>
<li><code>var</code>：ES5 和 ES6 中，定义<strong>全局变量</strong>（是varibale的简写）</li>
<li><code>let</code>：定义<strong>局部变量</strong>，替代var</li>
<li><code>const</code>：定义<strong>常量</strong>（定义后，不可修改）</li>
</ul>
<h2 id="var全局变量">var：全局变量</h2>
<p>看以下代码</p>
<pre><code class="language-JavaScript">        {
            var a = 23
        }

        console.log(a);//这里的 a 指的是 区块 里的 a
</code></pre>
<p>运行结果：</p>
<pre><code class="language-javascript">123
</code></pre>
<p>因为a<strong>不是函数中声明</strong>的，只是<strong>在一个区块</strong>中，所以a是<strong>全局</strong>声明</p>
<pre><code class="language-JavaScript">        var a = 1;
        {
            var a = 2;//会覆盖掉前边的a
        }
        
        console.log(a);
</code></pre>
<p>运行结果：</p>
<pre><code>2
</code></pre>
<p><strong>总结：</strong></p>
<p>用 var 定义的全部变量，有时候会污染整个 js 的作用域</p>
<h2 id="let定义局部变量">let：定义局部变量</h2>
<p>看以下代码</p>
<pre><code class="language-js">        var a =111	//全局的
        {
            let a = 123		//局部的
            console.log(a,&quot;内部&quot;);
        }
        console.log(a,&quot;外部&quot;);
</code></pre>
<p>运行结果：</p>
<pre><code class="language-js">123 &quot;内部&quot;
111 &quot;外部&quot;
</code></pre>
<p>下面再看一个代码，如果在</p>
<pre><code class="language-js">        var a =111
        {
            console.log(a);	//报错
            let a = 123
            console.log(a,&quot;内部&quot;);
        }
        console.log(a,&quot;外部&quot;);
</code></pre>
<p>运行结果：</p>
<pre><code>报错！
02let.html:12 Uncaught ReferenceError: Cannot access 'a' before initialization
    at 02let.html:12
</code></pre>
<p>用<code>let</code>声明的变量，只在局部（块级作用域内）起作用</p>
<p><code>let</code>可以防止数据污染。</p>
<p>我们来看下面这个for循环的例子，很经典</p>
<pre><code class="language-html">    &lt;button&gt;按钮1&lt;/button&gt;
    &lt;button&gt;按钮2&lt;/button&gt;
    &lt;button&gt;按钮3&lt;/button&gt;
    &lt;button&gt;按钮4&lt;/button&gt;
    &lt;button&gt;按钮5&lt;/button&gt;
    &lt;button&gt;按钮6&lt;/button&gt;
    &lt;button&gt;按钮7&lt;/button&gt;
    &lt;button&gt;按钮8&lt;/button&gt;
    &lt;button&gt;按钮9&lt;/button&gt;
    &lt;button&gt;按钮10&lt;/button&gt;
    &lt;script&gt;
        var allBtn = document.querySelectorAll(&quot;button&quot;)
        for(var i =1;i&lt;=10;i++){
            allBtn[i-1].onclick = function(){
                console.log(i);
            }
        }
    &lt;/script&gt;
</code></pre>
<p>以上的代码，当点击每个按钮的时候都会显示什么呢，</p>
<p>答案是：点击每个按钮显示11。因为onclick是异步操作，执行onclick函数的时候for循环已经执行完毕了，这个时候i=11，所以每个按钮点击的时候都会显示11</p>
<p>要想完成点击每个按钮返回相应的下标的话有以下几种方法：</p>
<p><strong>方法1.闭包</strong></p>
<p><strong>闭包内的参数和变量不会被垃圾回收机制回收</strong></p>
<pre><code class="language-JavaScript">        var allBtn = document.querySelectorAll(&quot;button&quot;)
        for (var i = 1; i &lt;= 10; i++) {
            allBtn[i - 1].onclick = (function (index) {
                return function () {
                    console.log(index);
                }
            })(i)
        }
</code></pre>
<p><strong>方法2：let</strong></p>
<pre><code class="language-js">        var allBtn = document.querySelectorAll(&quot;button&quot;)
        for(let i =1;i&lt;=10;i++){
            allBtn[i - 1].onclick = function(){
                console.log(i);
            }
        }
</code></pre>
<p>方法2仅需要把 var 改为 let 即可</p>
<p><strong>总结：<strong>我们要习惯用 let 声明，减少var声明带来的</strong>污染全局空间</strong>。</p>
<p>为了进一步说明 let 不会带来污染，需要说明的是：</p>
<p>当定义了<code>let a =1</code>时，如果在同一作用域内继续定义<code>let a = 2</code>，是会报错的</p>
<pre><code class="language-js">        {
            let a = 2
            let a = 3 //报错
        }
</code></pre>
<h2 id="const定义常量">const：定义常量</h2>
<p><strong>const 声明的变量被改变后会报错</strong></p>
<p>在程序开发中，有些变量是希望声明后，在业务层就不再发生变化，此时就可以用const来定义</p>
<p>比如说你们喜欢用的探探，在使用探探时，一旦选定性别，系统就不允许再改变，这个时候就可以用<code>const</code>来定义</p>
<pre><code class="language-js">        const GENDER = 0;   //在定义常量的时候最好使用大写字母，方便识别

        GENDER = 1      //报错

        console.log(GENDER);
</code></pre>
<p>用const声明的变量，只在<strong>局部</strong>（块级作用域内）起作用</p>
<h2 id="let-和-const-的作用重要">let 和 const 的作用【重要】</h2>
<p>let 和 const 的特点如下</p>
<ul>
<li>禁止重复声明</li>
<li>支持块级作用域（只在局部中起作用）</li>
<li>const被限制修改</li>
</ul>
<p>相反，用<code>var</code> 声明的变量：可以重复声明、没有块级作用域、不能限制</p>
<h1 id="81变量的解构赋值">8.1变量的解构赋值</h1>
<p>ES6允许我们，通过数组或者对象的方式，<strong>对一组变量进行赋值</strong>，这被成为解构。</p>
<p>解构赋值在实际开发中可以大量减少我们的代码量，并且让程序结构更清晰。</p>
<h2 id="数组的解构赋值">数组的解构赋值</h2>
<p><strong>举例：</strong></p>
<p>通常情况下，我们在为一组变量赋值时，一般是这样写：</p>
<pre><code class="language-js">let a = 0;
let b = 1;
let c = 2 ;
</code></pre>
<p>现在我们可以通过<strong>数组解构</strong>的方式进行赋值</p>
<pre><code>let [a,b,c] = [1, 2, 3]
</code></pre>
<p>拓展：</p>
<pre><code>        let [a1,b1,c1] = [1,2,3]
        console.log(a1,b1,c1);  //1 2 3

        let [a2,b2,c2] = [1,2]
        console.log(a2,b2,c2);  //1 2 undefined

        let [a3,b3,c3] = [1,,3]
        console.log(a3,b3,c3);  //1 undefined 3

        let [a4,b4,c4] = []
        console.log(a4,b4,c4);  //undefined undefined undefined

</code></pre>
<p><strong>解构的默认值：</strong></p>
<p>在解构赋值时，是允许使用默认值的。举例如下：</p>
<pre><code class="language-js">        let [a2,b2,c2 = 8] = [1,2]  //c2默认是 8 ,如果右边有值会覆盖，没值会使用默认值
        console.log(a2,b2,c2);  //1 2 8
</code></pre>
<h2 id="对象的解构赋值">对象的解构赋值</h2>
<p>首先我们看一看以前的代码</p>
<pre><code class="language-js">        let user = {
            name: &quot;蔡徐坤&quot;,
            type: &quot;NBA形象大使&quot;,
            like: &quot;篮球&quot;
        }

        //一个一个赋值，太麻烦
        let name = user.name;
        let type = user.type;
        let like = user.like


        console.log(name,type,like);
</code></pre>
<p>再看看对象的解构赋值：</p>
<pre><code class="language-js">        let user = {
            name: &quot;蔡徐坤&quot;,
            type: &quot;NBA形象大使&quot;,
            like: &quot;篮球&quot;
        }
        let {name,type,like} = user //变量名要和对象的属性名一致
        console.log(name,type,like);    //蔡徐坤 NBA形象大使 篮球
</code></pre>
<p>上方的代码可以看出，对象的解构和数组的解构，有一个重要的区别：</p>
<p>数组的元素是按次序排列的，变量的取值由它的位置决定；</p>
<p>而对象的属性没有次序，是根据键来取值的</p>
<h2 id="字符串解构">字符串解构</h2>
<pre><code class="language-js">        var str = &quot;helloWorld&quot;
        var [a,b,c,d,e,f] = str
        console.log(a,b,c,d,e,f);   //h e l l o W
</code></pre>
<h1 id="9-forof循环">9 for...of循环</h1>
<h2 id="数组的遍历">数组的遍历</h2>
<p>ES6中，如果我们要遍历一个数组，可以这样做：</p>
<pre><code class="language-js">    let arr = [1,2,3,4,5];

    for(let value of arr){
        console.log(value);
    }
</code></pre>
<p>输出结果：</p>
<pre><code>1
2
3
4
5
</code></pre>
<p>for...of 的循环可以避免我们开拓内存空间，增加代码运行效率，所以建议大家在以后的工作中使用for...of循环</p>
<p>注意，上面的数组，<code>for...of</code>获取的是数组里面的值，而<code>for...in</code>获取的是index索引值</p>
<h2 id="map对象的遍历">map对象的遍历</h2>
<pre><code class="language-js">    let a = new Map()
    a.set(&quot;username&quot;,&quot;admin&quot;)
    a.set(&quot;password&quot;,&quot;123456&quot;)

    for(let i of a){
        console.log(i);
    }
</code></pre>
<p>输出内容：</p>
<pre><code class="language-js">[&quot;username&quot;, &quot;admin&quot;]
[&quot;password&quot;, &quot;123456&quot;]
</code></pre>
<p>如果我们想获取单个的key和value，就可以使用我们上一个知识点：<strong>数组的解构赋值</strong></p>
<pre><code class="language-js">    let a = new Map()
    a.set(&quot;username&quot;,&quot;admin&quot;)
    a.set(&quot;password&quot;,&quot;123456&quot;)
    console.log(a);

	
    for(let [key,value] of a){
        console.log(key+&quot;--------&quot;+value);
    }
</code></pre>
<p>输出内容：</p>
<pre><code class="language-js">username--------admin
password--------123456
</code></pre>
<h1 id="10-模板字符串">10 模板字符串</h1>
<p>我们以前让字符串进行拼接的时候，是这样做的：（传统写法的字符拼接）</p>
<pre><code class="language-js">        let name = &quot;张三&quot;
        let age = 44
        console.log(&quot;我的名字是&quot;+name+&quot;,我今年&quot;+age+&quot;岁了。&quot;);
</code></pre>
<p>ES6的语法，字符串拼接可以这样写</p>
<pre><code class="language-js">        let name = &quot;张三&quot;
        let age = 44
        console.log(&quot;我的名字是&quot;+name+&quot;,我今年&quot;+age+&quot;岁了。&quot;);
        console.log(`我的名字是${name},我今年${age}岁了`);  //ES6字符串拼接

        // `${}`不仅可以用来进行字符串拼接，还可以用来进行运算等操作
</code></pre>
<p><strong>注意:</strong><code>${}</code>需要和``(键盘Esc下面的那个键)一起使用</p>
<p><code>${}</code>不仅可以<strong>拼接字符串</strong>，还可以进行<strong>数学运算</strong>和<strong>函数调用</strong></p>
<pre><code class="language-js">        let price = 10
        let num =50

        console.log(`总价是${price*num}`);			//总价是500

        // 调用函数
        function content(){
            return &quot;啦啦啦德玛西亚~&quot;
        }
        console.log(`歌词是：${content()}`);		//歌词是：啦啦啦德玛西亚~
</code></pre>
<h1 id="11-es6函数扩展">11 ES6函数扩展</h1>
<h2 id="箭头函数-通常把一个函数作为另外一个函数的参数的时候使用">箭头函数----通常把一个函数作为另外一个函数的参数的时候使用</h2>
<p><strong><mark>箭头函数中的this，引用的就是最近作用域中的this</mark></strong></p>
<p>向外层作用域中一层层查找this直到有this的定义</p>
<p>定义和调用函数：（传统写法）</p>
<pre><code class="language-js">        function fn1(a,b){
            return a + b
        }
        console.log(fn1(1,2));   //输出结果：3
</code></pre>
<p>定义和调用函数：（ES6的写法）</p>
<pre><code class="language-js">        let fn2 = (a,b) =&gt; a + b

        console.log(fn2(1,2));   //输出结果：3
</code></pre>
<p>二者效果是一样的。</p>
<p>在箭头函数中，如果方法体内有两句话或者以上的话，那就需要在方法体外边加上<code>{}</code>括号。如下：</p>
<pre><code class="language-js">        let fn3 = (a,b) =&gt;{
            let c = a+b
            return c
        }
        console.log(fn3(1,2));	  //输出结果：3
</code></pre>
<p>从上面的箭头函数中，我们可以很清晰的找到函数名、参数名、方法体。</p>
<p>箭头函数还有一个很重要的点是<strong>this指向问题</strong></p>
<p>举个例子：</p>
<p>现在我们创建一个div，点击div以后每隔1秒之后变色</p>
<p>css:</p>
<pre><code>        #d1{
            width: 200px;
            height: 200px;
            background-color: pink;
        }
</code></pre>
<p>html:</p>
<pre><code class="language-html">    &lt;!-- 点击div，使得div每隔1秒钟改变颜色 --&gt;
    &lt;div id = &quot;d1&quot;&gt;&lt;/div&gt;
</code></pre>
<p>js:</p>
<pre><code class="language-js">        let div = document.querySelector(&quot;#d1&quot;)
        div.onclick = function(){
            setInterval(function(){
                let r = Math.random()*255;	//随机颜色
                let g = Math.random()*255;	//随机颜色
                let b = Math.random()*255;	//随机颜色
                this.style.backgroundColor = `rgb(${r},${g},${b})`	//原本这里的this是指向window的，所以我们在后面添加了.bind(this)，把当前函数的外嵌函数的this传了过来，用来改变this指向，操作完成后this指向的便是div了
            }.bind(this), 1000);//改变this指向
        }
</code></pre>
<p>还有一种方法就是利用我们新学的箭头函数</p>
<pre><code class="language-js">        div.onclick = function(){
            console.log(this,&quot;outer&quot;);
            setInterval(()=&gt;{	//此时this = 它的外嵌方法的this
                let r = Math.random()*255;
                let g = Math.random()*255;
                let b = Math.random()*255;
                this.style.backgroundColor = `rgb(${r},${g},${b})`//此时this = 它的外嵌方法的this
            },1000)
        }
</code></pre>
<p>有一个辨别this指向谁技巧就是，看当前箭头函数的<strong>上一行</strong>，它的this是谁，该箭头函数的this就是谁</p>
<h2 id="默认参数">默认参数</h2>
<p>要求：假如一个函数有两个形参，但是在调用的时候没有传入参数，这时候函数给自己设置一个默认值，应该怎么操作</p>
<p>以前的代码：</p>
<pre><code class="language-js">        function fn(a,b){
            a = a?a:1
            b = b?b:1
            return a+b
        }

        console.log(fn());  //2
</code></pre>
<p>ES6中：</p>
<pre><code class="language-js">		//在未传参的情况下,a默认是1，b默认是1
		function fn(a=1,b=1){
            return a+b
        }

        console.log(fn());  //2
</code></pre>
<p>拓展：</p>
<pre><code class="language-js">        var a = 3
        //在未传参的情况下,a默认是4，b默认是a,也就相当于是4，因为要使用function中的局部变量
        function fn2(a=4,b=a){
            console.log(a,&quot;a&quot;); //4
            console.log(b,&quot;b&quot;); //4
            return a+b
        }

        console.log(fn2());  //8
</code></pre>
<h2 id="扩展运算符">扩展运算符</h2>
<p>注意区分：</p>
<ul>
<li>扩展运算符格式为<code>...</code></li>
<li>rest运算符为<code>...变量名</code></li>
</ul>
<p><strong>使用场景1：</strong></p>
<p><strong>复制数组</strong></p>
<pre><code class="language-js">        var arr = [&quot;小明&quot;,&quot;小铭&quot;,&quot;小澎&quot;,&quot;小鹏&quot;]

        // 扩展运算符复制数组
        var arr1 =[...arr]

        console.log(arr,&quot;arr&quot;);		//[&quot;小明&quot;, &quot;小铭&quot;, &quot;小澎&quot;, &quot;小鹏&quot;] &quot;arr&quot;
        console.log(arr1,&quot;arr1&quot;);	//[&quot;小明&quot;, &quot;小铭&quot;, &quot;小澎&quot;, &quot;小鹏&quot;] &quot;arr1&quot;

		//两个数组的地址不一样
        console.log(arr==arr1);		//false
</code></pre>
<p>拓展：</p>
<pre><code class="language-js">		var arr = [&quot;小明&quot;,&quot;小铭&quot;,&quot;小澎&quot;,&quot;小鹏&quot;]
        var arr2 = arr
        arr2.push(&quot;小二&quot;)
        console.log(arr);
        console.log(arr2);
</code></pre>
<p>运行结果：</p>
<pre><code class="language-js">[&quot;小明&quot;, &quot;小铭&quot;, &quot;小澎&quot;, &quot;小鹏&quot;, &quot;小二&quot;]
[&quot;小明&quot;, &quot;小铭&quot;, &quot;小澎&quot;, &quot;小鹏&quot;, &quot;小二&quot;]
</code></pre>
<p>造成这样的运行结果是因为上方代码 <code>var arr2 = arr</code>，是直接让arr2指向arr的地址，也就是说arr2和arr指向的是同一地址，只要其中一个操作改变，那么两个都会改变。</p>
<p>要想改变这种状况就可以使用我们的<code>...</code>,也就是<strong>复制数组</strong>部分的代码</p>
<p><strong>注意：</strong><code>...</code>不是深拷贝，<code>...</code>只能拷贝一层，如果是第二层或者以上的话依然是引用指针</p>
<p><strong>使用场景2：</strong></p>
<p><strong>遍历传参</strong></p>
<pre><code class="language-js">//		...也支持传参
        var arr = [&quot;小明&quot;,&quot;小铭&quot;,&quot;小澎&quot;,&quot;小鹏&quot;]
        function fn1(a,b,c,d){
            console.log(a);
            console.log(b);
            console.log(c);
            console.log(d);
        }

        fn1(...arr)	//等同于fn1(arr[0],arr[1],..........,arr[arr.length-1])
</code></pre>
<p>运行结果：</p>
<pre><code class="language-js">小明
小铭
小澎
小鹏
</code></pre>
<h2 id="rest运算符"><code>rest</code>运算符</h2>
<p><code>rest</code>在英文中指的是<strong>剩余部分</strong>。我们举个例子，理解剩余部分的含义：</p>
<pre><code class="language-js">        function fn(first,seconde,...arg){
            console.log(first);
            console.log(seconde);

            console.log(arg);
            console.log(arg.length);
            // console.log(arguments);
        }

        fn(0,1,2,3,4,5,6);
</code></pre>
<p>运行结果：</p>
<pre><code>0
1
[2, 3, 4, 5, 6]
5
</code></pre>
<p><strong>不确定参数的函数</strong></p>
<p>当我们想定义一个方法，但是不确定其参数的个数时，我们也可以用<strong>rest运算符</strong>作为参数。</p>
<pre><code class="language-js">//		以前的参数需要确定个数，以下程序会报错
		function fn(a,b,c){
            console.log(a);
            console.log(b);
            console.log(c);
            console.log(d); //报错:  d is not defined
        }       
        fn(1,2,3)



//		现在有了扩展运算符，就不用担心报错的问题了。代码可以这样写
        function fn2(...arg){   //当不确定方法的参数时，可以使用扩展运算符,这里的“arg”是随便起的
            console.log(arg[0],&quot;arg[0]&quot;);
            console.log(arg[1],&quot;arg[1]&quot;);
            console.log(arg[2],&quot;arg[2]&quot;);
            console.log(arg[3],&quot;arg[3]&quot;);
        }

        fn(1,2,3)   //方法中定义了四个参数，但只引用了三个参数，ES6中并不会报错
</code></pre>
<p>第二个方法的运行结果：</p>
<pre><code class="language-js">1 &quot;arg[0]&quot;
2 &quot;arg[1]&quot;
3 &quot;arg[2]&quot;
undefined &quot;arg[3]&quot;
</code></pre>
<p>谈到<code>...</code>我们顺便说一下<code>arguments</code></p>
<h2 id="arguments">arguments</h2>
<p><strong>一、功能</strong></p>
<p><strong>每一个函数，即使你什么参数都没有传，里面也会有一个<code>arguments</code></strong></p>
<p>我们来看一下</p>
<pre><code class="language-js">        function fn1 (){
            console.log(arguments);
        }

        fn1()
</code></pre>
<p>运行结果：（先只看length）</p>
<figure data-type="image" tabindex="8"><img src="C:%5CUsers%5CMaMing%5CDesktop%5Cdemo%5CES6~ES11%5C01README.assets%5Cimage-20200921152825151.png" alt="image-20200921152825151" loading="lazy"></figure>
<p>在没有传递任何参数的时候，arguments的length为0，或许我们已经猜到Arguments的作用是什么了。</p>
<p>没错，<strong>arguments是用来记录当前函数传递的实参的</strong></p>
<p>我们再来看一个例子：</p>
<pre><code class="language-js">        function fn2 (a){
            console.log(a);
            console.log(arguments);
            console.log(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);
            
        }

        fn2(1,2,3,4,5)
</code></pre>
<p>函数<code>fn2</code>才设置了一个形参a，但是我们传递了五个参数。</p>
<p>这时候我不止想获取到a，我还想把其他四个参数获取到，就可以用到<code>arguments</code>.</p>
<p>运行结果：</p>
<figure data-type="image" tabindex="9"><img src="C:%5CUsers%5CMaMing%5CDesktop%5Cdemo%5CES6~ES11%5C01README.assets%5Cimage-20200921155347879.png" alt="image-20200921155347879" loading="lazy"></figure>
<p>我们可以看到，arguments像一个数组一样把所有的参数都保存了下来，</p>
<p>然而arguments并不是一个数组，<strong>arguments是一个类似数组（类数组）</strong></p>
<br>
<br>
<br>
<p><strong>二、属性</strong></p>
<p>现在我们知道了arguments的功能，接下来我们看一下它的属性</p>
<p><code>callee</code></p>
<p><strong>callee是一个方法，而且这个方法就是我们定义的这个方法</strong></p>
<p>为了方便阅读，我们写如下代码：</p>
<pre><code class="language-js">        function fn2 (a){      
            // 我调我自己
            fn2(1)
        }

        fn2(1,2,3,4,5)
</code></pre>
<p>以上代码同等于：</p>
<pre><code class="language-js">        function fn2 (a){
            // 我调我自己
            callee(1)
        }

        fn2(1,2,3,4,5)
</code></pre>
<p>注：以上两个程序会陷入死循环，但是为了简洁阅读我就没有添加多余的条件。</p>
<p>当使用<strong>arguments</strong>进行函数传递时，有一些需要注意的点。例子如下：</p>
<pre><code class="language-js">var length = 10;
function fn() {
  console.log(this.length);
}

var obj = { 
  method: function(fn) {
    fn();
    arguments[0]();
  }
};

obj.method(fn, 1); 
</code></pre>
<p>运行结果：</p>
<pre><code class="language-js">10
2
</code></pre>
<p>这里有2个需要注意的点。fn函数里面的this的指向：</p>
<p>1.第一个值为10，执行的是method里面的第一行<code>fn()</code>,这里this指向的window。所以输出的值为最外层定义的length。</p>
<p>2.第二个值为2，执行的是method里面的第二行<code>arguments[0]()</code>（arguments[0]() =&gt; fn() ），<strong>这里this执行的是arguments这个对象</strong>,所以输出值为<code>arguments</code>的长度</p>
<p>....<strong>Symbol类型的键</strong>暂未揭晓</p>
<h1 id="12-新增基本数据类型">12 新增基本数据类型</h1>
<p>我们先来复习一下js的所有<strong>数据类型：</strong></p>
<p>ES5中的数据类型：Number、Boolean、String、undefined、null、Object</p>
<p>其中，基本数据类型为：Number、String、Boolean、undefined、null</p>
<p>ES6中新增了一个基本数据类型——Symbol类型，是<strong>独一无二的值</strong></p>
<p>Symbol 类型的对象<strong>永远不相等，即便创建的时候传入相同的值</strong>。</p>
<pre><code class="language-js">        let s = Symbol(&quot;asd&quot;)
        let s2 = Symbol(&quot;asd&quot;)
        console.log(s===s2);    //false
        console.log(s==s2);    //false

		console.log(s);			//Symbol(asd)
		console.log(typeof s);	//symbol
</code></pre>
<p>运行结果：</p>
<pre><code>false
false
Symbol(asd)
symbol
</code></pre>
<p><strong>注意</strong>，<strong><code>Symbol</code>函数前不能使用<code>new</code>命令</strong>，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p>
<h1 id="13-promise">13 Promise</h1>
<h2 id="概述">概述：</h2>
<p>内部代码：</p>
<pre><code class="language-js">class MPromise {
            constructor(fn) {
                this.successList = []
                this.failList = []
                // pending ,fullfilled,rejected
                this.state =&quot;pending&quot;
                fn(this.resolveFn.bind(this),this.rejectFn.bind(this))
            }
            then(successFn, failFn) {
                if (typeof successFn == &quot;function&quot;) {
                    this.successList.push(successFn)
                }
                if (typeof failFn == &quot;function&quot;) {
                    this.failList.push(failFn)
                }
            }
            catch(failFn) {
                if (typeof failFn == &quot;function&quot;) {
                    this.failList.push(failFn)
                }
            }
            resolveFn(res){
                this.state =&quot;fullfilled&quot;
                this.successList.forEach(function(item,index){
                    // 将成功的实践循环调用
                    item(res)
                })
            }
            rejectFn(res){
                this.state =&quot;reject&quot;

                // 注册到的失败所有事件进行调用
                this.failList.forEach(function(item,index){
                    item(res)
                })

            }
        }


        var p1 = new MPromise(function (resolve, reject) {
            setTimeout(function () {
                if (true) {
                    resolve(&quot;成功&quot;)
                } else {
                    reject(&quot;失败&quot;)
                }
            }, 1000)
        })

        p1.then(function (res) {
            console.log(&quot;成功啦！1&quot;);
        })
        p1.then(function (res) {
            console.log(&quot;成功啦！2&quot;);
        })

        p1.catch(function () {
            console.log(&quot;失败了┭┮﹏┭┮&quot;);
        })
</code></pre>
<h1 id="14-async-await">14 async await</h1>
<p>先从字面意思来理解，async是“异步”的意思，而 await是等待的意思。所以应该很好理解async用于声明一个异步的function（实际上是async function 对象），而await用于等待一个异步任务执行完成的结果。</p>
<p>并且await 只能出现在async函数中</p>
<pre><code class="language-js">        var fnPromise1 = function () {
            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    // resolve会传给下方的await调用函数
                    resolve(&quot;0.5s输出&quot;)
                }, 500)
            })
        }
        var fnPromise2 = function () {
            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    // resolve会传给下方的await调用函数
                    resolve(&quot;1.5秒输出&quot;)
                }, 1500)
            })
        }
        var fnPromise3 = function () {
            return new Promise(function (resolve, reject) {
                // 下方可以用try...catch捕捉
                reject(&quot;失败了&quot;)
            })
        }


        async function demo() {
            // 一层层等待
            var result1 = await fnPromise1()
            // 执行完第一个之后才能执行下一个
            var result2 = await fnPromise2()
            console.log(result1);
            console.log(result2);
            try {
                var result3 = await fnPromise3()

            } catch (e) {
                console.log(e);
            }

        }

        demo()



        // var p1 = fnPromise()
        // p1.then(res=&gt;{
        //     console.log(res);
        // })
</code></pre>
<h1 id="15-迭代器iterator与生成器generator">15 迭代器（Iterator）与生成器（Generator）</h1>
<h2 id="迭代器">迭代器</h2>
<p>迭代器是什么？</p>
<p><strong>迭代器是一种特殊对象，每个迭代器对象都有一个next()，该方法返回一个对象，包括value和done属性</strong></p>
<p><strong>ES5实现迭代器代码如下</strong></p>
<pre><code class="language-js">        var arr = [0, 1, 1, 2, 3, 6, 9, 15, 24]
        //实现一个返回迭代器的对象的函数，注意该函数不是迭代器，返回的结果才叫迭代器。
        function createIterator(count) {
            var num = 0
            return {
                pre1: 0,
                pre2: 0,
                next: function () {
                    if(num&gt;count){
                        return{
                            done:true,
                            value:undefined
                        }
                    }
                    if (num == 0||num == 1) {
                        num++
                        return {
                            // done代表事情做完没有
                            done: false,
                            value: num
                        }
                    }else{
                        num++
                        // console.log(num,&quot;num&quot;);
                        // console.log(this.pre1,&quot;pre1&quot;);
                        // console.log(this.pre2,&quot;pre2&quot;);
                        result = this.pre1+this.pre2
                        this.pre2 = this.pre1
                        this.pre1 = result
                        return{
                            done: false,
                            value: result
                        }
                    }
                    num++
                }
            }

        }

        var user = new Map()
        user.set(&quot;username&quot;,&quot;小明&quot;)
        user.set(&quot;password&quot;,&quot;123456&quot;)
        user.set(&quot;age&quot;,&quot;20&quot;)
        console.log(user);
        // user 可迭代，因为他有user.entries()方法
        // user.entries()方法里面就有next()方法
        var userIterator =user.entries()
        console.log(userIterator.next());

        for(let s of userIterator){
            console.log(s,&quot;of userIterator&quot;);
        }

        var a = createIterator();
        for(let value of a){
            // 如果只有next，不是一个正宗的迭代器
            console.log(value,&quot;a&quot;);
        }
</code></pre>
<h2 id="生成器">生成器</h2>
<p><strong>生成器是函数：用来返回迭代器</strong></p>
<p>这个概念有2个关键点，一个是函数、一个是返回迭代器。这个函数不是上面ES5中创建迭代器的函数，而是ES6中特有的，一个带有*（星号）的函数，同时也需要使用到yield</p>
<p>yield关键字有个神奇的功能，就是当你执行一次next(),那么只会执行一个yield后面的内容，然后语句终止运行</p>
<pre><code class="language-js"> // 函数名字前面加*，yield
        function* easy() {
            yield 1
            yield 2
            yield 3
            yield 4
        }
        // 创建方法的时候并不运行，当执行.next()的时候执行，且每next一次，执行一次yield，从后中断
        let easyAIterator = easy()
        // 该方法的原型有Generator方法，其中有next()方法
        console.log(easyAIterator);

        for (let i of easyAIterator) {
            console.log(i);

        }


	//增加以下难度
        function* difficult(count) {
            let num = 0
            let pre1 = 0
            let pre2 = 0
            if (num == 0) {
                pre1 = 1
                num++
                // yield {
                //     // yield默认的done为false，所有不必添加done
                //     done: false,
                //     value: num
                // }
                yield num
            }
            while (true) {
                num++
                let result = pre1 + pre2
                pre2 = pre1
                pre1 = result
                yield result

                if (num &gt;= count) {
                    // 如果没有yield，直接break，*difficult没有返回值，就自动停止了
                    break
                }
            }





        }

        var diffAIterator = difficult(5)
        for(let i of diffAIterator){
            console.log(i,&quot;diffAIterator&quot;)
        }
        console.log(diffAIterator);
</code></pre>
<p>迭代器的应用</p>
<pre><code class="language-js"> /* 调用生成器的对象叫迭代器 */
        var priceAll = [100, 99, 6, 46, 4, 9465, 12, 3, 46, 4, 89, 489, 12, 654, 654,]
        
        function* priceGenerator(priceAll) {
            for(let i =0;i&lt;priceAll.length;i++){
                let result = &quot;$&quot;+priceAll[i]
                yield result
            }
        }

        var priceAIterator =priceGenerator(priceAll)
        console.log(priceAIterator); 

        for(let i of priceAIterator){
            console.log(i);
        }

</code></pre>
<h2 id="创建可迭代对象">创建可迭代对象</h2>
<p><strong>在ES6中，数组、Set、Map、字符串都是可迭代对象。</strong></p>
<p><strong>默认情况下定义的对象（object）是不可迭代的，但是可以通过Symbol.iterator创建迭代器</strong></p>
<pre><code class="language-js">        // 数组是支持迭代的
		var a = [&quot;小明&quot;, &quot;小青&quot;, &quot;小宋&quot;, &quot;小马&quot;, &quot;小明&quot;]

        for (value of a) {
            console.log(value);
        }
        console.log(&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;);

        // Set可迭代。Set类似数组,但成员的值是唯一的（不可重复）,没有顺序
        var s = new Set(a)
        console.log(s);

        for (let value of s) {
            console.log(value);
        }

        console.log(&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;);
        // 字符串也可迭代
        var b = &quot;helloWorld&quot;
        console.log(b);
        for (let value of b) {
            console.log(value);
        }

        console.log(&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;);
        // Map对象也可迭代
        var user = new Map()
        user.set(&quot;name&quot;, &quot;小明&quot;)
        user.set(&quot;age&quot;, 18)
        user.set(&quot;gender&quot;, &quot;男&quot;)
        user.set(&quot;hobby&quot;, &quot;run&quot;)
        console.log(user);

        for (let [key, value] of user) {
            console.log(key, value);
        }


        // 但是Object对象不可迭代
        var student = {
            &quot;name&quot;: &quot;小黑&quot;,
            &quot;age&quot;: 18
        }
        // for (const value of student) {// 报错student is not iterable
        //     // console.log(value); 
        //     // 如果有Symbol.iterator函数则可以迭代
        // }
       	console.log(&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;);

        // 现在想让Object迭代可以这样做
        let student2 = {
            &quot;name&quot;: &quot;罗小黑&quot;,
            &quot;age&quot;: 18,
            &quot;gender&quot;: &quot;男&quot;,

            // *[Symbol.iterator]此方法可以帮助我们将任意的对象编程可迭代对象
            *[Symbol.iterator]() {
                for(let key in this){
                    yield [key,this[key]];
                }
                
            }
        }
        console.log(student2);

        for (const value of student2) {
            console.log(value);
        }

</code></pre>
<p>运行结果：</p>
<pre><code class="language-js">小明
小青
小宋
小马
小明
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Set(4) {&quot;小明&quot;, &quot;小青&quot;, &quot;小宋&quot;, &quot;小马&quot;}
小明
小青
小宋
小马
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
helloWorld
h
e
l
l
o
W
o
r
l
d
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Map(4) {&quot;name&quot; =&gt; &quot;小明&quot;, &quot;age&quot; =&gt; 18, &quot;gender&quot; =&gt; &quot;男&quot;, &quot;hobby&quot; =&gt; &quot;run&quot;}
name 小明
age 18
gender 男
hobby run
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
{name: &quot;罗小黑&quot;, age: 18, gender: &quot;男&quot;, Symbol(Symbol.iterator): ƒ}
 [&quot;name&quot;, &quot;罗小黑&quot;]
 [&quot;age&quot;, 18]
 [&quot;gender&quot;, &quot;男&quot;]
</code></pre>
<h3 id="内建迭代器">内建迭代器</h3>
<p>上面提到了，数组、Set、Mat都是可迭代对象，即它们内部实现了迭代器，并且提供了3种迭代器函数调用。</p>
<p><strong>1、entries()返回迭代器</strong>：返回键值对</p>
<pre><code class="language-js">        //数组
		var a = [&quot;小明&quot;, &quot;小青&quot;, &quot;小宋&quot;, &quot;小马&quot;, &quot;小明&quot;]
        let A = a.entries()
        console.log(A);
        for ([key,value] of A) {
            console.log(key,value);
        }
        console.log(&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;);

		//Set
		var s = new Set([&quot;小明&quot;, &quot;小青&quot;, &quot;小宋&quot;, &quot;小马&quot;, &quot;小明&quot;])
        console.log(s);
        for (let v of s.entries()) {
            console.log(v);
        }
        console.log(&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;);


		//Map
		var user = new Map()
        user.set(&quot;name&quot;, &quot;小明&quot;)
        user.set(&quot;age&quot;, 18)
        user.set(&quot;gender&quot;, &quot;男&quot;)
        user.set(&quot;hobby&quot;, &quot;run&quot;)
        for (let v of user.entries()) {
            console.log(v);
        }
</code></pre>
<p>运行结果：</p>
<pre><code> Array Iterator {}
 	__proto__: Array Iterator
 0 &quot;小明&quot;
 1 &quot;小青&quot;
 2 &quot;小宋&quot;
 3 &quot;小马&quot;
 4 &quot;小明&quot;
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Set(4) {&quot;小明&quot;, &quot;小青&quot;, &quot;小宋&quot;, &quot;小马&quot;}
 (2) [&quot;小明&quot;, &quot;小明&quot;]
 (2) [&quot;小青&quot;, &quot;小青&quot;]
 (2) [&quot;小宋&quot;, &quot;小宋&quot;]
 (2) [&quot;小马&quot;, &quot;小马&quot;]
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 (2) [&quot;name&quot;, &quot;小明&quot;]
 (2) [&quot;age&quot;, 18]
 (2) [&quot;gender&quot;, &quot;男&quot;]
 (2) [&quot;hobby&quot;, &quot;run&quot;]
</code></pre>
<p>**values()返回迭代器：**返回键值对的value</p>
<pre><code class="language-js">        //数组
		var a = ['a','b','c']
        for (let v of a.values()) {
            console.log(v);
        }
		//'a' 'b' 'c'


		//Set
		var s = new Set(['a','b','c'])
        for (let v of s.values()) {
            console.log(v);
        }
		//'a' 'b' 'c'


		//Map
		var user = new Map()
        user.set(&quot;a&quot;, &quot;a&quot;)
        user.set(&quot;b&quot;, &quot;b&quot;)
        for (let v of user.values()) {
            console.log(v);
        }
		//	&quot;a&quot; &quot;b&quot;

</code></pre>
<p><strong>3、keys返回迭代器</strong>：返回键值对的key</p>
<pre><code class="language-js">        //数组
        var a = ['a','b','c']
        for (let v of a.keys()) {
            console.log(v);
        }
        //0 1 2


        //Set
        var s = new Set(['a','b','c'])
        for (let v of s.keys()) {
            console.log(v);
        }
        //'a' 'b' 'c'


        //Map
        var user = new Map()
        user.set(&quot;a&quot;, &quot;a&quot;)
        user.set(&quot;b&quot;, &quot;b&quot;)
        for (let v of user.keys()) {
            console.log(v);
        }
        //	&quot;a&quot; &quot;b&quot;

</code></pre>
<h3 id="nodelist-迭代器">NodeList 迭代器</h3>
<p>迭代器真是无处不在，dom节点的迭代器来尝试下吧</p>
<pre><code class="language-html">    &lt;div&gt;内容1&lt;/div&gt;
    &lt;div&gt;内容2&lt;/div&gt;
    &lt;div&gt;内容3&lt;/div&gt;
    &lt;div&gt;内容4&lt;/div&gt;
    &lt;div&gt;内容5&lt;/div&gt;
    &lt;div&gt;内容6&lt;/div&gt;
    &lt;div&gt;内容7&lt;/div&gt;
    &lt;div&gt;内容8&lt;/div&gt;
    &lt;script&gt;
        var divs =document.querySelectorAll(&quot;div&quot;)
        var h3s =document.getElementsByTagName(&quot;h3&quot;)
        /* querySelectorAll和getElementsByTagName输出来的不相同
        querySelectorAll获取到的是NodeList
        getElementsByTagName是HTMLCollection
         */
        console.log(divs);
        console.log(h3s);
        for(let value of divs){
            console.log(value,&quot;divs&quot;);
        }

        for(let value of h3s){
            console.log(value,&quot;h3s&quot;);
        }

    &lt;/script&gt;
</code></pre>
<p>打印结果：</p>
<figure data-type="image" tabindex="10"><img src="C:%5CUsers%5CMaMing%5CDesktop%5Cdemo%5CES6~ES11%5C01README.assets%5Cimage-20200924165418693.png" alt="image-20200924165418693" loading="lazy"></figure>
<h3 id="展开运算符与迭代器">展开运算符与迭代器</h3>
<pre><code class="language-js">        var a =[1,2,3]
        var b =[4,5,6]
        // 展开运算符
        var c =[...a,...b]
        console.log(c);

        // 同样适用到迭代对象上
        function *abc(){
            yield 1
            yield 5
            yield 10
        }
        var tt = abc()
        var e =[...tt]
        console.log(e);
</code></pre>
<p>输出结果：</p>
<pre><code class="language-js">[1, 2, 3, 4, 5, 6]
[1, 5, 10]
</code></pre>
<h3 id="高级迭代器功能">高级迭代器功能</h3>
<p>迭代器的高级功能，</p>
<p>传参、抛出异常、生成器返回语句、委托生成器</p>
<p><strong>1、传参</strong></p>
<p>生成器里面有2个yield，当执行第一个next()的时候，返回value为1，然后给第二个next()传入参数10，传递的参数会替代掉上一个next()的yield返回值。下面例子中就是first</p>
<pre><code class="language-js">        function* createIterator() {
            let first = yield 1
            yield  first + 2
        }
        let i = createIterator();
        console.log(i.next());	//	{value: 1, done: false}
        console.log(i.next(10));	//{value: 12, done: false}

</code></pre>
<p><strong>2、在迭代器中抛出错误</strong></p>
<pre><code class="language-js">        function* createIterator() {
            let first = yield 1
            yield first + 2
        }
        let i = createIterator();
        console.log(i.next());			//{value: 1, done: false}
        console.log(i.throw(new Error(&quot;我是错误&quot;)));   //Uncaught Error: 我是错误
        console.log(i.next());   //不再执行
</code></pre>
<p><strong>3、生成器返回语句</strong></p>
<p>生成器中添加return表示退出操作</p>
<pre><code class="language-js">        function* createIterator() {
            let first = yield 1
            return	//中断
            yield first + 2
        }

        let i = createIterator();
        console.log(i.next());  //{value: 1, done: false}
        console.log(i.next());  //{value: undefined, done: true}
</code></pre>
<p><strong>委托生成器</strong></p>
<p>生成器嵌套生成器</p>
<pre><code class="language-js">        var AIterator = function*(){
            yield 1
            yield 2
            yield 3
        }
        var BIterator = function*(){
            yield 4
            yield 5
            yield 6
        }
        
        var CIterator = function*(){
            // 嵌套迭代器，一定不要忘了加*
            yield *AIterator()
            yield *BIterator()
        }
        var c = CIterator()
        for(let value of c){
            console.log(value);
        }
</code></pre>
<p>运行结果：</p>
<pre><code>1
2
3
4
5
6
</code></pre>
<h3 id="异步任务执行器">异步任务执行器</h3>
<p>ES6之前，我们使用异步的操作方式是调用函数并执行回调函数</p>
<p>书上举的例子挺好的，在nodejs中，有一个读取文件的操作，使用的就是回调函数的方式</p>
<pre><code class="language-js">	//fs ----&gt; file System
	var fs = require(&quot;fs&quot;)
	fs.readFile(&quot;xx.json&quot;,function(err,contents){
        //在回调函数中国做一些事情
    })
</code></pre>
<p>那么任务执行器是什么呢？</p>
<p><strong>任务执行器是一个函数，用来循环执行生成器，因为我们知道生成器需要执行N次next()方法，才能运行完，所以我们需要一个自动任务执行器帮我们做这些事情，这就是任务执行器的作用</strong></p>
<p>下面我们编写一个异步任务执行器。</p>
<pre><code class="language-js">  function *aIterator(){
            yield 1
            yield 3
            yield 5
            yield 7
            yield 9
            yield 11
        }


        // 用run函数来替代运行，这个run就是执行器
        function run (fnIter,fn) {
            let iterator = fnIter()
            while(true){
                // next函数中有done值和value值
                let {value,done} = iterator.next();
                if(done){
                    break
                }else{
                    fn(value)
                }
            }
        }
        run(aIterator,(value)=&gt;{
            console.log(value+10);
        })
</code></pre>
<h1 id="16代理proxy">16代理Proxy</h1>
<p>proxy这个词相信你已经听了无数遍了</p>
<p><strong>语法</strong></p>
<pre><code class="language-js">        let pUser =new Proxy(targe,handler)
</code></pre>
<p>target：一个目标对象（可以是任何类型的对象，包括本机数组，函数，甚至另一个代理）用Proxy来包装。</p>
<p>handler：一个对象，其属性是当执行一个操作时定义代理的行为的函数</p>
<h4 id="代理的使用">代理的使用</h4>
<p>**基础demo：**Proxy的demo有很多，我们只分析基础demo，主要看new Proxy({},handler)的操作，指定目标obj对象，然后handler对象执行get()操作，get()返回值的判断是，如果name是target目标对象的属性，则返回target[name]的值，否则返回37，</p>
<pre><code class="language-js">        let user = {
            name: &quot;小明&quot;,
            age: 16
        }

        // 设置代理对象,第一个参数要代理的对象，第二个参数是要做的事情
        let pUser =new Proxy(user,{
            // target就是对象
            // 每次从pUser中获取属性的时候运行该函数
            get(target,attr){
                // console.log(target);
                // console.log(attr);

                // 如果不return 的话是拿不到数据的
                return target[attr]
            },

            // 每次从pUser中设置或者改变属性的时候运行该函数
            set(target,attr,value){
                // console.log(target);
                // console.log(attr);
                // console.log(value); 
                // 如果不设置的话是改变不了的
                target[attr] = value;
            }

            
            
            
        })

       let age =  pUser.age
       pUser.age=123
</code></pre>
<p><strong>代理的运用</strong></p>
<pre><code class="language-js">        let DOM = new Proxy({}, {
            get(target,attr) {
                // console.log(123);
                var domObj = document.createElement(attr)
                return function (attrs,...children) {
                    for(key in attrs){
                        domObj.setAttribute(key,attrs[key])
                    }
                    for(let i =0;i&lt;children.length;i++){
                        if(typeof children[i] ==&quot;string&quot;){
                            children[i] = document.createTextNode(children[i])
                        }
                        domObj.appendChild(children[i])
                    }
                    return domObj
                }
            }
        })
        var d1 =DOM.div({id:&quot;d1&quot;,&quot;class&quot;:&quot;redBg&quot;},&quot;helloWorld&quot;,&quot;你好&quot;)
        document.body.appendChild(d1)

        var ul =DOM.ul(
            {id:&quot;lieBiao&quot;,&quot;class&quot;:&quot;redBg&quot;},
            DOM.li({&quot;class&quot;:&quot;li&quot;},&quot;列表1&quot;),
            DOM.li({&quot;class&quot;:&quot;li&quot;},&quot;列表2&quot;),
            DOM.li({&quot;class&quot;:&quot;li&quot;},&quot;列表3&quot;),
            DOM.li({&quot;class&quot;:&quot;li&quot;},&quot;列表4&quot;),
        )
        document.body.appendChild(ul)

</code></pre>
<h1 id="其他">其他</h1>
<h2 id="深拷贝和浅拷贝的区别以及实现">深拷贝和浅拷贝的区别以及实现</h2>
<p>浅拷贝：假设A复制了B,当修改A时，B也跟着变化了，那么这就是浅拷贝。</p>
<p>深拷贝：A复制了B，当修改A时，B没有发生任何变化，<strong>二者完全不相连</strong>，这就是深拷贝。</p>
<p>在了解深拷贝和浅拷贝之前我们需要先懂得一个概念，</p>
<p>什么是引用数据类型，（重音在“引用”上）</p>
<p>我们都知道<strong>基本数据类型</strong>包括：<span style="color:red">number、string、Boolean、null、Undefined、symbol、BigInt</span></p>
<p>还有一个引用数据类型：Object类（包括无序对象例如<code>{name:&quot;小明&quot;}</code>，数组例如:<code>[1,2,3]</code>以及函数等）</p>
<p><strong>基本数据类型的存储方式——名、值都储存在栈内存中</strong></p>
<p>相当于没有所谓的指向堆地址一说</p>
<p>例如let a = 1;</p>
<figure data-type="image" tabindex="11"><img src="https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124130901890-511917244.jpg" alt="img" loading="lazy"></figure>
<p>当你b=a复制时，栈内存会新开一个内存，例如这样：</p>
<figure data-type="image" tabindex="12"><img src="https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124131822437-430949998.jpg" alt="img" loading="lazy"></figure>
<p>a和b现在没有任何关联，所以修改a的时候，b完全不受影响。</p>
<p>但是这算不上是深拷贝，深拷贝只针对较为复杂的引用数据类型Object。</p>
<p><strong>引用数据类型的存储方式——名和值分开放，名存在栈内存中，值存在堆内存中，但是栈内存会放一个引用的地址指向相应的堆内存</strong></p>
<p>在这之前我们先看一个例子（浅拷贝）：</p>
<pre><code class="language-js">let a=[0,1,2,3,4],
    b=a;
console.log(a===b);
//现在对a[0]进行更改
a[0]=1;
console.log(a,b);
</code></pre>
<p>运行结果：</p>
<figure data-type="image" tabindex="13"><img src="https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124114023703-1953539844.png" alt="img" loading="lazy"></figure>
<p>我们看到b复制了a之后，把a进行修改，b却也跟着改变了，是因为b复制的只是a的引用地址，二者的值其实是同一个</p>
<figure data-type="image" tabindex="14"><img src="https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124133428359-1292133331.jpg" alt="img" loading="lazy"></figure>
<p>以上是a的存储方式</p>
<figure data-type="image" tabindex="15"><img src="https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124133647796-1390255671.jpg" alt="img" loading="lazy"></figure>
<p>当b=a进行拷贝的时候，其实复制的只是a的引用地址，并非堆内存里面的值</p>
<figure data-type="image" tabindex="16"><img src="https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124133934328-67216865.jpg" alt="img" loading="lazy"></figure>
<p>而当我们使<code>a[0]=1</code>进行修改时，由于a和b指向的是同一个地址，所以b自然也收了影响，这就是所谓的浅拷贝</p>
<figure data-type="image" tabindex="17"><img src="https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124140906203-2099568933.jpg" alt="img" loading="lazy"></figure>
<p>如果给b也开辟一个堆内存存放值的话，像基本类型那样，就达到深拷贝的效果了</p>
<p>那么如何实现深拷贝呢</p>
<p><strong>1.递归实现深拷贝</strong></p>
<pre><code class="language-js">        // 使用递归完成深拷贝
        var star = {
            name: &quot;蔡徐坤&quot;,
            gender: 1,
            hobby: [&quot;唱&quot;, &quot;跳&quot;, &quot;rap&quot;, &quot;篮球&quot;],
            friends: [&quot;lawyer&quot;, &quot;chicken&quot;],
            goods: { cloth: &quot;吊带&quot;, weapon: &quot;篮球&quot; }
        }
        var fakeStar = {
            money: 9999
        }

        // 使用递归实现深拷贝
        function deepCopy(obj1, obj2) {
            obj2 = obj2 || {}
            for (let i in obj1) {
                if (typeof obj1[i] != 'object') {
                    // 如果不是引用类型Object，直接复制就可
                    obj2[i] = obj1[i]
                } else {
                    if (obj1[i].constructor === Array) {
                        // 如果是数组
                        obj2[i] = []
                    } else {
                        //如果是对象
                        obj2[i] = {}
                    }
                    //进行递归操作
                    deepCopy(obj1[i], obj2[i])
                }
            }
            return obj2
        }

        fakeStar = deepCopy(star, fakeStar)
        console.log(star, &quot;star&quot;);
        console.log(fakeStar, &quot;fakeStar&quot;);
</code></pre>
<p><strong>2.借用JSON对象的parse和stringify</strong></p>
<pre><code class="language-js">function deepClone(obj){
    let _obj = JSON.stringify(obj),
        objClone = JSON.parse(_obj);
    return objClone
}    
let a=[0,1,[2,3],4],
    b=deepClone(a);
a[0]=1;
a[2][0]=1;
console.log(a,b);
</code></pre>
<figure data-type="image" tabindex="18"><img src="https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124154610578-1742013996.png" alt="img" loading="lazy"></figure>
<p><strong>3.除此之外，还有jquery提供的$.extend()方法</strong></p>
<p><strong>jQuery.extend(<em>[deep]</em>, target, object1, <em>[objectN]</em>)</strong></p>
<h1 id="es6-es2020">es6-es2020</h1>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f623a94c2f6f4cbeb46b1e8d66e75186~tplv-k3u1fbpfcp-watermark.image" alt="ES6缩略" style="zoom: 50%;" />
<h2 id="es2015">es2015</h2>
<h3 id="const-and-let">const and let</h3>
<p>const 声明之后必须马上赋值</p>
<p>let声明之后可以立马赋值也可以使用的时候再赋值</p>
<ul>
<li>不允许重复声明</li>
<li>未定义就会报错：不存在变量提升</li>
<li>暂时性死区：在let and const 声明变量之前 该变量不可以使用</li>
</ul>
<h3 id="解构赋值">解构赋值</h3>
<p>字符串，数值，boolean，对象，数组，函数参数均可以解构赋值。</p>
<ul>
<li>只要=两边模式相同，左边的变量就会被赋值</li>
<li>解构赋值，如果=右边的值不是数组或者对象，就会把右边转为<mark>对象</mark></li>
<li>需要遵循匹配模式</li>
<li>结构不成功时变量的值等undefined</li>
<li>undefined and null 无法转为对象，因此无法进行解构</li>
</ul>
<h3 id="字符串扩展">字符串扩展</h3>
<ul>
<li>可以通过for-of遍历字符串</li>
<li>字符串模板  <code>${ }</code></li>
<li>repeat(),字符串重复n次并且返回新的<code>字符串</code></li>
<li>matchAll():返回正则在String中的所有的匹配</li>
<li>includes</li>
<li>startWith()/endWith()</li>
</ul>
<h3 id="number扩展">Number扩展</h3>
<ul>
<li>新增了一系列方法</li>
</ul>
<h3 id="object扩展">Object扩展</h3>
<ul>
<li>简洁表示:直接写入变量和函数作为对象的属性和方法（{prop,method(){ }}）</li>
<li>Object.assgin()合并对象（浅拷贝）</li>
<li>Object.getPrototype()获取对象的原型对象</li>
<li>Object.setPrototype()修改对象的原型对象</li>
<li>__ proto __：返回或者设置对象的隐式原型</li>
</ul>
<p>属性遍历</p>
<ul>
<li>for-in：遍历对象自身可遍历可枚举属性</li>
<li>Object.keys() 返回自身可枚举属性组成的数组
<ul>
<li>规则
<ol>
<li>首先遍历所有的数值键，按照数值升序排列</li>
<li>遍历所有的字符串键，按照加入时间升序</li>
<li>遍历所有的Symbol，按照加入时间升序</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="array扩展">Array扩展</h3>
<ul>
<li>[...arr]   扩展运算符</li>
<li>Array.form()转为真正的数组
<ol>
<li>类数组：arguments，length，Nodelist</li>
<li>可遍历对象：String，set，map，Generator</li>
</ol>
</li>
<li><strong>find()</strong>：返回第一个符合条件的成员</li>
<li><strong>findIndex()</strong>：返回第一个符合条件的成员索引值</li>
<li><strong>fill()</strong>：根据指定值填充整个数组，返回原数组</li>
<li><strong>keys()</strong>：返回以索引值为遍历器的对象</li>
<li><strong>values()</strong>：返回以属性值为遍历器的对象</li>
<li>es6将数组空位转为undefined</li>
</ul>
<ol>
<li>Math.max.apply(null,[x,y]) =&gt; Math.max(...[x,y])</li>
<li>合并，clone，拼接，转化字符串为数组都可以用到 [ ... ]</li>
</ol>
<h3 id="函数扩展">函数扩展</h3>
<ul>
<li>参数默认值: function(x=1,y=1){}</li>
<li>reset/spread参数():返回函数的多余参数</li>
<li>严格模式：只要函数用了... 解构赋值 扩展运算符，就不能使用严格模式</li>
<li>箭头函数:()=&gt;{}
<ul>
<li>this指向固定化</li>
<li>无自己的this，内部的this就是外层代码块的this，this是定义所在对象的this，不是使用的对象</li>
<li>因为没有this，所以不能用作构造函数，不能使用new</li>
<li>不能使用yield，不能用作Generator函数</li>
<li>不可使用Arguments对象，此对象在函数体内不存在</li>
</ul>
</li>
<li>尾调用优化：</li>
</ul>
<h3 id="symbol">Symbol</h3>
<p>唯一值：const set = Symbol(Str)</p>
<h3 id="set">Set</h3>
<p>唯一and不重复的值</p>
<p>具有iterator的数据结构</p>
<ul>
<li><strong>add()</strong>：添加值，返回实例</li>
<li><strong>delete()</strong>：删除值，返回布尔</li>
<li><strong>has()</strong>：检查值，返回布尔</li>
<li><strong>clear()</strong>：清除所有成员</li>
<li><strong>keys()</strong>：返回以属性值为遍历器的对象</li>
<li><strong>values()</strong>：返回以属性值为遍历器的对象</li>
<li><strong>entries()</strong>：返回以属性值和属性值为遍历器的对象</li>
<li><strong>forEach()</strong>：使用回调函数遍历每个成员</li>
</ul>
<p><strong>使用</strong>：去重String，Array。取交集，并集</p>
<ol>
<li>没有键只有值</li>
<li>添加多个NaN时，只会存在一个NaN</li>
<li>添加相同的对象的时候会认为是不同的对象</li>
<li>遍历顺序：插入顺序</li>
</ol>
<p>WeakSet</p>
<p>成员值只能是对象。</p>
<ul>
<li>add</li>
<li>delete</li>
<li>has</li>
</ul>
<p>存储DOM节点：DOM节点被移除的时候自动从文档中移除不用担心内存泄漏</p>
<p>临时存放一组对象或者是与对象绑定的信息</p>
<p><strong>tips</strong>：weakSet不可遍历，成员都是弱引用，</p>
<h3 id="map">Map</h3>
<p>类似于对象的数据结构，成员是任何类型的值。</p>
<p>属性：constuctor，size</p>
<p>方法：</p>
<ul>
<li><strong>get()</strong>：返回键值对</li>
<li><strong>set()</strong>：添加键值对，返回实例</li>
<li><strong>delete()</strong>：删除键值对，返回布尔</li>
<li><strong>has()</strong>：检查键值对，返回布尔</li>
<li><strong>clear()</strong>：清除所有成员</li>
<li><strong>keys()</strong>：返回以键为遍历器的对象</li>
<li><strong>values()</strong>：返回以值为遍历器的对象</li>
<li><strong>entries()</strong>：返回以键和值为遍历器的对象</li>
<li><strong>forEach()</strong>：使用回调函数遍历每个成员</li>
</ul>
<p>遍历顺序：插入顺序</p>
<p>对一个键多次赋值以后，后面的值将会覆盖前面的值</p>
<p>对同一个对象的引用，被视为一个键</p>
<p>对同样值的两个实例，被视为两个键。</p>
<p>添加多个NaN是作为键时，只会存在一个</p>
<p>Object：字符串-值，Map：值-值</p>
<h3 id="proxy">Proxy</h3>
<p>修改某些操作的默认行为(target,handler)</p>
<h3 id="class">Class</h3>
<p>对一类有着共同特征事物的抽象</p>
<p>类本身指向构造函数，所有的方法定义在prototype上，相当于构造函数的另外一种写法</p>
<p><strong>方法和关键字</strong></p>
<p>constructor : 构造函数</p>
<p>extrends：继承父类</p>
<p>super新建父类的this</p>
<p>get：取值函数，拦截属性的取值行为</p>
<p>set：存值函数</p>
<h3 id="module">Module</h3>
<ul>
<li>
<p>命令</p>
<ul>
<li>
<p>export</p>
<p>：规定模块对外接口</p>
<ul>
<li><strong>默认导出</strong>：<code>export default Person</code>(导入时可指定模块任意名称，无需知晓内部真实名称)</li>
<li><strong>单独导出</strong>：<code>export const name = &quot;Bruce&quot;</code></li>
<li><strong>按需导出</strong>：<code>export { age, name, sex }</code>(推荐)</li>
<li><strong>改名导出</strong>：<code>export { name as newName }</code></li>
</ul>
</li>
<li>
<p>import</p>
<p>：导入模块内部功能</p>
<ul>
<li><strong>默认导入</strong>：<code>import Person from &quot;person&quot;</code></li>
<li><strong>整体导入</strong>：<code>import * as Person from &quot;person&quot;</code></li>
<li><strong>按需导入</strong>：<code>import { age, name, sex } from &quot;person&quot;</code></li>
<li><strong>改名导入</strong>：<code>import { name as newName } from &quot;person&quot;</code></li>
<li><strong>自执导入</strong>：<code>import &quot;person&quot;</code></li>
<li><strong>复合导入</strong>：<code>import Person, { name } from &quot;person&quot;</code></li>
</ul>
</li>
<li>
<p>复合模式</p>
<p>：</p>
<pre><code>export命令
</code></pre>
<p>和</p>
<pre><code>import命令
</code></pre>
<p>结合在一起写成一行，变量实质没有被导入当前模块，相当于对外转发接口，导致当前模块无法直接使用其导入变量</p>
<ul>
<li><strong>默认导入导出</strong>：<code>export { default } from &quot;person&quot;</code></li>
<li><strong>整体导入导出</strong>：<code>export * from &quot;person&quot;</code></li>
<li><strong>按需导入导出</strong>：<code>export { age, name, sex } from &quot;person&quot;</code></li>
<li><strong>改名导入导出</strong>：<code>export { name as newName } from &quot;person&quot;</code></li>
<li><strong>具名改默认导入导出</strong>：<code>export { name as default } from &quot;person&quot;</code></li>
<li><strong>默认改具名导入导出</strong>：<code>export { default as name } from &quot;person&quot;</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>继承：<code>默认导出</code>和<code>改名导出</code>结合使用可使模块具备继承性</p>
</li>
<li>
<p>设计思想：尽量地静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</p>
</li>
<li>
<p>严格模式：ES6模块自动采用严格模式(不管模块头部是否添加<code>use strict</code>)</p>
</li>
</ul>
<blockquote>
<p>模块方案</p>
</blockquote>
<ul>
<li><strong>CommonJS</strong>：用于服务器(动态化依赖)</li>
<li><strong>AMD</strong>：用于浏览器(动态化依赖)</li>
<li><strong>CMD</strong>：用于浏览器(动态化依赖)</li>
<li><strong>UMD</strong>：用于浏览器和服务器(动态化依赖)</li>
<li><strong>ESM</strong>：用于浏览器和服务器(静态化依赖)</li>
</ul>
<p>加载方式</p>
<ul>
<li>运行时加载:整体加载模块生成一个对象，再从对象上获取需要的属性and方法进行加载。
<ul>
<li>只有运行的时候才能得到这对象，无法在编译的时候做静态优化</li>
</ul>
</li>
<li>编译时加载：直接在模块中获取需要的属性和方法进行加载（<strong>按需加载</strong>）
<ul>
<li>在编译的时候就完成了加载哦，效率较高，但无法引用模块本身，可拓展JS高级语法</li>
</ul>
</li>
<li>传统加载:通过<script>加载
<ul>
<li>同步</li>
<li>异步
<ul>
<li>defer：顺序加载</li>
<li>async:乱序加载</li>
</ul>
</li>
</ul>
</li>
<li>模块加载：<script type="module">  默认是异步</li>
</ul>
<p>CommonJS and ESM区别：</p>
<ul>
<li>CommonJs输出值的拷贝，模ESM输出值的引用
<ul>
<li>CommonJS一旦输出一个值，模块内部的变化就影响不到这个值</li>
</ul>
</li>
<li>CommonJS是运行时加载，ESM是编译时加载
<ul>
<li>CommonJS只有在脚本运行完以后才会生成</li>
<li>ESM加载模块不是对象，它的对外接口只是一种静态定义</li>
</ul>
</li>
</ul>
<h3 id="iterator迭代器and-generato生成器">Iterator迭代器and Generato生成器</h3>
<p>Iterator：为不同的数据结构提供统一的访问机制</p>
<p>创建一个指针指向首个成员，按照next()访问下一个成员变量，直到结束位置。</p>
<p>数据结构</p>
<ul>
<li>​	集合：Array，Object，set ，Map</li>
<li>原生具备接口的数据结构：String，Array，Set，Map，TypeArray，arguments</li>
</ul>
<p>Generator：封装多个内部状态的异步编程解决方案。</p>
<pre><code>function* Func(){}
</code></pre>
<p>调用<code>Generator函数</code>(该函数不执行)返回指向内部状态的指针对象(不是运行结果)</p>
<h3 id="promise">Promise</h3>
<p>包含异步操作的结果对象</p>
<p>resolved  pending rejected</p>
<p>特点：对象的状态一经改变就不会再变，状态不受外界影响。</p>
<p>then方法：分别指定resolved和rejected状态的回调函数  then(resolved,rejected)</p>
<p>Promise.all():将多个实例包装成一个新的实例，返回全部实例状态变更后的结果数组。</p>
<ul>
<li>入参：具有迭代器的数据结构</li>
<li>成功：全部成功才会fulfilled</li>
<li>失败：只要有一个失败就是rejected</li>
</ul>
<ol>
<li>只有异步操作可以决定当前状态是哪一个，其他操作无法改变</li>
<li>状态改变只有两种情况pending---&gt;resolved  pending---&gt;rejected</li>
<li>一旦新建Promise对象就会立即执行，无法中途取消</li>
<li>不设置回调函数，内部抛错不会到外部</li>
<li>pending状态的时候无法知道是那个阶段</li>
<li>resolved rejected回触发then回调函数</li>
<li>reject（）等于抛错错误</li>
<li>实例状态的错误会冒泡，一直向后传递直到被捕获为止。</li>
</ol>
<h2 id="es2016">es2016</h2>
<p>数值扩展</p>
<ul>
<li>指数运算符 （**）：相当于指数求幂 Math.pow()</li>
</ul>
<p>数组扩展</p>
<ul>
<li>includes()</li>
</ul>
<h2 id="es2017">es2017</h2>
<p>String扩展</p>
<ul>
<li>padStart() :把指定的字符串填充到字符串头部，返回新字符串</li>
<li>padEnd() :把指定的字符串填充到字符串尾部部，返回新字符串</li>
</ul>
<p>Object扩展</p>
<ul>
<li>Object.values() :返回以值组成的数组</li>
<li>Object.entries():返回以键值组成的数组</li>
<li>Object.getOwnPropertyDescriptors() :返回对象所有的自身属性的描述对象</li>
</ul>
<p>函数：允许函数的最后一个参数有 逗号，</p>
<p>**Async:**使异步函数以同步函数的形式书写</p>
<p>原理：将Generator函数和自动执行器spawn包装在一个函数里</p>
<p>await：等待当前Promise对象状态变更完毕</p>
<ul>
<li>正常：后面是P&quot;romise对象则返回结果，否则返回对应的值</li>
<li>后随Thenable对象，将其等于Promise对象返回其结果</li>
</ul>
<p>应用场景：按顺序执行异步操作。</p>
<p>tips：</p>
<ol>
<li>Async函数返回Promise对象，可以使用then()添加回调函数</li>
<li>nebulareturn值会被后续的then出参</li>
<li>内部抛出错误会导致返回的Promise对象编程rejected，被catch</li>
<li>返回的Promise对象必须等到内部await所有的promise对象执行完毕，或者报错</li>
<li>只要有一个rejected，全部报错</li>
<li>await只能放在async中</li>
<li>数组使用forEach()执行async/await会失效，可以使用for-of或者promise.all(代替)</li>
</ol>
<h2 id="es2018">es2018</h2>
<p>String</p>
<p>放松对标签模板中字符串转义的限制</p>
<p>Object</p>
<p>扩展运算符 ...</p>
<p>转换对象为用逗号分割的参数序列{...obj}</p>
<ul>
<li>clone</li>
<li>合并对象 {...obj1,...obj2 }</li>
<li>转换字符串为对象 {...&quot;hello&quot;}</li>
<li>转换数组为对象{...[1,2]}</li>
<li>修改现有对象部分属性：<code>const obj = { x: 1, ...{ x: 2 } }</code></li>
</ul>
<h3 id="正则reg">正则reg</h3>
<p><strong>s修饰符</strong>：dotAll模式修饰符，使<code>.</code>匹配任意单个字符(<code>dotAll模式</code>)</p>
<p><strong>dotAll</strong>：是否设置<code>s修饰符</code></p>
<p><strong>后行断言</strong>：<code>x</code>只有在<code>y</code>后才匹配</p>
<p><strong>后行否定断言</strong>：<code>x</code>只有不在<code>y</code>后才匹配</p>
<p><strong>Unicode属性转义</strong>：匹配符合<code>Unicode某种属性</code>的所有字符</p>
<ul>
<li>正向匹配：<code>\p{PropRule}</code></li>
<li>反向匹配：<code>\P{PropRule}</code></li>
<li>限制：<code>\p{...}</code>和<code>\P{...}</code>只对<code>Unicode字符</code>有效，使用时需加上<code>u修饰符</code></li>
</ul>
<p><strong>具名组匹配</strong>：为每组匹配指定名字(<code>?&lt;GroupName&gt;</code>)</p>
<p><strong>Promise</strong></p>
<ul>
<li>finally()：指定不管最后状态如何都会指定的回调函数</li>
</ul>
<p><strong>Async</strong></p>
<p>异步迭代器（for-await-of）：循环等待每个Promise对象编程resolved才进入下一步</p>
<h2 id="es2019">es2019</h2>
<p><strong>String</strong></p>
<ul>
<li>JSON.Stringify()可以返回不符合utf-8标准的字符串</li>
<li>trimStart():消除String头部空格，返回新串</li>
<li>trimEnd():消除String尾部空格，返回新串</li>
</ul>
<p><strong>Object</strong></p>
<p>object.fromEntries()返回以键和值组成的对象</p>
<p><strong>Array</strong></p>
<ul>
<li>flat：扁平化数组</li>
<li>flatMap():映射且扁平化数组，返回新的数组</li>
</ul>
<p><strong>Fucntion</strong></p>
<p>toString：返回函数的原始代码</p>
<p>catch（：参数可省略</p>
<p><strong>Symbol</strong></p>
<p>description:返回Symbol的描述</p>
<h2 id="es2020">es2020</h2>
<p><strong>声明</strong></p>
<ul>
<li>globalThis：顶层this，指向全局环境下的this</li>
<li>Node：顶层对象global</li>
<li>webworker：顶层对象是self。</li>
</ul>
<p><strong>BigInt</strong>：任何位数的整数，1n</p>
<ul>
<li>BigInt()：转换普通数组为BigInt类型</li>
<li>BigInt.asIntN():转换BigInt为-2n-1 到2n-1-1</li>
<li>BigInt.parseInt():将一个字符串转换为指定进制的BigInt类型</li>
</ul>
<p>Tips：BigInt可以使用各种进制表示，加上后缀</p>
<p>BigInt与普通整数之间是两种值，并不相等</p>
<p>typeOf bigInt = bigint</p>
<p><strong>Object</strong></p>
<p>链判断操作符：是否存在对象属性      ?.</p>
<p>对象属性 ：obj?. prop</p>
<p>函数调用：func？.(...args)</p>
<p>空判断操作符(??):是否值为undefined or null 是则使用默认值</p>
<p><strong>正则****reg</strong></p>
<p>mathAll().返回所有匹配的遍历器</p>
<p><strong>Module</strong></p>
<p>import()动态导入（返回Promise）</p>
<p><mark>require同步加载</mark></p>
<p><mark>import异步加载</mark></p>
<p><strong>Iterator</strong></p>
<p>for-in遍历顺序</p>
<h3 id="promise-2">Promise</h3>
<ul>
<li><strong>Promise.allSettled()</strong>：将多个实例包装成一个新实例，返回全部实例状态变更后的状态数组(齐变更再返回)</li>
</ul>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://Leonhaiwang.github.io/tag/TFbKUxkyH/" class="tag">
                    前端
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://Leonhaiwang.github.io/post/vue/">
                  <h3 class="post-title">
                    vue
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
