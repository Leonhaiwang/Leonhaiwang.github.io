<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Leonhaiwang.github.io</id>
    <title>Leon</title>
    <updated>2021-04-22T12:42:43.499Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Leonhaiwang.github.io"/>
    <link rel="self" href="https://Leonhaiwang.github.io/atom.xml"/>
    <subtitle>It is always day one !</subtitle>
    <logo>https://Leonhaiwang.github.io/images/avatar.png</logo>
    <icon>https://Leonhaiwang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Leon</rights>
    <entry>
        <title type="html"><![CDATA[Git基础知识以及常用命令]]></title>
        <id>https://Leonhaiwang.github.io/post/git-ji-chu-zhi-shi-yi-ji-chang-yong-ming-ling/</id>
        <link href="https://Leonhaiwang.github.io/post/git-ji-chu-zhi-shi-yi-ji-chang-yong-ming-ling/">
        </link>
        <updated>2021-04-22T12:38:56.000Z</updated>
        <content type="html"><![CDATA[<p>版本控制工具：在开发过程中用于管理我们对于文件目录等的修改历史，方便查看历史记录，以便方便查看。</p>
<h1 id="git与svn最主要区别">Git与SVN最主要区别</h1>
<p>SVN是集中式版本控制工具，版本库是集中放在中央服务器的。工作的时候首先要从中央服务器下载。</p>
<p>Git是分布式版本控制管理系统，没有中央服务器，每个人的电脑就是一台完整的版本库，只需要提交自己修改的了部分。</p>
<h1 id="优点">优点</h1>
<ul>
<li>适合分布式开发，强调个体。</li>
<li>公共服务器压力和数据量都不会太大。</li>
<li>速度快、灵活。</li>
<li>任意两个开发者之间可以很容易的解决冲突。</li>
<li>离线工作。</li>
</ul>
<h1 id="git理论基础">Git理论基础</h1>
<h2 id="工作区域">工作区域</h2>
<ul>
<li>工作目录-Working Directory</li>
<li>暂存区 -Stage</li>
<li>资源库-Repository</li>
<li>远程Git库-Remote Directory</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://Leonhaiwang.github.io/post-images/1619095300600.png" alt="" loading="lazy"></figure>
<h2 id="工作流程">工作流程</h2>
<p>１、在工作目录中添加、修改文件；</p>
<p>２、将需要进行版本管理的文件放入暂存区域；</p>
<p>３、将暂存区域的文件提交到git仓库。</p>
<h1 id="git操作">Git操作</h1>
<p>要管理项目的根目录执行</p>
<h2 id="创建工作目录与常见指令">创建工作目录与常见指令</h2>
<figure data-type="image" tabindex="2"><img src="https://Leonhaiwang.github.io/post-images/1619095318668.png" alt="" loading="lazy"></figure>
<h2 id="获得git仓库">获得Git仓库</h2>
<h2 id="创建全新仓库">创建全新仓库</h2>
<pre><code class="language-js">git init //在当前目录下新建一个Git代码库
</code></pre>
<h2 id="克隆远程仓库">克隆远程仓库</h2>
<pre><code># 克隆一个项目和它的整个代码历史(版本信息)
$ git clone [url]
</code></pre>
<h2 id="git文件操作">GIT文件操作</h2>
<p>Git提交的时候主要关心文件的两个版本之间是否有改变，判断文件整体是否改变的方法就是SHA-1算法计算文件的校验和。</p>
<h4 id="文件的四种状态">文件的四种状态</h4>
<ul>
<li>Untracked：在文件夹中但是未加到Git库中，不参与版本控制--- git add .</li>
<li>Unmodify：文件已经入库但是未修改，</li>
<li>Modified：已修改没有进行其他的操作，git add 进入暂存Staged,git checkout 丢弃修改过</li>
<li>Staged：暂存，执行git commit将修改同步到库中。</li>
</ul>
<h4 id="查看文件状态">查看文件状态</h4>
<pre><code>git status
</code></pre>
<h4 id="添加文件与目录">添加文件与目录</h4>
<p>添加文件到暂存区</p>
<pre><code>git add . //全部 [filename]
</code></pre>
<p>移除文件与目录</p>
<pre><code>git rm --cached &lt;file&gt;
</code></pre>
<h4 id="查看文件修改后的差异">查看文件修改后的差异</h4>
<pre><code>git diff [files]
</code></pre>
<pre><code>#比较暂存区的文件与之前已经提交过的文件
git diff --cached
</code></pre>
<h4 id="忽略文件">忽略文件</h4>
<p>.gitignore</p>
<p>一组规则</p>
<h4 id="提交commit">提交commit</h4>
<p>将暂存区中的文件提交到本地仓库</p>
<pre><code>$ git commit -m [message]

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区，跳过了add,对新文件无效
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...
</code></pre>
<h4 id="查看提交日志">查看提交日志</h4>
<p>git log</p>
<h4 id="查看所有分支日志"><strong>查看所有分支日志</strong></h4>
<p>&quot;git reflog&quot;中会记录这个仓库中所有的分支的所有更新记录，包括已经撤销的更新。</p>
<h4 id="查看文件列表">查看文件列表</h4>
<p>git ls-files</p>
<h4 id="撤销本地仓库更新">撤销本地仓库更新</h4>
<p>git reset --hard</p>
<h2 id="回滚操作">回滚操作</h2>
<pre><code>git resert 
</code></pre>
<h2 id="git分支">Git分支</h2>
<pre><code># 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 切换到上一个分支
$ git checkout -

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[webpack基础知识]]></title>
        <id>https://Leonhaiwang.github.io/post/webpack-ji-chu-zhi-shi/</id>
        <link href="https://Leonhaiwang.github.io/post/webpack-ji-chu-zhi-shi/">
        </link>
        <updated>2021-04-21T07:44:36.000Z</updated>
        <content type="html"><![CDATA[<p>js<strong>静态打包工具</strong>(根据依赖图映射项目所需要的所有的模块，生成一个或者多个bundle.js)</p>
<h2 id="概念">概念</h2>
<ul>
<li>模块打包
<ul>
<li>执行模块打包，将不同的文件整合打包在一起，保证引用正确。我们就可以在项目中自由的划分文件模块</li>
</ul>
</li>
<li>编译兼容
<ul>
<li>帮助代码做polyfill，编译转换无法识别的文件。我们可以 用新的语法特性来开发。</li>
</ul>
</li>
<li>能力扩展
<ul>
<li>在打包的基础上帮助我们实现：按需加载，代码压缩等。提高自动化程度，工程效率，打包输出质量。</li>
</ul>
</li>
</ul>
<p>打包：将模块化的依赖性文件，生成浏览器可以识别的文件</p>
<p>entry （入口）：通过入口文件去找到需要相互依赖的文件。默认值是 <code>./src/index.js</code></p>
<p>output（输出）：在哪里创建输出文件以及所创建的bundle.js，以及如何命名</p>
<p>loader（插件）：（加载其他扩展语言的功能）：解析文件，使得webpack可以处理其他的文件转为有效模块，tips：sass。</p>
<p>​							必须包含两个属性 test：需要解析的文件格式 ，use：使用的转换方式</p>
<p>插件（plugin）：具有某种特定功能的操作-打包优化，资源管理，注入环境</p>
<p>模式 mode：开发环境or生产环境。 production，development。</p>
<h2 id="entry">entry</h2>
<pre><code class="language-js">module.export = {
	entry:&quot;./src/index.js&quot;
}
</code></pre>
<p>在创建多页面应用程序，需要多个独立分离的视图</p>
<pre><code>module.export = {
  entry:{
    pageone:&quot;./src/index.js&quot;,
    pagetwo:&quot;./src/ssc.js&quot;
  }
}
</code></pre>
<p>在多页面应用程序中，服务器会传输一个新的html文档给你的客户端，页面重新加载此文档，资源被重新下载，在这个期间有很多机会去做别的事情。</p>
<h2 id="output">output</h2>
<p>可以有多个entry起点，但是只能有一个输出位置、。</p>
<pre><code>module.exports = {
  output: {
    filename: 'bundle.js',
  }
};
</code></pre>
<h2 id="mode">mode</h2>
<p>development  ||  production || none</p>
<pre><code>mode: 'production'
</code></pre>
<h2 id="loader">loader</h2>
<p>对模块的源代码进行切换。主要是将不同的语言转换为js。</p>
<p>在转换以前需要首先安装相应的loader</p>
<pre><code class="language-node">npm install --save-dev css-loader
</code></pre>
<p>配置</p>
<pre><code class="language-js"> module: {
    //对某种格式的文件进行转换处理
    rules: [
      {
        test: /\.css$/,   //正则匹配css文件
        use: [
          //解析的顺序是从下到上的 --逆序执行
          //将js样式内容插入style标签中
          &quot;style-loader&quot;,
          //首先将css文件变为js
          &quot;css-loader&quot;
        ]
      },
      {
        //匹配图片文件
        test: /\.(jpg|png|gif)$/,
        loader: 'url-loader',
        //限制内容 
        //图片小于8kb，base64
        options: {
          limit: 8 * 1024,
          // 关闭url模块化解析
          esModules: false,
          //取图片hash的前十位 + 扩展名
          name: &quot;[hash:10].[ext]&quot;
        }
      }, {
        test:/\.html$/,
        loader:&quot;html-loader&quot;
      }
    ]
  },
</code></pre>
<h2 id="plugin">plugin</h2>
<p>插件---解决loader无法解决的事情。</p>
<p>由于插件可以传递参数，在webpack.config.js中，向plugin属性传入new实例。</p>
<pre><code class="language-js">let HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)

plugins: [
    new HtmlWebpackPlugin({
      template = '../demo04/src/index.html'
    })
  ],
</code></pre>
<h2 id="配置configuration">配置（configuration）</h2>
<p>webpack.config.js 是一个导出webpack配置对象的js文件。会根据配置对象上定义的属性进行处理。</p>
<p>可通过Node.js Common.JS 引入</p>
<ul>
<li>通过require() 引入文件</li>
<li>通过require() 使用npm工具函数</li>
<li>使用js控制流表达式</li>
<li>对常用值使用变量and常量</li>
</ul>
<h2 id="模块module">模块（module）</h2>
<p>模块化编程中，开发者将程序分解为功能离散的模块。</p>
<p>每个模块有比程序更小的接触面，使得验证，测试等方便。模块可以提供可靠的抽象和封装界限，使得程序中的模块条理清楚</p>
<h2 id="为什么是webpack">为什么是webpack？</h2>
<p>在webpack以前，我们使用脚本来存放每个功能，或者使用一个大型的js文件包含所有的。这种方式相对来说都有缺陷。</p>
<p>Node是一个在js运行的时候，可以在浏览器环境之外的计算机和服务器中使用的，webpack就运行在node.js中。</p>
<p>不仅可以编写模块，还支持任何模块格式，并同时处理资源。</p>
<h2 id="模块解析-module-resolution">模块解析 （module resolution）</h2>
<p>resolver是一个库，帮助找到模块的绝对路径，一个模块可以作为另一个模块的依赖模块，然后被引用。</p>
<p>可以通过 <code>import</code> <code>require</code>关键字来找到依赖。</p>
<p>模块可以解析 <code>模块路径</code> <code>绝对路径</code> <code>相对路径</code></p>
<p><strong>缓存</strong>：每次文件系统访问都会被缓存，以便更快的触发对同一个文件的多个请求。在观察者模式下，只有修改过的文件会从缓存中拆除。</p>
<h2 id="依赖图">依赖图</h2>
<p>一个文件依赖于另外一个文件，webpack中这就是依赖关系，so webpack 可以接受非代码资源，并且作为依赖提供给应用程序。</p>
<p>从entry开始，webpack递归构建一个依赖图，这个依赖图包含着应用陈旭的每个模块，打包为一个bundle.js供浏览器加载。</p>
<h2 id="manifest">manifest</h2>
<p>runtime：在浏览器运行的过程中，webpack用来连接模块化应用程序所需的所有的代码。包含：模块交互的时候，连接模块所需的加载和解析的逻辑。包括已经加载到浏览器中的连接模块逻辑。</p>
<p><strong>manfifest</strong>：webpack如何管理所需的模块之间的交互。</p>
<p><strong>当compiler开始执行，解析时候，会保留所有模块的详细要点，这个数据集合被称为manifest，当完成打包并发送到浏览器的时候，runtime会通过manifest来解析加载模块</strong>。------无论使用的是import or require，都已经转为 <code>__webpack__reqiure__</code>, 指向模块标识符。</p>
<p>tips：对于通过缓存提升浏览器性能有着很大的帮助。</p>
<h2 id="部署目标target">部署目标：target</h2>
<pre><code>module.export = {
	target:'node'
}
</code></pre>
<p>可以通过下面这种方法导出多个同构的libray</p>
<pre><code class="language-js">const path = require('path');
const serverConfig = {
  target: 'node',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'lib.node.js'
  }
  //…
};

const clientConfig = {
  target: 'web', // &lt;=== 默认是 'web'，可省略
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'lib.js'
  }
  //…
};

module.exports = [ serverConfig, clientConfig ];
</code></pre>
<h2 id="热更新">热更新</h2>
<ul>
<li>保留在完全重新加载页面期间丢失的应用程序状态</li>
<li>只更新变更内容</li>
<li>在源代码中对css/js进行修改，会立刻在浏览器中进行更新</li>
</ul>
<h3 id="如何运行的这是">如何运行的这是</h3>
<h4 id="应用程序中">应用程序中</h4>
<ol>
<li>应用程序要求HMR runtime检查 更新。</li>
<li>HMR runtime 异步的下载更新，然后通知应用程序。</li>
<li>应用程序要求HMR runtime 应用更新</li>
<li>HMR runtime 同步的应用更新。</li>
</ol>
<h4 id="在compiler中">在Compiler中</h4>
<p>除了普通资源，compiler需要发出update，将之前的版本更新到新的版本</p>
<p>update：</p>
<ul>
<li>更新后的manifest（json）</li>
<li>一个或者多个updated chunk</li>
</ul>
<h4 id="在模块中">在模块中</h4>
<p>HMR可选功能，只会影响包含HMR代码的模块，通过style-loader追加补丁，在更新的时候，通过新的样式替换旧的样式</p>
<p>在模块中实现了HMR功能，可以在当模块中写入HMR代码，在更新的时候，记录更新，完成更新。</p>
<p>如果在一个模块中没有HMR，更新就会冒泡，意味着包含这个模块的所有的东西都会被更新。</p>
<h4 id="在项目中">在项目中</h4>
<p>在开发环境中，可以将HMR作为LiveReload的替代，在重新加载整个页面之前，hot模式会尝试使用HMR来更新。</p>
<h2 id="webpackconfigjs"><strong>webpack.config.js</strong></h2>
<pre><code class="language-js">let path = require(&quot;path&quot;) 
console.log(path.resolve(__dirname,&quot;dist&quot;));
module.export =  {
  //入口文件
  entry:&quot;./src/index.js&quot;,
  output:{
    //输出文件名称：
    filename:&quot;bundle.js&quot;,
    //输出路径
    //绝对路径
    path:path.resolve(__dirname,&quot;dist&quot;)
  },
  mode:&quot;development&quot;
}
</code></pre>
<h3 id="loader-2">loader</h3>
<p>进行源代码的转换--- ts ---&gt;js</p>
<ul>
<li>将css文件导入js文件中</li>
<li>配置webpack中的modules（对某种格式的文件进行转换处理）</li>
<li>webpack</li>
</ul>
<pre><code class="language-js">let path = require(&quot;path&quot;) 
console.log(path.resolve(__dirname,&quot;dist&quot;));
module.export =  {
  //入口文件
  entry:&quot;./src/index.js&quot;,
  output:{
    //输出文件名称：
    filename:&quot;bundle.js&quot;,
    //输出路径
    //绝对路径
    path:path.resolve(__dirname,&quot;dist&quot;)
  },
  mode:&quot;development&quot;,
  //loader的配置
  module:{
    //对某种格式的文件进行转换处理
    rules:[
      {
        test:/\.css$/,   //正则匹配css文件
        use:[
          //解析的顺序是从下到上的 --逆序执行
          //将js样式内容插入style标签中
          &quot;style-loader&quot;,
          //首先将css文件变为js
          &quot;css-loader&quot;
        ]
      },
      {
        
      }
    ]
  }
}
</code></pre>
<h3 id="plugin整合html">plugin整合html</h3>
<ul>
<li>安装 html-webpack-plugin 插件</li>
<li>在plugin中注册插件</li>
</ul>
<pre><code class="language-js"> plugins: [
    new HtmlWebpackPlugin({
      template = '../demo04/src/index.html'
    })
  ]
</code></pre>
<h3 id="图片资源打包">图片资源打包</h3>
<pre><code class="language-js">module: {
    //对某种格式的文件进行转换处理
    rules: [
      {
        test: /\.css$/,   //正则匹配css文件
        use: [
          //解析的顺序是从下到上的 --逆序执行
          //将js样式内容插入style标签中
          &quot;style-loader&quot;,
          //首先将css文件变为js
          &quot;css-loader&quot;
        ]
      },
      {
        //匹配图片文件
        test: /\.(jpg|png|gif)$/,
        loader: 'url-loader',
        //限制内容 
        //图片小于8kb，base64
        options: {
          limit: 8 * 1024,
          // 关闭url模块化解析
          esModules: false,
          //取图片hash的前十位 + 扩展名
          name: &quot;[hash:10].[ext]&quot;
        }
      }, {
        test:/\.html$/,
        loader:&quot;html-loader&quot;
      }
    ]
  },
</code></pre>
<pre><code class="language-js">let path = require(&quot;path&quot;)
// console.log(path.resolve(__dirname,&quot;dist&quot;));
let HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)
module.export = {
  //入口文件
  entry:{
    pageone:&quot;./src/index.js&quot;,
    pagetwo:&quot;./src/ssc.js&quot;
  },
  output: {
    //输出文件名称：
    filename: &quot;bundle.js&quot;,
    //输出路径
    //绝对路径
    path: path.resolve(__dirname, &quot;dist&quot;)
  },
  mode: &quot;production&quot;, // 设置mode
  //loader的配置
  module: {
    //对某种格式的文件进行转换处理
    rules: [
      {
        test: /\.css$/,   //正则匹配css文件
        use: [
          //解析的顺序是从下到上的 --逆序执行
          //将js样式内容插入style标签中
          &quot;style-loader&quot;,
          //首先将css文件变为js
          &quot;css-loader&quot;
        ]
      },
      {
        //匹配图片文件
        test: /\.(jpg|png|gif)$/,
        loader: 'url-loader',
        //限制内容 
        //图片小于8kb，base64
        options: {
          limit: 8 * 1024,
          // 关闭url模块化解析
          esModules: false,
          //取图片hash的前十位 + 扩展名
          name: &quot;[hash:10].[ext]&quot;
        }
      }, {
        test:/\.html$/,
        loader:&quot;html-loader&quot;
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template = '../demo04/src/index.html'
    })
  ],
  devServer:{
    //项目构建路径
    contentBase:path.resolve(__dirname,&quot;dist&quot;),
    //启动gzip编码的压缩
    compress:true,
    port:3000,
    open:true
  }
}
</code></pre>
<h1 id="模块打包运行原理">模块打包运行原理</h1>
<p>打包过程</p>
<ol>
<li>读取webpack配置参数</li>
<li>创建compiler对象并且开始解析项目</li>
<li>从入口entry开始解析，遍历递归解析树，<strong>形成依赖关系树</strong></li>
<li>对不同类型的依赖文件使用对应的loader进行编译，最终都转为JavaScript</li>
<li>整个过程中webpack会通过发布订阅模式，向外抛出hooks，webpack监听关键的事件节点，干预结果输出。</li>
</ol>
<p>对于文件的解析与构建，webpack主要通过compiler与compiltion实现。</p>
<p>compiler是一个全局单例：把控整个webpack打包构建流程。</p>
<p>compilation对象是每一次构建的上下文对象，包含了当前构建所需要的所有的信息，	每次热更新和重新构建，compiler都会生成一个compilation负责。</p>
<p>每个模块间的依赖关系，依赖于AST语法树，每个模块文件在loader文件解析完成后，会生成acron模块代码的AST语法树，通过语法树分析是否有依赖的模块。</p>
<p>最终webpack打包的是一个<strong>IIFE</strong>（立即执行函数）</p>
<h1 id="sourcemap">SourceMap</h1>
<p>将编译打包压缩后的代码，映射回源代码。</p>
<p>由于打包压缩后的代码没有阅读性可言，一旦在开发中报错，不好。sourceMap帮助我们快速的定位到源代码的位置。</p>
<p>通常有一份对应的映射文件来解决标记混淆代码对应源码的位置======&gt;.map文件</p>
<p>有了代码压缩文件以后，只要在代码的最后加上，即可sourceMap生效。</p>
<pre><code>//# sourceURL=/path/to/file.js.map
</code></pre>
<p>webpack打包的bundle文件，在每个文件的代码末端，都会加上上方的注释。需要浏览器的支持。</p>
<h1 id="loader思路">loader思路</h1>
<p>loader存在的意义：在webpack中，打包出来的都是js代码，对于sass等文件，先进行转换，才能继续执行打包文件。</p>
<p>针对每个文件类型，loader是支持以数组的形式配置多个。webpack在转换文件类型的时候，会按顺序链式调用每一个loader，前一个loader会作为后一个loader的入参。因此返回值必须是js字符串，单一职责，只关心loader的输入和输出。</p>
<p>loader函数中的this由webpack提供，可以通过this对象，提供的相关属性，获取当前loader需要的各种信息。</p>
<h1 id="plugin-2">plugin</h1>
<p>loader文件转换，plugin功能扩展。</p>
<p>webpack基于发布订阅者模式，在运行的生命周期中广播出许多的事件，插件通过监听这些事件，在特定的时间段执行特定的插件任务，从而实现想要的功能。</p>
<p>loader中compiler提供了整个生命周期相关的钩子，compilation提供了模块和依赖相关的钩子。</p>
<p>webpack的事件机制基于webpack自己实现的一套tapable事件流方案。</p>
<h2 id="遵循的规范和原则">遵循的规范和原则</h2>
<ul>
<li>插件必须是一个函数或者一个而包含apply方法的对象，才能访问到compiler实例</li>
<li>传给每个插件的compiler和compilation是一个引用，如果在一个地方修改了，会影响后面的插件。</li>
<li>异步的事件处理函数需要在事件处理结束以后调用回调函数，通知webpack进入下一个流程。</li>
</ul>
<pre><code class="language-js">class Myplugin{
	apply(compiler){
	//找到合适事件的钩子，实现自己的插件功能
		compiler.hooks.emit.tap('MyPlugin',compilation=&gt;{
			//当前打包构建流程的上下文
			//doSomething
		})
	}
}
</code></pre>
<p>https://juejin.cn/post/6844904094281236487#heading-0</p>
<h1 id="经典面试">经典面试</h1>
<h2 id="常见loader">常见loader</h2>
<ul>
<li>row-loader：加载文件原始内容</li>
<li>file-loader：把文件输出到一个文件夹中，通过url去引用输出的文件</li>
<li>source-map-loader：加载额外的source-map-loader,方便调试</li>
<li>image-loader：加载并且压缩图片文件</li>
<li>sass-loder：sass---&gt;css</li>
<li>css-loader：加载css支持模块压缩文件导入等特性</li>
<li>babel-loader：es5-----&gt;es6</li>
</ul>
<h2 id="常见plugin">常见plugin</h2>
<ul>
<li>ignore-plugin：忽略部分文件</li>
<li>html-webpack-plugin：简化html文件</li>
<li>web-webpack-plugin：方便的为单页面应用输出html</li>
<li>clean-webpack-plugin：目录清理</li>
<li>mini-css-extract-plugin：分离样式文件</li>
<li>serviceworker-webpack-plugin：为应用增加离线缓存功能。</li>
</ul>
<h2 id="loader-plugin区别">loader plugin区别</h2>
<p>loader：对接受到的内容进行一个转换，由于webpack只认识js。</p>
<p>plugin：插件。扩展webpack的功能。在webpack运行的过程中会抛出许多的hooks，plugin监听这些hooks在合适的时机通过webpack的api改变输出结果。</p>
<p>loader在modules.rules中单独配置，数组。每一项都是一个Object{test，loader，options}</p>
<p>plugin在plugins中单独配置，数组。每一项是一个plugin实例。</p>
<h2 id="webpack可以提高效率的插件">webpack可以提高效率的插件</h2>
<p>webpack-merge：提取公共的配置，减少重复配置的代码</p>
<p>webpack-dashboard：友好展示相关的打包信息。</p>
<h2 id="webpack模块打包原理">webpack模块打包原理</h2>
<p>webpack为每一个文件设置一个导入导出的环境，本质上并没有修改代码执行逻辑，代码执行顺序也是一样的。</p>
<h2 id="文件监听原理">文件监听原理</h2>
<p>开始监听</p>
<ul>
<li>启动webpack的时候命令带上--watch参数</li>
<li>配置webpack.config.js的时候设置watch：ture</li>
</ul>
<p>发生代码变化的时候自动重新构建新的输出文件</p>
<p>原理：轮询判断文件的最后编辑时间是否发生变化，如果某个文件发生了变化，并不会立即告诉监听者，而是会先换存起来，aggreateTimout再执行。</p>
<pre><code class="language-js">module.export = {
watch:true,
//只有开启了监听模式的时候，watchOptions才有意义
watchOptions:{
	ignored:/node_modules/,
	aggregateTomeout:300,//监听到变化后300ms再去执行
	poll:1000//判断文件是否发生变化是通过不停的轮询系统指定的文件有没有变化实现的。
}
}
</code></pre>
<h2 id="webpack热更新原理">webpack热更新原理</h2>
<p>hot module replacement 热更新 HMR   <strong>不用更新浏览器将新变更的模块替换掉旧的模块</strong></p>
<p>HMR核心就是客户端从服务端拉去更新后的文件，准确的说：chunk diff（需要更新的部分）</p>
<p>在浏览器和WDS之间构建了一个websocket，在本地资源源码发生变化的时候，wds向浏览器推送更新（并且带上构建的hash），让客户端与上一次的资源进行对比。客户端对比出差异以后向wds发送ajax获取更改的内容（文件列表，hash）。这样客户端就可以借助这些信息向wds发起JSONP请求。</p>
<p>webpack通过node端的接口watch文件变化，重建模块并且通知浏览器变化的文件名，浏览器重新请求获取文件并替换该文件对应的模块。</p>
<h2 id="文件指纹">文件指纹</h2>
<p>打包输出文件名的后缀</p>
<p>hash：和整个项目的构建相关，只要项目的文件上有所修改，整个项目构建的hash值就会修改。</p>
<p>chunkhash：和webpack打包的chunk相关，不同的entry会有不同的chunkhash</p>
<p>contenthash：根据文件内容来定义hash，文件内容变化，则contenthash变化。</p>
<h3 id="js文件指纹">js文件指纹</h3>
<p>设置output的filename：用chunkhash。</p>
<pre><code>filename:'[name][chunkhash:8].js'
</code></pre>
<h3 id="css文件指纹">css文件指纹</h3>
<pre><code>module.export = {
	plugins:[
	new MiniCssExtractPlugin({
		filename:`[name][contenthash:8].css`
	})
	]
}
</code></pre>
<h2 id="如何优化webpack的构建速度">如何优化webpack的构建速度</h2>
<ul>
<li>使用高版本的webpack，node</li>
<li>压缩代码
<ul>
<li>多进程并行压缩
<ul>
<li>webpack-paralle-uglify-plugin</li>
</ul>
</li>
<li>通过mini-css-extract-plugin提取chunk中的css到单独文件，</li>
</ul>
</li>
<li>图片压缩
<ul>
<li>配置image-wepack-loader</li>
</ul>
</li>
<li>提取页面公共资源
<ul>
<li>基础包分离
<ul>
<li>使用html-webpack-externals-plugin，将基础包通过cdn引入，不打入bundle</li>
</ul>
</li>
</ul>
</li>
<li>利用缓存构建二次构建速度
<ul>
<li>babel-loader：开启缓存</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript不借助第三个变量交换两个变量的值]]></title>
        <id>https://Leonhaiwang.github.io/post/javascript-bu-jie-zhu-di-san-ge-bian-liang-jiao-huan-liang-ge-bian-liang-de-zhi/</id>
        <link href="https://Leonhaiwang.github.io/post/javascript-bu-jie-zhu-di-san-ge-bian-liang-jiao-huan-liang-ge-bian-liang-de-zhi/">
        </link>
        <updated>2021-04-20T06:39:34.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-js">let a = 1,b = 2;
</code></pre>
<ul>
<li>借助了es6的中结构赋值方法</li>
</ul>
<pre><code class="language-js">[a,b] = [b,a]
</code></pre>
<ul>
<li>先把a作为一个对象，赋值键值对，取出键值对</li>
</ul>
<pre><code>a = {a:b,b:a}
a = a.a;
b = a.b;
</code></pre>
<ul>
<li>数组：类似上一种方法</li>
</ul>
<pre><code>a = [a,b]
a = a[1]
b = a[0]
</code></pre>
<ul>
<li>异或</li>
</ul>
<pre><code>a ^= b;
b ^= a;
a ^= b;
</code></pre>
<ul>
<li>加减</li>
</ul>
<pre><code>a = a + b;
b = a - b;
a = a - b;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图片懒加载-按需加载]]></title>
        <id>https://Leonhaiwang.github.io/post/tu-pian-lan-jia-zai-an-xu-jia-zai/</id>
        <link href="https://Leonhaiwang.github.io/post/tu-pian-lan-jia-zai-an-xu-jia-zai/">
        </link>
        <updated>2021-04-16T13:53:23.000Z</updated>
        <content type="html"><![CDATA[<p>#为什么要进行图片懒加载</p>
<ul>
<li>可以让不可视的图片不去加载，避免一次性加载过多的图片导致请求阻塞，提高网站的加载速度，提高用户体验。</li>
</ul>
<p><strong>原理</strong>：监听图片资源容器是否出现在视口区域内，决定图片是否要加载。<mark>如何判断元素处于加载区域</mark></p>
<h2 id="实现">实现</h2>
<ol>
<li>给目标元素一张占位图，将真实的图片链接存在自定义的属性中，data-src</li>
<li>监听scroll事件</li>
<li>利用scroll中的Element.getBoundingClientRect()方法判断目标元素与视口的交叉状态、</li>
<li>当交叉的时候，将真实的图片链接赋值给src或者bgcimage</li>
</ol>
<ul>
<li>scroll可能会被高频触发，这里可以加上节流函数</li>
<li>getBoundingClientRect()方法：返回元素的大小以及相对于视口的位置信息
<ul>
<li>left top</li>
<li>width height</li>
<li><mark>结合视口的宽度和高度，就可以判断元素是否出现在视口区域内</mark></li>
</ul>
</li>
</ul>
<pre><code class="language-js"> function isElementInViewport(el) {
        const { left, top, width, height } = el.getBoundingClientRect();
        const w = window.innerWidth || document.documentElement.clientWidth;
        const h = window.innerHeight || document.documentElement.clientHeight;
        return top &lt;= h &amp;&amp; top + height &gt;= 0 &amp;&amp; left &lt;= w &amp;&amp; left + width &gt;= 0;
      }
</code></pre>
<p>实现</p>
<ul>
<li>scroll只有在滚动的时候才会加载，要首屏渲染</li>
<li>addEventListener()注册事件处理程序的时候，需要保存事件处理程序的引用，以便销毁注册的事件程序。</li>
</ul>
<pre><code class="language-js">//简单的html端
      document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; {
        //获取所有的class为lazy的img标签
        let lazyImages = [].slice.call(document.querySelectorAll(&quot;img.lazy&quot;));
        //active节流
        let active = false;
        const lazyLoad = () =&gt; {
          //throttle：200ms执行一次
          if (active) return;
          active = true;
          setTimeout(() =&gt; {
            lazyImages.forEach((lazyImage) =&gt; {
              //判断元素是否进去viewport
              if (isInViewport(lazyImage)) {
                //设置真实的图片
                //ele.dataset   ==== 读取自定义属性集合
                lazyImage.src = lazyImage.dataset.src;
                lazyImage.srcset = lazyImage.dataset.srcset;
                //删除class 防止下次重复查找到img标签
                lazyImage.classList.remove(&quot;lazy&quot;);
              }
              //更新lazyimags数组，把还没处理的元素拿出来
              lazyImages = lazyImages.filter((image) =&gt; {
                return image != lazyImage;
              });
              //全部处理完毕，移除监听
              if (lazyImages.length === 0) {
                document.removeEventListener(&quot;scroll&quot;, lazyLoad);
                document.removeEventListener(&quot;resize&quot;, lazyLoad);
                document.removeEventListener(&quot;orientationchange&quot;, lazyLoad);
              }
            });
            active = false;
          }, 200);
        };
        document.addEventListener(&quot;scroll&quot;, lazyLoad);
        document.addEventListener(&quot;resize&quot;, lazyLoad);
        document.addEventListener(&quot;orientationchange&quot;, lazyLoad);
      });
</code></pre>
<p>适合单页面应用的写法</p>
<pre><code class="language-js">function LazyLoad() {
  // 这个active是节流throttle所用的标志位，这里用到了闭包知识
  let active = false;

  const lazyLoad = () =&gt; {
    // throttle相关：200ms内只会执行一次lazyLoad方法
    if (active) return;
    active = true;

    setTimeout(() =&gt; {
      // 获取所有class为lazy的img标签，这里由于之前已经把处理过的img标签的class删掉了  所以不会重复查找
      let lazyImages = [].slice.call(document.querySelectorAll(&quot;img.lazy&quot;));

      lazyImages.forEach(lazyImage =&gt; {
        // 判断元素是否进入viewport
        if (isInViewport(lazyImage)) {
          // &lt;img class=&quot;lazy&quot; src=&quot;[占位图]&quot; data-src=&quot;[真实url地址]&quot; data-srcset=&quot;[不同屏幕密度下，不同的url地址]&quot; alt=&quot;I'm an image!&quot;&gt;
          // ele.dataset.* 可以读取自定义属性集合，比如data-*
          // img.srcset 属性用于设置不同屏幕密度下，image自动加载不同的图片  比如&lt;img src=&quot;image-128.png&quot; srcset=&quot;image-256.png 2x&quot; /&gt;
          lazyImage.src = lazyImage.dataset.src;
          lazyImage.srcset = lazyImage.dataset.srcset;
          // 删除class  防止下次重复查找到改img标签
          lazyImage.classList.remove(&quot;lazy&quot;);
        }

        // 当全部处理完了，移除监听
        if (lazyImages.length === 0) {
          document.removeEventListener(&quot;scroll&quot;, lazyLoad);
          window.removeEventListener(&quot;resize&quot;, lazyLoad);
          window.removeEventListener(&quot;orientationchange&quot;, lazyLoad);
        }
      })

      active = false;
    }, 200);
  }

  document.addEventListener(&quot;scroll&quot;, lazyLoad);
  document.addEventListener(&quot;resize&quot;, lazyLoad);
  document.addEventListener(&quot;orientationchange&quot;, lazyLoad);
}

</code></pre>
<p>将函数放在mounted中</p>
<pre><code class="language-vue">mounted: function () {
    LazyLoad();
  }

</code></pre>
<p>封装img-lazy组件</p>
<pre><code class="language-js">&lt;template&gt;
  &lt;img :class=&quot;['lazy', className]&quot; :src=&quot;defaultImg&quot; :data-src=&quot;url&quot; :data-srcset=&quot;`${url} 1x`&quot; alt=&quot;fordeal&quot;&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    props: {
      url: {
        type: String
      },
      defaultImg: {
        type: String,
        default: [默认图片]
      className: {
        type: String,
        default: ''
      }
    }
  }
&lt;/script&gt;

</code></pre>
<p>使用</p>
<pre><code class="language-vue">&lt;img-lazy className=&quot;image&quot; :url=&quot;item.display_image&quot; /&gt;
</code></pre>
<h2 id="现在api">现在api</h2>
<p>IntersectionObserver接口：<strong>异步</strong>监听目标元素与其祖先或者视窗的交叉状态，不会随着目标元素的滚动同步触发。（不会影响页面的性能）</p>
<ol>
<li>
<p>配置项</p>
<ul>
<li>root：所监听对象的具体的祖先元素，viewport</li>
<li>rootMargin：计算交叉状态的时候，将margin加到祖先元素上，有效扩大或者缩小祖先元素的判断范围。</li>
<li>threshold：设置阈值。达到阈值，触发函数。</li>
</ul>
</li>
<li>
<p>回调函数</p>
<p>传递回调函数的时候会传递一个包含inersectionObserverEntry对象的数组，七个属性</p>
<ol>
<li>time：返回一个记录从intersectionObserver的时间原点到交叉被触发的时间戳</li>
<li>target：目标元素</li>
<li>rootBounds：祖先元素的矩阵信息</li>
<li>boundingClientRect：目标元素的矩阵信息</li>
<li>intersectionRect：组件元素与目标元素的相交信息</li>
<li>intersectionRatio：返回intersectionRect与boundingClientRect比例值</li>
<li>isIntersecting:目标元素是否与祖先元素相交。</li>
</ol>
</li>
<li>
<p>实现</p>
<ul>
<li>observe：开始监听一个目标元素</li>
<li>unobserve：停止监听特定元素</li>
<li>disconnect：是inetersectionObserver对象停止工作</li>
<li>takeRecords：为所有的监听目标返回一个intersectionObserverEntry对象数组并且停止监听这些目标。</li>
</ul>
</li>
</ol>
<p>实现</p>
<pre><code class="language-js">function lazyLoad(images, options = {}) {
        if (!(this instanceof lazyLoad)) return new lazyLoad(images, optoins);
        this.setting = Object.assign(
          {},
          { src: &quot;data-src&quot;, srcset: &quot;data-srcset&quot;, selector: &quot;.lazyload&quot; },
          options
        );
        this.images =
          images || document.querySelectorAll(this.setting.selector);
        this.observer = null;
        this.init();
      }
      lazyLoad.prototype.init = function () {
        let self = this;
        let observerConfig = {
          root:null,
          rootMargin:'0px',
          threshold:[0]
        }
        this.observer  = new IntersectionObserver(entries =&gt; {
          entries.forEach(entry =&gt;{
            const target = entry.target;
            if(entry.intersectionRatio &gt; 0){
              this.observer.unobserve(target)
              const src = target.getAttribute(this.setting.src)
              const srcset = target.getAttribute(this.setting.srcset)
              if('img'===target.tagName.toLocaleLowerCase()){
                if(src)target.src = src;
                if(srcset)target.srcset = srcset;
              }else{
                target.style.backgroundImage = `url(${src})`
              }
            }
          })
        },observerConfig)
        this.images.forEach(image =&gt; this.observer.observe(iamge))
      };
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组扁平化 VS 对象扁平化]]></title>
        <id>https://Leonhaiwang.github.io/post/shu-zu-bian-ping-hua-vs-dui-xiang-bian-ping-hua/</id>
        <link href="https://Leonhaiwang.github.io/post/shu-zu-bian-ping-hua-vs-dui-xiang-bian-ping-hua/">
        </link>
        <updated>2021-04-14T08:59:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="数组扁平化">数组扁平化</h2>
<p>flat方法</p>
<ul>
<li>reduce</li>
<li><strong>...</strong></li>
<li>tostring</li>
<li></li>
</ul>
<pre><code class="language-js">//reduce
function flattens(arr){
      return arr.reduce((prev,cur)=&gt;{
        return prev.concat(Array.isArray(cur)?flattens(cur):cur)
      },[])
    }
//遍历递归andforEach
function flattens(arr){
      var result = []
      for(let i = 0;i&lt;arr.length;i++){
        if(Array.isArray(arr[i])){
          result = result.concat(flattens(arr[i]))
        }
        else{
          result.push(arr[i])
        }
      }
      return result
    }
//arr.forEach(x=&gt;{
        if(Array.isArray(x)){
          result = result.concat(flattens(x))
        }
        else{
          result.push(x)
        }
      })
  //map
      function flattens(arr){
      return arr.toString().split(',').map(item=&gt;+item)
    }
//apply some
function flattens(arr){
      while(arr.some(item=&gt;Array.isArray(item))){
        arr = [].concat.apply([],arr)
      }
      return arr
    }
 
//...
 function flattens(arr){
      while(arr.some(item=&gt;Array.isArray(item))){
        arr = [].concat(...arr)
      }
      return arr
    }
</code></pre>
<h1 id="对象扁平化">对象扁平化</h1>
<pre><code class="language-js"> function objectFlat(obj = {}) {
        const res = {};
        function flat(item, perKey = &quot;&quot;) {
          //entries返回一个可枚举属性的数组
          Object.entries(item).forEach(([key, val]) =&gt; {
            const newKey = perKey ? `${perKey}.${key}` : key;
            if (val &amp;&amp; typeof val === &quot;object&quot;) {
              flat(val, newKey);
            } else {
              res[newKey] = val;
            }
          });
        }
        flat(obj);
        return res;
      }
      const source = { a: { b: { c: 1, d: 2 }, e: 3 }, f: { g: 2 } };
      console.log(objectFlat(source));
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组扁平化]]></title>
        <id>https://Leonhaiwang.github.io/post/shu-zu-bian-ping-hua/</id>
        <link href="https://Leonhaiwang.github.io/post/shu-zu-bian-ping-hua/">
        </link>
        <updated>2021-03-30T01:25:32.000Z</updated>
        <content type="html"><![CDATA[<pre><code>//reduce
function flattens(arr) {
  return arr.reduce((prev, cur) =&gt; {
    return prev.concat(Array.isArray(cur) ? flattens(cur) : cur)
  }, [])
}
//遍历
function flattens1(arr1) {
  let result = []
  for(let i= 0;i&lt;arr.length;i++){
    if(Array.isArray(arr[i])){
      result = result.concat(flattens1(arr[i]))
    }else{
      result.push(arr[i])
    }
  }
  return result
}
//forEach
function flattens2 (arr) {
  arr.forEach(element =&gt; {
    if(Array.isArray(element)){
      result = result.concat(flattens1(element))
    }else{
      result.push(element)
    }
  });
}
//...
function flattens3 (arr) {
  while(arr.some(item=&gt;Array.isArray(item))){
    arr = [].concat(...arr)
  }
  return arr
}
//apply some
function flattens4 (arr) {
  while(arr.some(item=&gt;Array.isArray(item))){
    arr = [].concat.apply([],arr)
  }
  return arr
}
//map
function flattens5 (arr) {
  return arr.toString().split(',').map(item=&gt;+item)
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[堆排序]]></title>
        <id>https://Leonhaiwang.github.io/post/dui-pai-xu/</id>
        <link href="https://Leonhaiwang.github.io/post/dui-pai-xu/">
        </link>
        <updated>2021-03-29T12:38:32.000Z</updated>
        <content type="html"><![CDATA[<p>堆排序是一种类似于完全二叉树（子节点总是大于或者小于父节点）的一种数据结构，</p>
<p>平均时间复杂的O(nlogn)</p>
<ul>
<li>大顶堆：每个节点的值都大于或者等于子节点的值，升序</li>
<li>小顶堆：每个节点的值都小于或者等于子节点的值，降序</li>
</ul>
<p>排序过程：</p>
<ul>
<li>将所有的数据存储在堆中</li>
<li>按大顶堆构建堆，将数据从大到小取出，构造出大顶堆</li>
<li>入堆完成后，将堆顶元素取出，末尾元素置于堆顶，调整结构</li>
<li>反复执行</li>
</ul>
<pre><code class="language-js">  var len;

  function buildMaxHeap(arr) { //大顶堆
    len = arr.length;
    for (var i = Math.floor(len / 2); i &gt;= 0; i--) {
      heapify(arr, i)
    }
  }
  //堆调整
  function heapify(arr, i) {
    var left = 2 * i,
      right = 2 * i + 2,
      largest = i;
    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) {
      largest = left;
    }
    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) {
      largest = right;
    }
    if (largest != i) {
      swap(arr, i, largest)
      heapify(arr, largest)
    }
  }

  function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }

  function heapSort(arr) {
    buildMaxHeap(arr);
    for (let i = arr.length - 1; i &gt; 0; i--) {
      swap(arr, 0, i);
      len--;
      heapify(arr, 0)
    }
    return arr;
  }
  console.log(heapSort([1, 3, 7, 3, 24, 5]));
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二维码登录的本质]]></title>
        <id>https://Leonhaiwang.github.io/post/er-wei-ma-deng-lu-de-ben-zhi/</id>
        <link href="https://Leonhaiwang.github.io/post/er-wei-ma-deng-lu-de-ben-zhi/">
        </link>
        <updated>2021-03-29T08:26:55.000Z</updated>
        <content type="html"><![CDATA[<p>本质上就是一种登录认证</p>
<ul>
<li>告诉系统我是谁</li>
<li>向系统证明我是谁</li>
</ul>
<p>事实上：扫码只需要确认是本人的手机的账号操作的，就能间接的认证用户的身份。（不是通过二维码将账号密码传过去的，too danger！）</p>
<p>二维码的实际上可以看做是String字符串，</p>
<h2 id="一般系统认证机制">一般系统认证机制</h2>
<ol>
<li>账号密码登录的时候，客户端将设备信息一起传给服务端</li>
<li>如果账号密码被校验通过以后会将账号和设备绑定，存起来（账号，密码，设备ID）Token中</li>
<li>客户端得到这个token后，进行一个本地保存（storage），每一次访问api都带上token</li>
<li>服务端通过token找到绑定的账号的设备信息，如果相同，校验通过，返回数据。</li>
</ol>
<h2 id="扫码登录一般步骤">扫码登录一般步骤</h2>
<ol>
<li>扫码前，手机端已登录，Pc端二维码展示</li>
<li>手机打开应用扫码，授权，PC端登录成功</li>
</ol>
<p>QRCode在这个过程中有三个状态</p>
<ul>
<li>待扫码pending</li>
<li>已扫码，待确认</li>
<li>已确认</li>
</ul>
<h3 id="pc端口二维码准备">pc端口二维码准备</h3>
<ol>
<li>PC端向服务端发送请求，将PC设备传给服务端</li>
<li>服务端收到信息后，将二维码ID与Pc端信息进行绑定 并发送给Pc客户端</li>
<li>生成二维码</li>
<li>PC端不断的轮询服务端，请求当前的二维码的状态信息</li>
</ol>
<h3 id="扫描状态切换">扫描状态切换</h3>
<ol>
<li>用户扫码获取到Pc的二维码ID，调用服务端API将移动端的信息与二维码ID发送给服务端</li>
<li>服务端收到以后将身份信息和二维码ID绑定，生成临时token，返回给手机端</li>
<li>Pc端一直在轮询二维码的状态，改变二维码状态---&gt;已扫描</li>
</ol>
<h3 id="状态确认">状态确认</h3>
<ol>
<li>手机端收到临时token会弹出登录页面，用户点击确认的时候，手机携带临时token调用服务端端口，已经确认</li>
<li>服务端收到确认以后根据二维码ID绑定的设备信息生成Pc端登录的token</li>
<li>PC端轮询接口，二维码已确认，登录成功，访问资源</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[伪类和伪元素的区别？使用场景？]]></title>
        <id>https://Leonhaiwang.github.io/post/wei-lei-he-wei-yuan-su-de-qu-bie-shi-yong-chang-jing/</id>
        <link href="https://Leonhaiwang.github.io/post/wei-lei-he-wei-yuan-su-de-qu-bie-shi-yong-chang-jing/">
        </link>
        <updated>2021-03-25T11:42:21.000Z</updated>
        <content type="html"><![CDATA[<p>伪类：用来选择不能够被普通选择器选择的文档以外的元素  ：hover    <strong>可以理解为<mark>特定状态</mark>元素的选择器</strong></p>
<p>伪元素：需要创建不存在与文档中的元素，比如：before     <strong>类似添加一个新的节点到</strong>DOM<strong>中</strong></p>
<h2 id="区别">区别：</h2>
<p>表示方法：css2中伪类and伪元素都是以：  css2.1以后伪类用<code>:</code> 伪元素用 <code>::</code>表示。</p>
<p>定义不同：伪类（假的类）------&gt;添加类达到效果，伪元素（假的元素 ）-----&gt;添加元素达到效果。</p>
<h2 id="异同">异同：</h2>
<ul>
<li>都用来表示文档树以外的“元素”</li>
<li>伪类和伪元素分别用 ：  | ：：</li>
<li><mark>伪类是操作文旦中已经有的元素，伪元素是创建一个文档以外的元素</mark></li>
<li><strong>如果没有伪元素，是否需要添加元素才能达到效果，如果是---&gt;伪元素    反之---&gt;伪类</strong></li>
</ul>
<p>伪类：  hover active link ：nth-child<br>
伪元素： ：before ::first-letter        ::selection  ::backdrop</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[call、apply、bind 理解及实现]]></title>
        <id>https://Leonhaiwang.github.io/post/callapplybind-li-jie-ji-shi-xian/</id>
        <link href="https://Leonhaiwang.github.io/post/callapplybind-li-jie-ji-shi-xian/">
        </link>
        <updated>2021-03-25T09:18:26.000Z</updated>
        <content type="html"><![CDATA[<p>三个方法都能改变this的内部指向。</p>
<h2 id="call">call()</h2>
<p>call是属于所有function的方法，也就是Function.prototype.call</p>
<pre><code class="language-js">fun.call(thisArg[,arg1[,arg2,…]]);
</code></pre>
<p>可以让call中的对象调用当前对象所拥有的Function</p>
<pre><code class="language-js">function a(){
    //输出函数a中的this对象
    console.log(this); 
}
//定义函数b
function b(){} 

var obj = {name:'这是一个屌丝'}; //定义对象obj
a.call(); //window
a.call(null); //window
a.call(undefined);//window
a.call(1); //Number
a.call(''); //String
a.call(true); //Boolean
a.call(b);// function b(){}
a.call(obj); //Object
</code></pre>
<h2 id="apply">apply()</h2>
<p>apply<code>也是属于所有</code>Function<code>的方法，也就是</code>Function.prototype.apply</p>
<pre><code>fun.apply(thisArg, [argsArray]);
</code></pre>
<p><code>thisArg</code>就是<code>this</code>指向，<code>argsArray</code>是指定的参数数组</p>
<p>call参数是一个列表，将每个参数一个一个列出来。</p>
<p>apply参数是一个数组，将每个参数放在一个数组中</p>
<pre><code class="language-js">function jsy(x,y,z){
    console.log(x,y,z);
}

jsy.apply(null,[1,2,3]); 
// 1 2 3
</code></pre>
<h2 id="bind">bind()</h2>
<p>bind方法创建一个新的函数，当被调用的时候，将其this关键字设置为提供的值，在调用新函数的时候，在任何提供之前提供一个给定的参数序列</p>
<pre><code>fun.bind(thisArg[, arg1[, arg2[, ...]]])
</code></pre>
<p>bind会创建一个新的函数（绑定函数），原函数的一个拷贝，不会像call和apply一样立即执行-返回函数的引用</p>
<h2 id="总结">总结：</h2>
<ul>
<li>三者都是用来改变函数的this指向的，第一个参数都是this指向的对象。</li>
<li>bing是返回一个函数后可稍后执行，call/apply是立即调用</li>
<li>都可以给定参数传递</li>
<li>call给定参数需要将参数全部列出，apply给定参数组</li>
</ul>
<h2 id="模拟实现">模拟实现</h2>
<h3 id="call-2">call()</h3>
<p>call函数改变了this的指向，给传入的对象添加属性方法之后再删除</p>
<ol>
<li>将函数设为对象的属性</li>
<li>执行该函数</li>
<li>删除该函数</li>
</ol>
<pre><code class="language-js"> Function.prototype.call3 = function(context){
      //传值null的时候this指向window
      var context = context||window
      context.fn = this
      //循环arguments的值，除了第一项保存在args数组中
      var args = []
      for(i = 1,len = arguments.length;i&lt;len;i++){
        args.push('arguments['+i+']')
      }
      //把args参数数组放到要执行的函数里面
      var result = eval('context.fn('+args+')')
      //返回值
      delete context.fn
      return result
    }
    var value = 2;
    var obj = {
        value: 1
    }
   function bar(name, age) {
        console.log(this.value);
        return {
            value: this.value,
            name: name,
            age: age
        }
    }
    bar.call3(null)
    bar.call3(obj,&quot;name&quot;,45)
</code></pre>
<pre><code class="language-js">    //this为调用的函数
    //context是参数对象
    Function.prototype.myCall = function(context){
      //判断调用者是否是一个函数
      if(typeof this !='function'){
        throw new Error('this is a error')
      }
      //不传参数默认为window
      context = context||window
      //将值设置为需要调用的函数
      context.fn = this
      //将arguments转化为数组，将要用的值提取出来
      let args  = [...arguments].slice(1)
      // 传参调用函数
      const result = context.fn(...args)    
      //删除函数
      delete context.fn
      //返回执行结果
      return result
    }
    function print(age){
      console.log(this.name + age)
    }
    var obj = {
      name:'LiHui'
    }
    print.myCall(obj,11)
</code></pre>
<h3 id="apply-2">apply()</h3>
<p>apply实现方法和call相似，不同的就是在apply中传过来的参数就是一个数组，这里要把传过来的数组遍历，执行fn函数。中间需要添加传入的值是否是数组的判断</p>
<pre><code class="language-js">Function.prototype.apply1 = function(context,arr){
      var context = Object(context)||window
      context.fn = this
      var result;
      if(!arr){
        result = context.fn
      }
      else{
        var args = []
        for(var i = 0;i&lt;arr.length;i++){
          args.push('arr['+i+']')
        }
        result = eval('context.fn('+args+')')
      }
      delete context.fn
      return result
    }
</code></pre>
<pre><code class="language-js">	Function.prototype.myApply = function(context){
      if(typeof this != 'function'){
        throw new Error('is not a function')
      }
      context = context || window
      context.fn = this
      let result;
      if(arguments[1]){
        result = context.fn(...arguments[1])
      }else{
        result = context.fn()
      }
      delete context.fn
      return result
    }
    function print(age){
      console.log(this.name + &quot; &quot;+age)
    }
    var obj = {
      name:'name'
    }
    print.myApply(obj,[12])
</code></pre>
<h3 id="bind-2">bind()</h3>
<pre><code class="language-js">Function.prototype.myBind = function(context){
      //判断调用者是否为函数
      if(typeof this!='function'){
        throw new Error('must be a function')
      }
      //截取传递的参数
      const args = [...arguments].slice(1)
      //_this指向调用的函数
      const _this = this
        //返回一个函数
       return function F(){
         //判断this是不是 new F()实例，因为new不会被任何方式改变this
         if(this instanceof F){
           return new _this(...args,...arguments)
         }else{
           return _this.apply(context,args.concat(...arguments))
         }
       }
    }
    function print(age){
      console.log(this.name+ &quot;-&quot; +age)
    }
    var obj = {
      name:&quot;name&quot;
    }
    print.myBind(obj,123)()
</code></pre>
<h4 id="不用callapply实现bind">不用call(),apply()实现bind()</h4>
]]></content>
    </entry>
</feed>