<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Leonhaiwang.github.io</id>
    <title>Leon</title>
    <updated>2021-03-25T09:09:37.079Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Leonhaiwang.github.io"/>
    <link rel="self" href="https://Leonhaiwang.github.io/atom.xml"/>
    <subtitle>It is always day one !</subtitle>
    <logo>https://Leonhaiwang.github.io/images/avatar.png</logo>
    <icon>https://Leonhaiwang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Leon</rights>
    <entry>
        <title type="html"><![CDATA[从输入URL到页面加载发生了什么]]></title>
        <id>https://Leonhaiwang.github.io/post/cong-shu-ru-url-dao-ye-mian-jia-zai-fa-sheng-liao-shi-me/</id>
        <link href="https://Leonhaiwang.github.io/post/cong-shu-ru-url-dao-ye-mian-jia-zai-fa-sheng-liao-shi-me/">
        </link>
        <updated>2021-03-25T08:45:33.000Z</updated>
        <content type="html"><![CDATA[<p>😀😃😄</p>
<ul>
<li>DNS域名解析：将域名解析成IP地址</li>
<li>TCP连接：三次握手</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>断开连接：TCP四次挥手</li>
</ul>
<h2 id="dns域名解析">DNS域名解析</h2>
<p>计算机的唯一标识是IP地址，但是IP地址并不方面记忆。一个网址到一个IP的转换。</p>
<ul>
<li>首先在本地域名中查找IP地址，如果没有找到，本地域名向根域名服务器发送一个请求，如果根域名服务器中也没有，那会就会找到COM顶级域名查找，依次类推。直到找到以后存在缓存本地中。</li>
<li>整个过程是一个从右往左的过程。www.google.com.      .   就是对应的根域名服务器，通常会省略。</li>
</ul>
<p>DNS存在多级缓存，从浏览器的距离排序：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</p>
<p>DNS可以返回一个合适的IP给客户。位置，负载量，DNS负载均衡，重定向，是不一样的，但是在用户眼里是一样的。</p>
<h2 id="tcp连接">TCP连接</h2>
<p>三次握手</p>
<h2 id="http请求">HTTP请求</h2>
<p>客户端：构建HTTP请求报文并通过TCP协议发送到服务器指定端口（HTTP：80、HTTPS：443）。</p>
<h3 id="请求行">请求行</h3>
<p>请求方法：get,post,head,put,delete,patch,trace,options</p>
<p>URL:请求地址：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;？&lt;参数&gt;&lt;组成&gt;  http://localhost:8800/user?id=20</p>
<p>协议版本号：http版本号</p>
<h3 id="请求头">请求头</h3>
<p>请求的附加信息：关键字：值/对。HOST：主机名   keepalive：持久连接 User-agent:请求发出者</p>
<h3 id="请求体">请求体</h3>
<p>请求体：可以承载多个请求参数的数据 name=tom&amp;age=12</p>
<h2 id="服务器处理并返回http报文">服务器处理并返回http报文</h2>
<p>后端在固定的端口接受到TCP报文，对TCP连接进行处理，对http协议进行解析，并按照报文格式进一步封装成http request对象供上层使用。</p>
<p>服务器会安装处理请求的应用：web Server.     apache，Nginx，lighttpd ，IIS</p>
<h3 id="组成">组成</h3>
<p>响应行：响应版本，状态描述，状态码：200，301,302，303,400,404,500，403</p>
<p>响应报头：connection，Server</p>
<p>响应报文：服务器返回给浏览器的信息，html，css，js，图片文件等，并不是所有的响应报文都有相应数据。</p>
<h2 id="浏览器解析渲染页面">浏览器解析渲染页面</h2>
<p>边解析边渲染。</p>
<ul>
<li>根据html解析DOM树</li>
<li>根据css生成CSS规则树</li>
<li>结合DOM树和规则树生成渲染树rendertree</li>
<li>根据渲染树计算每一个节点的信息。</li>
<li>根据计算好的信息绘制页面。</li>
</ul>
<h3 id="根据html解析dom树">根据html解析DOM树</h3>
<p>根据html内容，将标签按照结构解析成DOM树，DOM树解析的过程是一个深度优先的过程，（先构建当前DOM元素的子阶段，再构建下一个兄弟节点）</p>
<p>在构建DOM树的过程中，如果遇到script标签，会等脚本执行完毕以后再继续</p>
<h3 id="根据css生成css规则树">根据css生成CSS规则树</h3>
<p>解析css生成树完成以前浏览器不会进行渲染。</p>
<p>解析css规则树的时候，js将会暂停，知道css规则树就绪。</p>
<h3 id="结合dom树和规则树生成渲染树rendertree">结合DOM树和规则树生成渲染树rendertree</h3>
<p>DOM树和css规则树全部生成好以后，浏览器才会开始构建渲染树</p>
<p>精简css可以加快css规则树的构建，加快页面渲染</p>
<h3 id="根据渲染树计算每一个节点的信息-布局">根据渲染树计算每一个节点的信息。布局</h3>
<p>布局：通过渲染树中的对象，计算出每一个渲染对象的位置和尺寸</p>
<p>回流：在布局形成后，发生了某个部分变化引起了布局，需要回去重新布局</p>
<h3 id="根据计算好的信息绘制页面">根据计算好的信息绘制页面。</h3>
<p>系统遍历呈现树，并且调用‘paint’的方法，将呈现器内容显示在屏幕上。</p>
<p>重绘：某个元素的背景颜色，文字颜色等，不影响元素周围和内部的属性</p>
<p>回流：某个元素的大小变化，需要重新计算	渲染树，重新渲染。</p>
<p>事件循环：JS</p>
<h2 id="断开连接">断开连接</h2>
<p>TCP四次挥手。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6]]></title>
        <id>https://Leonhaiwang.github.io/post/es6/</id>
        <link href="https://Leonhaiwang.github.io/post/es6/">
        </link>
        <updated>2021-03-25T08:30:10.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>[toc]</p>
<h1 id="11-什么是ecma">1.1 什么是ECMA</h1>
<p>ECMA（European Computer Manufacturers Association）中文名：欧洲计算机制造商协会</p>
<h1 id="12-什么是ecmascript">1.2 什么是ECMAScript</h1>
<table>
<thead>
<tr>
<th>版本</th>
<th>更新</th>
</tr>
</thead>
<tbody>
<tr>
<td>ES5</td>
<td>引入严格模式、JSON，扩展对象,bind。数组、原型、字符串、日期方法</td>
</tr>
<tr>
<td>ES6</td>
<td>let、const 变量声明、模块化、面向对象语法、Promise、箭头函数、数组解构赋值等等</td>
</tr>
<tr>
<td>ES7</td>
<td>幂运算符、数组扩展、Async/await 关键字</td>
</tr>
</tbody>
</table>
<h1 id="21-严格模式的理解es5">2.1 严格模式的理解——ES5</h1>
<h2 id="概念">概念</h2>
<p><strong>理解</strong>：除了正常运行模式（混杂模式），ES5添加了第二种运行模式：“严格模式”（strict mode）。</p>
<p>顾名思义，这种模式使得 JavaScript 在更严格的语法条件下运行</p>
<p><strong>目的：</strong></p>
<ul>
<li>消除JavaScript语法的一些不合理、不严谨之处，减少一些怪异行为。</li>
<li>消除代码运行的一些不安全之处，伪代码的安全运行保驾护航</li>
<li>为未来新版本的JavaScript做好铺垫</li>
</ul>
<h2 id="使用">使用</h2>
<ul>
<li>针对整个脚本文件：将 <code>&quot;use strict&quot;</code> 放在脚本文件的第一行，则整个脚本文件将以严格模式运行。</li>
<li>针对单个函数：将<code>&quot;use strict&quot;</code>放在函数体的第一行，则整个函数以严格模式运行</li>
</ul>
<h2 id="语法和行为改变">语法和行为改变</h2>
<ul>
<li>必须要声明变量
<ul>
<li>可以是<code>var ab = 10</code>，但不能是<code>ab = 10</code>（当然已经声明了ab的可以改变ab的值）</li>
</ul>
</li>
<li>禁止自定义的函数中的this指向window</li>
<li>创建eval作用域</li>
<li>对象不能有重名的属性</li>
</ul>
<h1 id="22-严格模式和普通模式的区别es5">2.2 严格模式和普通模式的区别——ES5</h1>
<p>下面列举几条严格模式的内容</p>
<h2 id="全局变量显示声明">全局变量显示声明</h2>
<p>在<strong>正常模式</strong>中，如果一个变量没有声明就付诸，默认是全局变量。</p>
<p>在<strong>严格模式</strong>中，禁止这种用法，全局变量必须显示声明。</p>
<h2 id="禁止this关键字指向全局对象">禁止this关键字指向全局对象</h2>
<pre><code class="language-JavaScript">function abc(){
  console.log(this);
}

abc()
</code></pre>
<p>在<strong>正常模式</strong>中，打印的是window。</p>
<p>在<strong>严格模式</strong>中，打印的是undefined。</p>
<h2 id="禁止使用with语句">禁止使用with语句</h2>
<p>因为with语句无法在编译时就确定，属性到底归属哪个对象</p>
<h2 id="构造函数必须通过new实例化对象">构造函数必须通过new实例化对象</h2>
<p>构造函数必须通过 new 实例化对象，否则报错。因为this为undefined，此时无法设置属性。</p>
<p>比如说：</p>
<pre><code class="language-javascript">function Student(){
  this.name = &quot;小红&quot;
  this.age = 18
  this.gender = 0
}

var s1 = new Student()//严格模式下的正确创建创建对象方法

var s2 = Student();//严格模式下报错
</code></pre>
<h1 id="31-json对象es5">3.1 JSON对象——ES5</h1>
<p>1、js对象（数组）--&gt;json对象（数组）：</p>
<pre><code>	JSON.stringfy(obj/arr)
</code></pre>
<p>2、json对象（数组）--&gt;js对象（数组）</p>
<pre><code class="language-javascript">	JSON.parse(json)
</code></pre>
<p>上面两个方法是 ES5 中提供的。</p>
<p>&quot;json字符串&quot;只有两种：<strong>json对象、json数组</strong></p>
<p><code>typeof json字符串</code>的返回结果是string</p>
<h1 id="41-object的扩展es5">4.1 Object的扩展——ES5</h1>
<p>ES5给Object扩展了一些静态的方法，常用的有2 个</p>
<h2 id="方法一-objectcreate">方法一 Object.create</h2>
<pre><code class="language-javascript">Object.create(prototype,[descriptors])
</code></pre>
<p>作用：以指定对象作为原型，创建新的对象。同时第二个参数可以为新的对象添加新的属性，并对此属性进行描述。</p>
<p><strong>举例1</strong>（没有第二个参数时）</p>
<pre><code class="language-JavaScript">var a = {
    username :&quot;admin&quot;,
    password:&quot;123456&quot;
}

// 不传第二个参数 Object.create(a)
var b = Object.create(a)

console.log(a,&quot;a&quot;);
console.log(b,&quot;b&quot;);
</code></pre>
<p>输出以下结果：</p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5CMaMing%5CDesktop%5Cdemo%5CES6~ES11%5C01README.assets%5Cimage-20200918082752774.png" alt="image-20200918082752774" loading="lazy"></figure>
<p>我们发现输出b里面什么都没有，但我们打开它的<code>__proto__</code>原型就会发现：</p>
<figure data-type="image" tabindex="2"><img src="C:%5CUsers%5CMaMing%5CDesktop%5Cdemo%5CES6~ES11%5C01README.assets%5Cimage-20200918083032836.png" alt="image-20200918083032836" loading="lazy"></figure>
<p><strong>a对象成为了b的原型</strong></p>
<hr>
<p><strong>举例2：</strong>(有第二个参数)<br>
第二个参数可以给新对象添加新的属性。例如：</p>
<p>把 a 对象设为 c 的原型的同时给 c 附加三个属性：name、gender、age</p>
<pre><code class="language-javascript">var a = {
    username :&quot;admin&quot;,
    password:&quot;123456&quot;
}
var c =Object.create(a,{
    name:{//添加name属性
        value :&quot;老王&quot;,//通过value关键字设置name的属性值
        writable:true,//是否可修改
        configurable:true,//是否可删除
        enumerable:true//是否可被迭代
    },
    
    gender:{//添加gender属性
        value :&quot;1&quot;,
        writable:false,
        configurable:true,
        enumerable:true
    },
    
    age:{//添加gender属性
        value :&quot;45&quot;,
        writable:true,
        configurable:true,
        enumerable:true
    },
})

// delete(c.gender)     ----------&gt; 	删除属性的方式

console.log(c , &quot;c&quot;);
</code></pre>
<p>运行结果：</p>
<figure data-type="image" tabindex="3"><img src="C:%5CUsers%5CMaMing%5CDesktop%5Cdemo%5CES6~ES11%5C01README.assets%5Cimage-20200918084223539.png" alt="image-20200918084223539" loading="lazy"></figure>
<p>上方代码中，</p>
<p>我们通过<code>Object.create(prototype,[descriptors])</code>的第二个参数给 <code>c</code> 设置了<code>name</code>、<code>gender</code>、<code>age</code>属性，但是要通过<code>value</code>来设置属性值，属性值默认是不可修改的，要通过<code>writable</code>来设置，这几个关键字解释如下：</p>
<ul>
<li><code>value</code>:设置属性值。</li>
<li><code>writable</code>：表示当前属性值是否可修改。默认为false。</li>
<li><code>configurable</code>:表示当前属性是否可以被删除。默认为false。</li>
<li><code>enumerable</code>表示当前属性是否能用 <code>for in</code>枚举，默认为false</li>
</ul>
<p><code>Object.create(prototype,[descriptors])</code>也是一种继承方式，例如：</p>
<pre><code class="language-javascript">student = {
    school:&quot;二小&quot;,
    learn:function(){
        console.log(&quot;俺会学习&quot;);
    },
}
var monitor = Object.create(student,{
    type:{
        value:&quot;班长&quot;,
        writable:true,
        configurable:true,
        enumerable:true
    },
    age:{
        value:&quot;20&quot;,
        writable:true,
        configurable:true,
        enumerable:true
    },
})
console.log(monitor);
</code></pre>
<h2 id="方法二-objectdefineproperty和objectdefineproperties">方法二 Object.defineProperty和Object.defineProperties</h2>
<p><strong>单独设置属性</strong></p>
<p><code>Object.defineProperty(obj, prop, descriptor)</code></p>
<p>参数说明：</p>
<pre><code>1 obj：必需。目标对象
2 prop：必需。需定义或修改的属性的名字
3 descriptor：必需。目标属性所拥有的特性
</code></pre>
<p>该方法可以（单独）重新定义或修改对象的属性</p>
<pre><code class="language-javascript">Object.defineProperty(monitor,&quot;type&quot;,{
    value:&quot;副班长&quot;,
    writable:true,
    configurable:true,
    enumerable:true
})
</code></pre>
<p><strong>设置属性并了解get 和 set</strong></p>
<p><code>Object.defineProperties(object,descriptors)</code></p>
<p>如果想给一个属性和某些数据绑定，就可以用到<code>get</code>和<code>set</code>,</p>
<p>在了解 get 和 set 前我们先了解一下什么是<strong>存取描述符</strong>和<strong>数据属性描述符</strong></p>
<ul>
<li>
<p><strong>存取描述符</strong>指可以控制数据如何存放和去除或者是否可以存放和取出的，是宏观上的。</p>
</li>
<li>
<p><strong>数据属性描述符</strong>指可以控制当前数据的值的属性和内容的，是微观的。</p>
</li>
<li>
<p>而<strong>存取描述符和数据属性描述符不能同时出现</strong>，</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>存取描述符</th>
<th>数据属性描述符</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>writable</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>configurable</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>enumerable</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>get</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>set</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody>
</table>
<p>也就是说有<code>value/writable</code>不能有<code>get/set</code>，有<code>get/set</code>不能有<code>value/writable</code></p>
<ul>
<li>get和set以函数的名义出现。</li>
<li>get函数----&gt;每次获取属性值时会调用该函数</li>
<li>set函数-----&gt;每次 设置/改变 属性值时会调用该函数</li>
</ul>
<pre><code class="language-javascript">        var user = {
            firstName:&quot;Peter&quot;,
            lastName: &quot;Parker&quot;,
            // fullName:firstName+lastName
        }

        Object.defineProperties(user, {
            fullName: {
                // 获取属性值时调用的函数
                get: function () {
                    return this.firstName + &quot;-&quot; + this.lastName
                },
                // 设置属性值时调用的函数
                set: function (data) {
                    console.log(&quot;被设置为了&quot; + data);
                    var arr = data.split(&quot;-&quot;);
                    console.log(arr);
                    if (arr.length == 2) {
                        this.firstName = arr[0]
                        this.lastName = arr[1]
                    } else {
                        console.log(&quot;输入不规范&quot;);
                    }
                }
            }
        })

        console.log(user);
</code></pre>
<h1 id="51-数组的扩展es5">5.1 数组的扩展——ES5</h1>
<h2 id="方法1-indexof">方法1 ：indexof</h2>
<pre><code>	Array.prototype.indexof(value)
</code></pre>
<p>获取value在数组中的第一个下标，如果没有返回-1</p>
<figure data-type="image" tabindex="4"><img src="https://upload-images.jianshu.io/upload_images/7047608-5bc57863d5d35991.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/228/format/webp" alt="img" loading="lazy"></figure>
<h2 id="方法2lastindexof">方法2：lastIndexOf</h2>
<pre><code>	Array.prototype.lastIndexOf(value)
</code></pre>
<p>获取value在数组中的最后一个下标，如果没有返回-1</p>
<h2 id="方法3foreach">方法3：forEach</h2>
<pre><code>Array.prototype.forEach(function(item,index,arr){})		//参数index，arr可选
</code></pre>
<p>作用：遍历当前数组，参数为一个回调函数，回调有三个值：</p>
<ol>
<li>当前元素，2. 当前元素索引值，3. 整个数组</li>
</ol>
<h2 id="方法4map">方法4：map</h2>
<pre><code>Array.prototype.map(function(item,index,arr){})			//参数index，arr可选
</code></pre>
<p>作用：遍历数组返回一个新的数组，返回的是<strong>加工之后</strong>的新数组</p>
<pre><code class="language-javascript">        var arr = [1,5,7,6,4,6,12,6,46,9,4,3,1,4,61,23,1,4,6,456]
        var newArr = arr.map(function(item){
            return item+&quot;个傻X&quot;
        })
        console.log(arr);
        console.log(newArr);
</code></pre>
<p>运行结果：</p>
<figure data-type="image" tabindex="5"><img src="C:%5CUsers%5CMaMing%5CDesktop%5Cdemo%5CES6~ES11%5C01README.assets%5Cimage-20200918180149615.png" alt="image-20200918180149615" loading="lazy"></figure>
<h2 id="方法5-filter">方法5： filter</h2>
<pre><code>Array.prototype.filter(function(item,index){})		//参数2，3可选
</code></pre>
<p>作用：遍历过滤出一个新的子数组，<strong>返回条件为true的值</strong></p>
<pre><code class="language-JavaScript">        var arr = [1,5,7,6,4,6,12,6,46,9,4,3,1,4,61,23,1,4,6,456]
        var newArr  = arr.filter(function(element){
            return element&gt;10
        }) 
        console.log(arr);
        console.log(newArr);
</code></pre>
<p>运行结果：</p>
<figure data-type="image" tabindex="6"><img src="C:%5CUsers%5CMaMing%5CDesktop%5Cdemo%5CES6~ES11%5C01README.assets%5Cimage-20200918183825258.png" alt="image-20200918183825258" loading="lazy"></figure>
<h2 id="方法6every">方法6：every</h2>
<pre><code>Array.prototype.every(function(element,index,array){});
</code></pre>
<p>作用：判断函数的回调函数是否<strong>全部</strong>都符合条件。</p>
<p>所有函数的回调函数都返回true则返回true，否则返回false</p>
<pre><code class="language-JavaScript">        var arr = [1,5,7,6,4,6,12,6,46,9,4,3,1,4,61,23,1,4,6,456]

        var result1 = arr.every(function(ele){
            return ele &lt; 500
        })

        var result2 = arr.every(function(ele){
            return ele &gt; 10 
        })

        console.log(result1);//true
        console.log(result2);//false
</code></pre>
<p>运行结果：</p>
<p>true</p>
<p>false</p>
<h2 id="方法7-some">方法7 ：some</h2>
<pre><code>Array.prototype.some(function(element,index,array){});
</code></pre>
<p>作用：判断回调中是否存在<strong>一个或以上</strong>符合条件。</p>
<p>存在一个函数的回调函数返回true则返回true，否则返回false</p>
<pre><code class="language-JavaScript">            var arr = [1,5,7,6,4,6,12,6,46,9,4,3,1,4,61,23,1,4,6,456]
            var result1 = arr.some(function(ele){
                return ele == 9
            })
            var result2 = arr.some(function(ele){
                return ele == 100
            })

            console.log(result1);	//true
            console.log(result2);	//false
</code></pre>
<p>运行结果：</p>
<p>true</p>
<p>false</p>
<h2 id="方法8reduce">方法8：reduce</h2>
<pre><code>Array.prototype.reduce(function(prev,curr,index,arr){})
</code></pre>
<p>跳过第一项，<strong>从第二项开始遍历</strong></p>
<p><strong>不要被这个方法的名字迷惑了</strong>，reduce的中文意思是减少的意思，但事实上<code>reduce</code>进行的操作大多不是用来进行减法运算，我们举个例子，来看一下这四个参数到底是干什么的</p>
<pre><code class="language-JavaScript">        var arr = [1,2,3,4,5]
        var result1 = arr.reduce(function(prev,cur,index,arr){
            console.log(prev,cur,index,arr);

            return prev + cur
        })
        console.log(result1);
</code></pre>
<p>运行结果：</p>
<figure data-type="image" tabindex="7"><img src="C:%5CUsers%5CMaMing%5CDesktop%5Cdemo%5CES6~ES11%5C01README.assets%5Cimage-20200919085223262.png" alt="image-20200919085223262" loading="lazy"></figure>
<ol>
<li>prev: 第一项的值或上一次叠加的结果值</li>
<li>cur: 当前会参与叠加的项</li>
<li>index： 当前值的索引</li>
<li>arr: 数组本身</li>
</ol>
<p><strong>prev并不是当前项的上一项</strong>，prev表示每次叠加之后的结果</p>
<p>如果我们就是想从第一项开始遍历怎么办，但是从第一项开始遍历的话，第一项就不具备 prev 的值了，</p>
<p>这时候我们就可以传另外一个参数。末尾添加一个<code>value</code> ，这里我们拿 0 举例，</p>
<p>这个0表示的就是第一项的 prev 的值</p>
<pre><code class="language-JavaScript">        var result1 = arr.reduce(function (prev, cur, index, arr) {
            console.log(prev, cur, index, arr);

            return prev + cur
        },0)
</code></pre>
<h1 id="61函数function的扩展es5">6.1函数function的扩展——ES5</h1>
<p>ES5 中新增了<code>bind()</code>函数来<strong>改变this的指向</strong></p>
<p>类似的函数还有<code>call()</code>、<code>apply()</code></p>
<p>那么这三个函数<code>call()</code>、<code>apply()</code>和<code>bind()</code>都怎么使用呢，又都有什么区别呢</p>
<p><strong>例1：</strong></p>
<pre><code class="language-JavaScript">        var name = &quot;老王&quot;
        var age = 45
        var obj = {
            name:&quot;老马&quot;,
            objAge:this.age,//this指向window
            objFun:function(){
                console.log(this.name+&quot;年龄&quot;+this.age);//this指向obj
            }
        }      
</code></pre>
<pre><code class="language-JavaScript">obj.objAge	 //45
obj.objFun();   //老马年龄undefined
</code></pre>
<p><strong>例2：</strong></p>
<pre><code class="language-JavaScript">        var foo = &quot;老张&quot;
        function shows(){
            console.log(this.foo);//this指向window
        }
</code></pre>
<pre><code>        shows();    //老张
</code></pre>
<p>很明显，例1中 obj.objFun()里的<code>this</code>指向obj，而 例2中 shows的<code>this</code>指向window</p>
<p>要想改变这一点，我们可以使用call()、apply()、bind()</p>
<p><strong>1，call()、apply()、bind() 都是用来重定义 this 这个对象的</strong></p>
<pre><code class="language-javascript">        var name = &quot;老王&quot;
        var age = 45
        var obj = {
            name:&quot;老马&quot;,
            objAge:this.age,		//this指向window
            objFun:function(){
                console.log(this.name+&quot;年龄&quot;+this.age);//this指向obj
            }
        }
        
        var another = {
            name:&quot;老傻X&quot;,
            age:&quot;99&quot;
        }
</code></pre>
<pre><code class="language-javascript">		obj.objFun.call(another)    //老傻X年龄99
        obj.objFun.apply(another)   //老傻X年龄99
        obj.objFun.bind(another)()  //老傻X年龄99
</code></pre>
<p>除了bind()方法后面多了一个<code>()</code>，其他都一样，返回结果也是相同的。</p>
<p>这是因为</p>
<p><code>call()</code>和<code>apply()</code>是<strong>立即调用函数</strong>，</p>
<p>而<code>bind()</code>绑定完this之后，不会立即调用当前函数，而是<strong>将函数返回</strong>，因此后面还需要加()来能使用</p>
<p><strong>2，对比call() 、bind() 、 apply()传参情况下</strong></p>
<p>当我们需要给函数传递参数时，call() 、bind() 、 apply()也能做到</p>
<pre><code class="language-javascript">        var name = &quot;老王&quot;
        var age = 45
        var obj = {
            name:&quot;老马&quot;,
            objAge:this.age, 
            objFun:function(a,b){//需要传递参数 a,b 
                console.log(this.name+&quot;年龄&quot;+this.age+&quot;,来自：&quot;+ a +&quot;，去往：&quot;+b);
            }
        }
</code></pre>
<pre><code class="language-javascript">        obj.objFun.call(another,&quot;河北&quot;,&quot;山西&quot;)    	//老傻X年龄99,来自：河北，去往：山西
        obj.objFun.apply(another,[&quot;河北&quot;,&quot;山西&quot;])   //老傻X年龄99,来自：河北，去往：山西
        obj.objFun.bind(another,&quot;河北&quot;,&quot;山西&quot;)()  	//老傻X年龄99,来自：河北，去往：山西   

		//错误传法
		obj.objFun.call(another,[&quot;河北&quot;,&quot;山西&quot;])    //老傻X年龄99,来自：河北,山西，去往：undefined
		obj.objFun.bind(another,[&quot;河北&quot;,&quot;山西&quot;])()  //老傻X年龄99,来自：河北,山西，去往：undefined   
</code></pre>
<p>从上面代码可以看出，</p>
<p>call()传参的方式和bind()传参的方式是相同的，</p>
<p>而apply传参需要把所有的参数放到一个数组里才可以</p>
<p>总结：<code>call()</code>、<code>apply()</code>和<code>bind()</code>的区别</p>
<ul>
<li>都能改变this的指向</li>
<li>call()/apply() 是<strong>立即调用函数</strong></li>
<li>bind()：绑定完this后，不会立即调用当前函数，而是<strong>将函数返回</strong>，因此后面还需要加（）才能调用</li>
<li>bind()传参和call()一样（单个单个的传）</li>
<li>apply() 传参需要把所有参数放到一个数组里</li>
</ul>
<h1 id="71-es6-的变量声明">7.1 ES6  的变量声明</h1>
<p>ES6中新增了<code>let</code>和<code>const</code>来定义变量：</p>
<ul>
<li><code>var</code>：ES5 和 ES6 中，定义<strong>全局变量</strong>（是varibale的简写）</li>
<li><code>let</code>：定义<strong>局部变量</strong>，替代var</li>
<li><code>const</code>：定义<strong>常量</strong>（定义后，不可修改）</li>
</ul>
<h2 id="var全局变量">var：全局变量</h2>
<p>看以下代码</p>
<pre><code class="language-JavaScript">        {
            var a = 23
        }

        console.log(a);//这里的 a 指的是 区块 里的 a
</code></pre>
<p>运行结果：</p>
<pre><code class="language-javascript">123
</code></pre>
<p>因为a<strong>不是函数中声明</strong>的，只是<strong>在一个区块</strong>中，所以a是<strong>全局</strong>声明</p>
<pre><code class="language-JavaScript">        var a = 1;
        {
            var a = 2;//会覆盖掉前边的a
        }
        
        console.log(a);
</code></pre>
<p>运行结果：</p>
<pre><code>2
</code></pre>
<p><strong>总结：</strong></p>
<p>用 var 定义的全部变量，有时候会污染整个 js 的作用域</p>
<h2 id="let定义局部变量">let：定义局部变量</h2>
<p>看以下代码</p>
<pre><code class="language-js">        var a =111	//全局的
        {
            let a = 123		//局部的
            console.log(a,&quot;内部&quot;);
        }
        console.log(a,&quot;外部&quot;);
</code></pre>
<p>运行结果：</p>
<pre><code class="language-js">123 &quot;内部&quot;
111 &quot;外部&quot;
</code></pre>
<p>下面再看一个代码，如果在</p>
<pre><code class="language-js">        var a =111
        {
            console.log(a);	//报错
            let a = 123
            console.log(a,&quot;内部&quot;);
        }
        console.log(a,&quot;外部&quot;);
</code></pre>
<p>运行结果：</p>
<pre><code>报错！
02let.html:12 Uncaught ReferenceError: Cannot access 'a' before initialization
    at 02let.html:12
</code></pre>
<p>用<code>let</code>声明的变量，只在局部（块级作用域内）起作用</p>
<p><code>let</code>可以防止数据污染。</p>
<p>我们来看下面这个for循环的例子，很经典</p>
<pre><code class="language-html">    &lt;button&gt;按钮1&lt;/button&gt;
    &lt;button&gt;按钮2&lt;/button&gt;
    &lt;button&gt;按钮3&lt;/button&gt;
    &lt;button&gt;按钮4&lt;/button&gt;
    &lt;button&gt;按钮5&lt;/button&gt;
    &lt;button&gt;按钮6&lt;/button&gt;
    &lt;button&gt;按钮7&lt;/button&gt;
    &lt;button&gt;按钮8&lt;/button&gt;
    &lt;button&gt;按钮9&lt;/button&gt;
    &lt;button&gt;按钮10&lt;/button&gt;
    &lt;script&gt;
        var allBtn = document.querySelectorAll(&quot;button&quot;)
        for(var i =1;i&lt;=10;i++){
            allBtn[i-1].onclick = function(){
                console.log(i);
            }
        }
    &lt;/script&gt;
</code></pre>
<p>以上的代码，当点击每个按钮的时候都会显示什么呢，</p>
<p>答案是：点击每个按钮显示11。因为onclick是异步操作，执行onclick函数的时候for循环已经执行完毕了，这个时候i=11，所以每个按钮点击的时候都会显示11</p>
<p>要想完成点击每个按钮返回相应的下标的话有以下几种方法：</p>
<p><strong>方法1.闭包</strong></p>
<p><strong>闭包内的参数和变量不会被垃圾回收机制回收</strong></p>
<pre><code class="language-JavaScript">        var allBtn = document.querySelectorAll(&quot;button&quot;)
        for (var i = 1; i &lt;= 10; i++) {
            allBtn[i - 1].onclick = (function (index) {
                return function () {
                    console.log(index);
                }
            })(i)
        }
</code></pre>
<p><strong>方法2：let</strong></p>
<pre><code class="language-js">        var allBtn = document.querySelectorAll(&quot;button&quot;)
        for(let i =1;i&lt;=10;i++){
            allBtn[i - 1].onclick = function(){
                console.log(i);
            }
        }
</code></pre>
<p>方法2仅需要把 var 改为 let 即可</p>
<p><strong>总结：<strong>我们要习惯用 let 声明，减少var声明带来的</strong>污染全局空间</strong>。</p>
<p>为了进一步说明 let 不会带来污染，需要说明的是：</p>
<p>当定义了<code>let a =1</code>时，如果在同一作用域内继续定义<code>let a = 2</code>，是会报错的</p>
<pre><code class="language-js">        {
            let a = 2
            let a = 3 //报错
        }
</code></pre>
<h2 id="const定义常量">const：定义常量</h2>
<p><strong>const 声明的变量被改变后会报错</strong></p>
<p>在程序开发中，有些变量是希望声明后，在业务层就不再发生变化，此时就可以用const来定义</p>
<p>比如说你们喜欢用的探探，在使用探探时，一旦选定性别，系统就不允许再改变，这个时候就可以用<code>const</code>来定义</p>
<pre><code class="language-js">        const GENDER = 0;   //在定义常量的时候最好使用大写字母，方便识别

        GENDER = 1      //报错

        console.log(GENDER);
</code></pre>
<p>用const声明的变量，只在<strong>局部</strong>（块级作用域内）起作用</p>
<h2 id="let-和-const-的作用重要">let 和 const 的作用【重要】</h2>
<p>let 和 const 的特点如下</p>
<ul>
<li>禁止重复声明</li>
<li>支持块级作用域（只在局部中起作用）</li>
<li>const被限制修改</li>
</ul>
<p>相反，用<code>var</code> 声明的变量：可以重复声明、没有块级作用域、不能限制</p>
<h1 id="81变量的解构赋值">8.1变量的解构赋值</h1>
<p>ES6允许我们，通过数组或者对象的方式，<strong>对一组变量进行赋值</strong>，这被成为解构。</p>
<p>解构赋值在实际开发中可以大量减少我们的代码量，并且让程序结构更清晰。</p>
<h2 id="数组的解构赋值">数组的解构赋值</h2>
<p><strong>举例：</strong></p>
<p>通常情况下，我们在为一组变量赋值时，一般是这样写：</p>
<pre><code class="language-js">let a = 0;
let b = 1;
let c = 2 ;
</code></pre>
<p>现在我们可以通过<strong>数组解构</strong>的方式进行赋值</p>
<pre><code>let [a,b,c] = [1, 2, 3]
</code></pre>
<p>拓展：</p>
<pre><code>        let [a1,b1,c1] = [1,2,3]
        console.log(a1,b1,c1);  //1 2 3

        let [a2,b2,c2] = [1,2]
        console.log(a2,b2,c2);  //1 2 undefined

        let [a3,b3,c3] = [1,,3]
        console.log(a3,b3,c3);  //1 undefined 3

        let [a4,b4,c4] = []
        console.log(a4,b4,c4);  //undefined undefined undefined

</code></pre>
<p><strong>解构的默认值：</strong></p>
<p>在解构赋值时，是允许使用默认值的。举例如下：</p>
<pre><code class="language-js">        let [a2,b2,c2 = 8] = [1,2]  //c2默认是 8 ,如果右边有值会覆盖，没值会使用默认值
        console.log(a2,b2,c2);  //1 2 8
</code></pre>
<h2 id="对象的解构赋值">对象的解构赋值</h2>
<p>首先我们看一看以前的代码</p>
<pre><code class="language-js">        let user = {
            name: &quot;蔡徐坤&quot;,
            type: &quot;NBA形象大使&quot;,
            like: &quot;篮球&quot;
        }

        //一个一个赋值，太麻烦
        let name = user.name;
        let type = user.type;
        let like = user.like


        console.log(name,type,like);
</code></pre>
<p>再看看对象的解构赋值：</p>
<pre><code class="language-js">        let user = {
            name: &quot;蔡徐坤&quot;,
            type: &quot;NBA形象大使&quot;,
            like: &quot;篮球&quot;
        }
        let {name,type,like} = user //变量名要和对象的属性名一致
        console.log(name,type,like);    //蔡徐坤 NBA形象大使 篮球
</code></pre>
<p>上方的代码可以看出，对象的解构和数组的解构，有一个重要的区别：</p>
<p>数组的元素是按次序排列的，变量的取值由它的位置决定；</p>
<p>而对象的属性没有次序，是根据键来取值的</p>
<h2 id="字符串解构">字符串解构</h2>
<pre><code class="language-js">        var str = &quot;helloWorld&quot;
        var [a,b,c,d,e,f] = str
        console.log(a,b,c,d,e,f);   //h e l l o W
</code></pre>
<h1 id="9-forof循环">9 for...of循环</h1>
<h2 id="数组的遍历">数组的遍历</h2>
<p>ES6中，如果我们要遍历一个数组，可以这样做：</p>
<pre><code class="language-js">    let arr = [1,2,3,4,5];

    for(let value of arr){
        console.log(value);
    }
</code></pre>
<p>输出结果：</p>
<pre><code>1
2
3
4
5
</code></pre>
<p>for...of 的循环可以避免我们开拓内存空间，增加代码运行效率，所以建议大家在以后的工作中使用for...of循环</p>
<p>注意，上面的数组，<code>for...of</code>获取的是数组里面的值，而<code>for...in</code>获取的是index索引值</p>
<h2 id="map对象的遍历">map对象的遍历</h2>
<pre><code class="language-js">    let a = new Map()
    a.set(&quot;username&quot;,&quot;admin&quot;)
    a.set(&quot;password&quot;,&quot;123456&quot;)

    for(let i of a){
        console.log(i);
    }
</code></pre>
<p>输出内容：</p>
<pre><code class="language-js">[&quot;username&quot;, &quot;admin&quot;]
[&quot;password&quot;, &quot;123456&quot;]
</code></pre>
<p>如果我们想获取单个的key和value，就可以使用我们上一个知识点：<strong>数组的解构赋值</strong></p>
<pre><code class="language-js">    let a = new Map()
    a.set(&quot;username&quot;,&quot;admin&quot;)
    a.set(&quot;password&quot;,&quot;123456&quot;)
    console.log(a);

	
    for(let [key,value] of a){
        console.log(key+&quot;--------&quot;+value);
    }
</code></pre>
<p>输出内容：</p>
<pre><code class="language-js">username--------admin
password--------123456
</code></pre>
<h1 id="10-模板字符串">10 模板字符串</h1>
<p>我们以前让字符串进行拼接的时候，是这样做的：（传统写法的字符拼接）</p>
<pre><code class="language-js">        let name = &quot;张三&quot;
        let age = 44
        console.log(&quot;我的名字是&quot;+name+&quot;,我今年&quot;+age+&quot;岁了。&quot;);
</code></pre>
<p>ES6的语法，字符串拼接可以这样写</p>
<pre><code class="language-js">        let name = &quot;张三&quot;
        let age = 44
        console.log(&quot;我的名字是&quot;+name+&quot;,我今年&quot;+age+&quot;岁了。&quot;);
        console.log(`我的名字是${name},我今年${age}岁了`);  //ES6字符串拼接

        // `${}`不仅可以用来进行字符串拼接，还可以用来进行运算等操作
</code></pre>
<p><strong>注意:</strong><code>${}</code>需要和``(键盘Esc下面的那个键)一起使用</p>
<p><code>${}</code>不仅可以<strong>拼接字符串</strong>，还可以进行<strong>数学运算</strong>和<strong>函数调用</strong></p>
<pre><code class="language-js">        let price = 10
        let num =50

        console.log(`总价是${price*num}`);			//总价是500

        // 调用函数
        function content(){
            return &quot;啦啦啦德玛西亚~&quot;
        }
        console.log(`歌词是：${content()}`);		//歌词是：啦啦啦德玛西亚~
</code></pre>
<h1 id="11-es6函数扩展">11 ES6函数扩展</h1>
<h2 id="箭头函数-通常把一个函数作为另外一个函数的参数的时候使用">箭头函数----通常把一个函数作为另外一个函数的参数的时候使用</h2>
<p><strong><mark>箭头函数中的this，引用的就是最近作用域中的this</mark></strong></p>
<p>向外层作用域中一层层查找this直到有this的定义</p>
<p>定义和调用函数：（传统写法）</p>
<pre><code class="language-js">        function fn1(a,b){
            return a + b
        }
        console.log(fn1(1,2));   //输出结果：3
</code></pre>
<p>定义和调用函数：（ES6的写法）</p>
<pre><code class="language-js">        let fn2 = (a,b) =&gt; a + b

        console.log(fn2(1,2));   //输出结果：3
</code></pre>
<p>二者效果是一样的。</p>
<p>在箭头函数中，如果方法体内有两句话或者以上的话，那就需要在方法体外边加上<code>{}</code>括号。如下：</p>
<pre><code class="language-js">        let fn3 = (a,b) =&gt;{
            let c = a+b
            return c
        }
        console.log(fn3(1,2));	  //输出结果：3
</code></pre>
<p>从上面的箭头函数中，我们可以很清晰的找到函数名、参数名、方法体。</p>
<p>箭头函数还有一个很重要的点是<strong>this指向问题</strong></p>
<p>举个例子：</p>
<p>现在我们创建一个div，点击div以后每隔1秒之后变色</p>
<p>css:</p>
<pre><code>        #d1{
            width: 200px;
            height: 200px;
            background-color: pink;
        }
</code></pre>
<p>html:</p>
<pre><code class="language-html">    &lt;!-- 点击div，使得div每隔1秒钟改变颜色 --&gt;
    &lt;div id = &quot;d1&quot;&gt;&lt;/div&gt;
</code></pre>
<p>js:</p>
<pre><code class="language-js">        let div = document.querySelector(&quot;#d1&quot;)
        div.onclick = function(){
            setInterval(function(){
                let r = Math.random()*255;	//随机颜色
                let g = Math.random()*255;	//随机颜色
                let b = Math.random()*255;	//随机颜色
                this.style.backgroundColor = `rgb(${r},${g},${b})`	//原本这里的this是指向window的，所以我们在后面添加了.bind(this)，把当前函数的外嵌函数的this传了过来，用来改变this指向，操作完成后this指向的便是div了
            }.bind(this), 1000);//改变this指向
        }
</code></pre>
<p>还有一种方法就是利用我们新学的箭头函数</p>
<pre><code class="language-js">        div.onclick = function(){
            console.log(this,&quot;outer&quot;);
            setInterval(()=&gt;{	//此时this = 它的外嵌方法的this
                let r = Math.random()*255;
                let g = Math.random()*255;
                let b = Math.random()*255;
                this.style.backgroundColor = `rgb(${r},${g},${b})`//此时this = 它的外嵌方法的this
            },1000)
        }
</code></pre>
<p>有一个辨别this指向谁技巧就是，看当前箭头函数的<strong>上一行</strong>，它的this是谁，该箭头函数的this就是谁</p>
<h2 id="默认参数">默认参数</h2>
<p>要求：假如一个函数有两个形参，但是在调用的时候没有传入参数，这时候函数给自己设置一个默认值，应该怎么操作</p>
<p>以前的代码：</p>
<pre><code class="language-js">        function fn(a,b){
            a = a?a:1
            b = b?b:1
            return a+b
        }

        console.log(fn());  //2
</code></pre>
<p>ES6中：</p>
<pre><code class="language-js">		//在未传参的情况下,a默认是1，b默认是1
		function fn(a=1,b=1){
            return a+b
        }

        console.log(fn());  //2
</code></pre>
<p>拓展：</p>
<pre><code class="language-js">        var a = 3
        //在未传参的情况下,a默认是4，b默认是a,也就相当于是4，因为要使用function中的局部变量
        function fn2(a=4,b=a){
            console.log(a,&quot;a&quot;); //4
            console.log(b,&quot;b&quot;); //4
            return a+b
        }

        console.log(fn2());  //8
</code></pre>
<h2 id="扩展运算符">扩展运算符</h2>
<p>注意区分：</p>
<ul>
<li>扩展运算符格式为<code>...</code></li>
<li>rest运算符为<code>...变量名</code></li>
</ul>
<p><strong>使用场景1：</strong></p>
<p><strong>复制数组</strong></p>
<pre><code class="language-js">        var arr = [&quot;小明&quot;,&quot;小铭&quot;,&quot;小澎&quot;,&quot;小鹏&quot;]

        // 扩展运算符复制数组
        var arr1 =[...arr]

        console.log(arr,&quot;arr&quot;);		//[&quot;小明&quot;, &quot;小铭&quot;, &quot;小澎&quot;, &quot;小鹏&quot;] &quot;arr&quot;
        console.log(arr1,&quot;arr1&quot;);	//[&quot;小明&quot;, &quot;小铭&quot;, &quot;小澎&quot;, &quot;小鹏&quot;] &quot;arr1&quot;

		//两个数组的地址不一样
        console.log(arr==arr1);		//false
</code></pre>
<p>拓展：</p>
<pre><code class="language-js">		var arr = [&quot;小明&quot;,&quot;小铭&quot;,&quot;小澎&quot;,&quot;小鹏&quot;]
        var arr2 = arr
        arr2.push(&quot;小二&quot;)
        console.log(arr);
        console.log(arr2);
</code></pre>
<p>运行结果：</p>
<pre><code class="language-js">[&quot;小明&quot;, &quot;小铭&quot;, &quot;小澎&quot;, &quot;小鹏&quot;, &quot;小二&quot;]
[&quot;小明&quot;, &quot;小铭&quot;, &quot;小澎&quot;, &quot;小鹏&quot;, &quot;小二&quot;]
</code></pre>
<p>造成这样的运行结果是因为上方代码 <code>var arr2 = arr</code>，是直接让arr2指向arr的地址，也就是说arr2和arr指向的是同一地址，只要其中一个操作改变，那么两个都会改变。</p>
<p>要想改变这种状况就可以使用我们的<code>...</code>,也就是<strong>复制数组</strong>部分的代码</p>
<p><strong>注意：</strong><code>...</code>不是深拷贝，<code>...</code>只能拷贝一层，如果是第二层或者以上的话依然是引用指针</p>
<p><strong>使用场景2：</strong></p>
<p><strong>遍历传参</strong></p>
<pre><code class="language-js">//		...也支持传参
        var arr = [&quot;小明&quot;,&quot;小铭&quot;,&quot;小澎&quot;,&quot;小鹏&quot;]
        function fn1(a,b,c,d){
            console.log(a);
            console.log(b);
            console.log(c);
            console.log(d);
        }

        fn1(...arr)	//等同于fn1(arr[0],arr[1],..........,arr[arr.length-1])
</code></pre>
<p>运行结果：</p>
<pre><code class="language-js">小明
小铭
小澎
小鹏
</code></pre>
<h2 id="rest运算符"><code>rest</code>运算符</h2>
<p><code>rest</code>在英文中指的是<strong>剩余部分</strong>。我们举个例子，理解剩余部分的含义：</p>
<pre><code class="language-js">        function fn(first,seconde,...arg){
            console.log(first);
            console.log(seconde);

            console.log(arg);
            console.log(arg.length);
            // console.log(arguments);
        }

        fn(0,1,2,3,4,5,6);
</code></pre>
<p>运行结果：</p>
<pre><code>0
1
[2, 3, 4, 5, 6]
5
</code></pre>
<p><strong>不确定参数的函数</strong></p>
<p>当我们想定义一个方法，但是不确定其参数的个数时，我们也可以用<strong>rest运算符</strong>作为参数。</p>
<pre><code class="language-js">//		以前的参数需要确定个数，以下程序会报错
		function fn(a,b,c){
            console.log(a);
            console.log(b);
            console.log(c);
            console.log(d); //报错:  d is not defined
        }       
        fn(1,2,3)



//		现在有了扩展运算符，就不用担心报错的问题了。代码可以这样写
        function fn2(...arg){   //当不确定方法的参数时，可以使用扩展运算符,这里的“arg”是随便起的
            console.log(arg[0],&quot;arg[0]&quot;);
            console.log(arg[1],&quot;arg[1]&quot;);
            console.log(arg[2],&quot;arg[2]&quot;);
            console.log(arg[3],&quot;arg[3]&quot;);
        }

        fn(1,2,3)   //方法中定义了四个参数，但只引用了三个参数，ES6中并不会报错
</code></pre>
<p>第二个方法的运行结果：</p>
<pre><code class="language-js">1 &quot;arg[0]&quot;
2 &quot;arg[1]&quot;
3 &quot;arg[2]&quot;
undefined &quot;arg[3]&quot;
</code></pre>
<p>谈到<code>...</code>我们顺便说一下<code>arguments</code></p>
<h2 id="arguments">arguments</h2>
<p><strong>一、功能</strong></p>
<p><strong>每一个函数，即使你什么参数都没有传，里面也会有一个<code>arguments</code></strong></p>
<p>我们来看一下</p>
<pre><code class="language-js">        function fn1 (){
            console.log(arguments);
        }

        fn1()
</code></pre>
<p>运行结果：（先只看length）</p>
<figure data-type="image" tabindex="8"><img src="C:%5CUsers%5CMaMing%5CDesktop%5Cdemo%5CES6~ES11%5C01README.assets%5Cimage-20200921152825151.png" alt="image-20200921152825151" loading="lazy"></figure>
<p>在没有传递任何参数的时候，arguments的length为0，或许我们已经猜到Arguments的作用是什么了。</p>
<p>没错，<strong>arguments是用来记录当前函数传递的实参的</strong></p>
<p>我们再来看一个例子：</p>
<pre><code class="language-js">        function fn2 (a){
            console.log(a);
            console.log(arguments);
            console.log(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);
            
        }

        fn2(1,2,3,4,5)
</code></pre>
<p>函数<code>fn2</code>才设置了一个形参a，但是我们传递了五个参数。</p>
<p>这时候我不止想获取到a，我还想把其他四个参数获取到，就可以用到<code>arguments</code>.</p>
<p>运行结果：</p>
<figure data-type="image" tabindex="9"><img src="C:%5CUsers%5CMaMing%5CDesktop%5Cdemo%5CES6~ES11%5C01README.assets%5Cimage-20200921155347879.png" alt="image-20200921155347879" loading="lazy"></figure>
<p>我们可以看到，arguments像一个数组一样把所有的参数都保存了下来，</p>
<p>然而arguments并不是一个数组，<strong>arguments是一个类似数组（类数组）</strong></p>
<br>
<br>
<br>
<p><strong>二、属性</strong></p>
<p>现在我们知道了arguments的功能，接下来我们看一下它的属性</p>
<p><code>callee</code></p>
<p><strong>callee是一个方法，而且这个方法就是我们定义的这个方法</strong></p>
<p>为了方便阅读，我们写如下代码：</p>
<pre><code class="language-js">        function fn2 (a){      
            // 我调我自己
            fn2(1)
        }

        fn2(1,2,3,4,5)
</code></pre>
<p>以上代码同等于：</p>
<pre><code class="language-js">        function fn2 (a){
            // 我调我自己
            callee(1)
        }

        fn2(1,2,3,4,5)
</code></pre>
<p>注：以上两个程序会陷入死循环，但是为了简洁阅读我就没有添加多余的条件。</p>
<p>当使用<strong>arguments</strong>进行函数传递时，有一些需要注意的点。例子如下：</p>
<pre><code class="language-js">var length = 10;
function fn() {
  console.log(this.length);
}

var obj = { 
  method: function(fn) {
    fn();
    arguments[0]();
  }
};

obj.method(fn, 1); 
</code></pre>
<p>运行结果：</p>
<pre><code class="language-js">10
2
</code></pre>
<p>这里有2个需要注意的点。fn函数里面的this的指向：</p>
<p>1.第一个值为10，执行的是method里面的第一行<code>fn()</code>,这里this指向的window。所以输出的值为最外层定义的length。</p>
<p>2.第二个值为2，执行的是method里面的第二行<code>arguments[0]()</code>（arguments[0]() =&gt; fn() ），<strong>这里this执行的是arguments这个对象</strong>,所以输出值为<code>arguments</code>的长度</p>
<p>....<strong>Symbol类型的键</strong>暂未揭晓</p>
<h1 id="12-新增基本数据类型">12 新增基本数据类型</h1>
<p>我们先来复习一下js的所有<strong>数据类型：</strong></p>
<p>ES5中的数据类型：Number、Boolean、String、undefined、null、Object</p>
<p>其中，基本数据类型为：Number、String、Boolean、undefined、null</p>
<p>ES6中新增了一个基本数据类型——Symbol类型，是<strong>独一无二的值</strong></p>
<p>Symbol 类型的对象<strong>永远不相等，即便创建的时候传入相同的值</strong>。</p>
<pre><code class="language-js">        let s = Symbol(&quot;asd&quot;)
        let s2 = Symbol(&quot;asd&quot;)
        console.log(s===s2);    //false
        console.log(s==s2);    //false

		console.log(s);			//Symbol(asd)
		console.log(typeof s);	//symbol
</code></pre>
<p>运行结果：</p>
<pre><code>false
false
Symbol(asd)
symbol
</code></pre>
<p><strong>注意</strong>，<strong><code>Symbol</code>函数前不能使用<code>new</code>命令</strong>，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p>
<h1 id="13-promise">13 Promise</h1>
<h2 id="概述">概述：</h2>
<p>内部代码：</p>
<pre><code class="language-js">class MPromise {
            constructor(fn) {
                this.successList = []
                this.failList = []
                // pending ,fullfilled,rejected
                this.state =&quot;pending&quot;
                fn(this.resolveFn.bind(this),this.rejectFn.bind(this))
            }
            then(successFn, failFn) {
                if (typeof successFn == &quot;function&quot;) {
                    this.successList.push(successFn)
                }
                if (typeof failFn == &quot;function&quot;) {
                    this.failList.push(failFn)
                }
            }
            catch(failFn) {
                if (typeof failFn == &quot;function&quot;) {
                    this.failList.push(failFn)
                }
            }
            resolveFn(res){
                this.state =&quot;fullfilled&quot;
                this.successList.forEach(function(item,index){
                    // 将成功的实践循环调用
                    item(res)
                })
            }
            rejectFn(res){
                this.state =&quot;reject&quot;

                // 注册到的失败所有事件进行调用
                this.failList.forEach(function(item,index){
                    item(res)
                })

            }
        }


        var p1 = new MPromise(function (resolve, reject) {
            setTimeout(function () {
                if (true) {
                    resolve(&quot;成功&quot;)
                } else {
                    reject(&quot;失败&quot;)
                }
            }, 1000)
        })

        p1.then(function (res) {
            console.log(&quot;成功啦！1&quot;);
        })
        p1.then(function (res) {
            console.log(&quot;成功啦！2&quot;);
        })

        p1.catch(function () {
            console.log(&quot;失败了┭┮﹏┭┮&quot;);
        })
</code></pre>
<h1 id="14-async-await">14 async await</h1>
<p>先从字面意思来理解，async是“异步”的意思，而 await是等待的意思。所以应该很好理解async用于声明一个异步的function（实际上是async function 对象），而await用于等待一个异步任务执行完成的结果。</p>
<p>并且await 只能出现在async函数中</p>
<pre><code class="language-js">        var fnPromise1 = function () {
            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    // resolve会传给下方的await调用函数
                    resolve(&quot;0.5s输出&quot;)
                }, 500)
            })
        }
        var fnPromise2 = function () {
            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    // resolve会传给下方的await调用函数
                    resolve(&quot;1.5秒输出&quot;)
                }, 1500)
            })
        }
        var fnPromise3 = function () {
            return new Promise(function (resolve, reject) {
                // 下方可以用try...catch捕捉
                reject(&quot;失败了&quot;)
            })
        }


        async function demo() {
            // 一层层等待
            var result1 = await fnPromise1()
            // 执行完第一个之后才能执行下一个
            var result2 = await fnPromise2()
            console.log(result1);
            console.log(result2);
            try {
                var result3 = await fnPromise3()

            } catch (e) {
                console.log(e);
            }

        }

        demo()



        // var p1 = fnPromise()
        // p1.then(res=&gt;{
        //     console.log(res);
        // })
</code></pre>
<h1 id="15-迭代器iterator与生成器generator">15 迭代器（Iterator）与生成器（Generator）</h1>
<h2 id="迭代器">迭代器</h2>
<p>迭代器是什么？</p>
<p><strong>迭代器是一种特殊对象，每个迭代器对象都有一个next()，该方法返回一个对象，包括value和done属性</strong></p>
<p><strong>ES5实现迭代器代码如下</strong></p>
<pre><code class="language-js">        var arr = [0, 1, 1, 2, 3, 6, 9, 15, 24]
        //实现一个返回迭代器的对象的函数，注意该函数不是迭代器，返回的结果才叫迭代器。
        function createIterator(count) {
            var num = 0
            return {
                pre1: 0,
                pre2: 0,
                next: function () {
                    if(num&gt;count){
                        return{
                            done:true,
                            value:undefined
                        }
                    }
                    if (num == 0||num == 1) {
                        num++
                        return {
                            // done代表事情做完没有
                            done: false,
                            value: num
                        }
                    }else{
                        num++
                        // console.log(num,&quot;num&quot;);
                        // console.log(this.pre1,&quot;pre1&quot;);
                        // console.log(this.pre2,&quot;pre2&quot;);
                        result = this.pre1+this.pre2
                        this.pre2 = this.pre1
                        this.pre1 = result
                        return{
                            done: false,
                            value: result
                        }
                    }
                    num++
                }
            }

        }

        var user = new Map()
        user.set(&quot;username&quot;,&quot;小明&quot;)
        user.set(&quot;password&quot;,&quot;123456&quot;)
        user.set(&quot;age&quot;,&quot;20&quot;)
        console.log(user);
        // user 可迭代，因为他有user.entries()方法
        // user.entries()方法里面就有next()方法
        var userIterator =user.entries()
        console.log(userIterator.next());

        for(let s of userIterator){
            console.log(s,&quot;of userIterator&quot;);
        }

        var a = createIterator();
        for(let value of a){
            // 如果只有next，不是一个正宗的迭代器
            console.log(value,&quot;a&quot;);
        }
</code></pre>
<h2 id="生成器">生成器</h2>
<p><strong>生成器是函数：用来返回迭代器</strong></p>
<p>这个概念有2个关键点，一个是函数、一个是返回迭代器。这个函数不是上面ES5中创建迭代器的函数，而是ES6中特有的，一个带有*（星号）的函数，同时也需要使用到yield</p>
<p>yield关键字有个神奇的功能，就是当你执行一次next(),那么只会执行一个yield后面的内容，然后语句终止运行</p>
<pre><code class="language-js"> // 函数名字前面加*，yield
        function* easy() {
            yield 1
            yield 2
            yield 3
            yield 4
        }
        // 创建方法的时候并不运行，当执行.next()的时候执行，且每next一次，执行一次yield，从后中断
        let easyAIterator = easy()
        // 该方法的原型有Generator方法，其中有next()方法
        console.log(easyAIterator);

        for (let i of easyAIterator) {
            console.log(i);

        }


	//增加以下难度
        function* difficult(count) {
            let num = 0
            let pre1 = 0
            let pre2 = 0
            if (num == 0) {
                pre1 = 1
                num++
                // yield {
                //     // yield默认的done为false，所有不必添加done
                //     done: false,
                //     value: num
                // }
                yield num
            }
            while (true) {
                num++
                let result = pre1 + pre2
                pre2 = pre1
                pre1 = result
                yield result

                if (num &gt;= count) {
                    // 如果没有yield，直接break，*difficult没有返回值，就自动停止了
                    break
                }
            }





        }

        var diffAIterator = difficult(5)
        for(let i of diffAIterator){
            console.log(i,&quot;diffAIterator&quot;)
        }
        console.log(diffAIterator);
</code></pre>
<p>迭代器的应用</p>
<pre><code class="language-js"> /* 调用生成器的对象叫迭代器 */
        var priceAll = [100, 99, 6, 46, 4, 9465, 12, 3, 46, 4, 89, 489, 12, 654, 654,]
        
        function* priceGenerator(priceAll) {
            for(let i =0;i&lt;priceAll.length;i++){
                let result = &quot;$&quot;+priceAll[i]
                yield result
            }
        }

        var priceAIterator =priceGenerator(priceAll)
        console.log(priceAIterator); 

        for(let i of priceAIterator){
            console.log(i);
        }

</code></pre>
<h2 id="创建可迭代对象">创建可迭代对象</h2>
<p><strong>在ES6中，数组、Set、Map、字符串都是可迭代对象。</strong></p>
<p><strong>默认情况下定义的对象（object）是不可迭代的，但是可以通过Symbol.iterator创建迭代器</strong></p>
<pre><code class="language-js">        // 数组是支持迭代的
		var a = [&quot;小明&quot;, &quot;小青&quot;, &quot;小宋&quot;, &quot;小马&quot;, &quot;小明&quot;]

        for (value of a) {
            console.log(value);
        }
        console.log(&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;);

        // Set可迭代。Set类似数组,但成员的值是唯一的（不可重复）,没有顺序
        var s = new Set(a)
        console.log(s);

        for (let value of s) {
            console.log(value);
        }

        console.log(&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;);
        // 字符串也可迭代
        var b = &quot;helloWorld&quot;
        console.log(b);
        for (let value of b) {
            console.log(value);
        }

        console.log(&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;);
        // Map对象也可迭代
        var user = new Map()
        user.set(&quot;name&quot;, &quot;小明&quot;)
        user.set(&quot;age&quot;, 18)
        user.set(&quot;gender&quot;, &quot;男&quot;)
        user.set(&quot;hobby&quot;, &quot;run&quot;)
        console.log(user);

        for (let [key, value] of user) {
            console.log(key, value);
        }


        // 但是Object对象不可迭代
        var student = {
            &quot;name&quot;: &quot;小黑&quot;,
            &quot;age&quot;: 18
        }
        // for (const value of student) {// 报错student is not iterable
        //     // console.log(value); 
        //     // 如果有Symbol.iterator函数则可以迭代
        // }
       	console.log(&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;);

        // 现在想让Object迭代可以这样做
        let student2 = {
            &quot;name&quot;: &quot;罗小黑&quot;,
            &quot;age&quot;: 18,
            &quot;gender&quot;: &quot;男&quot;,

            // *[Symbol.iterator]此方法可以帮助我们将任意的对象编程可迭代对象
            *[Symbol.iterator]() {
                for(let key in this){
                    yield [key,this[key]];
                }
                
            }
        }
        console.log(student2);

        for (const value of student2) {
            console.log(value);
        }

</code></pre>
<p>运行结果：</p>
<pre><code class="language-js">小明
小青
小宋
小马
小明
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Set(4) {&quot;小明&quot;, &quot;小青&quot;, &quot;小宋&quot;, &quot;小马&quot;}
小明
小青
小宋
小马
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
helloWorld
h
e
l
l
o
W
o
r
l
d
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Map(4) {&quot;name&quot; =&gt; &quot;小明&quot;, &quot;age&quot; =&gt; 18, &quot;gender&quot; =&gt; &quot;男&quot;, &quot;hobby&quot; =&gt; &quot;run&quot;}
name 小明
age 18
gender 男
hobby run
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
{name: &quot;罗小黑&quot;, age: 18, gender: &quot;男&quot;, Symbol(Symbol.iterator): ƒ}
 [&quot;name&quot;, &quot;罗小黑&quot;]
 [&quot;age&quot;, 18]
 [&quot;gender&quot;, &quot;男&quot;]
</code></pre>
<h3 id="内建迭代器">内建迭代器</h3>
<p>上面提到了，数组、Set、Mat都是可迭代对象，即它们内部实现了迭代器，并且提供了3种迭代器函数调用。</p>
<p><strong>1、entries()返回迭代器</strong>：返回键值对</p>
<pre><code class="language-js">        //数组
		var a = [&quot;小明&quot;, &quot;小青&quot;, &quot;小宋&quot;, &quot;小马&quot;, &quot;小明&quot;]
        let A = a.entries()
        console.log(A);
        for ([key,value] of A) {
            console.log(key,value);
        }
        console.log(&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;);

		//Set
		var s = new Set([&quot;小明&quot;, &quot;小青&quot;, &quot;小宋&quot;, &quot;小马&quot;, &quot;小明&quot;])
        console.log(s);
        for (let v of s.entries()) {
            console.log(v);
        }
        console.log(&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;);


		//Map
		var user = new Map()
        user.set(&quot;name&quot;, &quot;小明&quot;)
        user.set(&quot;age&quot;, 18)
        user.set(&quot;gender&quot;, &quot;男&quot;)
        user.set(&quot;hobby&quot;, &quot;run&quot;)
        for (let v of user.entries()) {
            console.log(v);
        }
</code></pre>
<p>运行结果：</p>
<pre><code> Array Iterator {}
 	__proto__: Array Iterator
 0 &quot;小明&quot;
 1 &quot;小青&quot;
 2 &quot;小宋&quot;
 3 &quot;小马&quot;
 4 &quot;小明&quot;
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Set(4) {&quot;小明&quot;, &quot;小青&quot;, &quot;小宋&quot;, &quot;小马&quot;}
 (2) [&quot;小明&quot;, &quot;小明&quot;]
 (2) [&quot;小青&quot;, &quot;小青&quot;]
 (2) [&quot;小宋&quot;, &quot;小宋&quot;]
 (2) [&quot;小马&quot;, &quot;小马&quot;]
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 (2) [&quot;name&quot;, &quot;小明&quot;]
 (2) [&quot;age&quot;, 18]
 (2) [&quot;gender&quot;, &quot;男&quot;]
 (2) [&quot;hobby&quot;, &quot;run&quot;]
</code></pre>
<p>**values()返回迭代器：**返回键值对的value</p>
<pre><code class="language-js">        //数组
		var a = ['a','b','c']
        for (let v of a.values()) {
            console.log(v);
        }
		//'a' 'b' 'c'


		//Set
		var s = new Set(['a','b','c'])
        for (let v of s.values()) {
            console.log(v);
        }
		//'a' 'b' 'c'


		//Map
		var user = new Map()
        user.set(&quot;a&quot;, &quot;a&quot;)
        user.set(&quot;b&quot;, &quot;b&quot;)
        for (let v of user.values()) {
            console.log(v);
        }
		//	&quot;a&quot; &quot;b&quot;

</code></pre>
<p><strong>3、keys返回迭代器</strong>：返回键值对的key</p>
<pre><code class="language-js">        //数组
        var a = ['a','b','c']
        for (let v of a.keys()) {
            console.log(v);
        }
        //0 1 2


        //Set
        var s = new Set(['a','b','c'])
        for (let v of s.keys()) {
            console.log(v);
        }
        //'a' 'b' 'c'


        //Map
        var user = new Map()
        user.set(&quot;a&quot;, &quot;a&quot;)
        user.set(&quot;b&quot;, &quot;b&quot;)
        for (let v of user.keys()) {
            console.log(v);
        }
        //	&quot;a&quot; &quot;b&quot;

</code></pre>
<h3 id="nodelist-迭代器">NodeList 迭代器</h3>
<p>迭代器真是无处不在，dom节点的迭代器来尝试下吧</p>
<pre><code class="language-html">    &lt;div&gt;内容1&lt;/div&gt;
    &lt;div&gt;内容2&lt;/div&gt;
    &lt;div&gt;内容3&lt;/div&gt;
    &lt;div&gt;内容4&lt;/div&gt;
    &lt;div&gt;内容5&lt;/div&gt;
    &lt;div&gt;内容6&lt;/div&gt;
    &lt;div&gt;内容7&lt;/div&gt;
    &lt;div&gt;内容8&lt;/div&gt;
    &lt;script&gt;
        var divs =document.querySelectorAll(&quot;div&quot;)
        var h3s =document.getElementsByTagName(&quot;h3&quot;)
        /* querySelectorAll和getElementsByTagName输出来的不相同
        querySelectorAll获取到的是NodeList
        getElementsByTagName是HTMLCollection
         */
        console.log(divs);
        console.log(h3s);
        for(let value of divs){
            console.log(value,&quot;divs&quot;);
        }

        for(let value of h3s){
            console.log(value,&quot;h3s&quot;);
        }

    &lt;/script&gt;
</code></pre>
<p>打印结果：</p>
<figure data-type="image" tabindex="10"><img src="C:%5CUsers%5CMaMing%5CDesktop%5Cdemo%5CES6~ES11%5C01README.assets%5Cimage-20200924165418693.png" alt="image-20200924165418693" loading="lazy"></figure>
<h3 id="展开运算符与迭代器">展开运算符与迭代器</h3>
<pre><code class="language-js">        var a =[1,2,3]
        var b =[4,5,6]
        // 展开运算符
        var c =[...a,...b]
        console.log(c);

        // 同样适用到迭代对象上
        function *abc(){
            yield 1
            yield 5
            yield 10
        }
        var tt = abc()
        var e =[...tt]
        console.log(e);
</code></pre>
<p>输出结果：</p>
<pre><code class="language-js">[1, 2, 3, 4, 5, 6]
[1, 5, 10]
</code></pre>
<h3 id="高级迭代器功能">高级迭代器功能</h3>
<p>迭代器的高级功能，</p>
<p>传参、抛出异常、生成器返回语句、委托生成器</p>
<p><strong>1、传参</strong></p>
<p>生成器里面有2个yield，当执行第一个next()的时候，返回value为1，然后给第二个next()传入参数10，传递的参数会替代掉上一个next()的yield返回值。下面例子中就是first</p>
<pre><code class="language-js">        function* createIterator() {
            let first = yield 1
            yield  first + 2
        }
        let i = createIterator();
        console.log(i.next());	//	{value: 1, done: false}
        console.log(i.next(10));	//{value: 12, done: false}

</code></pre>
<p><strong>2、在迭代器中抛出错误</strong></p>
<pre><code class="language-js">        function* createIterator() {
            let first = yield 1
            yield first + 2
        }
        let i = createIterator();
        console.log(i.next());			//{value: 1, done: false}
        console.log(i.throw(new Error(&quot;我是错误&quot;)));   //Uncaught Error: 我是错误
        console.log(i.next());   //不再执行
</code></pre>
<p><strong>3、生成器返回语句</strong></p>
<p>生成器中添加return表示退出操作</p>
<pre><code class="language-js">        function* createIterator() {
            let first = yield 1
            return	//中断
            yield first + 2
        }

        let i = createIterator();
        console.log(i.next());  //{value: 1, done: false}
        console.log(i.next());  //{value: undefined, done: true}
</code></pre>
<p><strong>委托生成器</strong></p>
<p>生成器嵌套生成器</p>
<pre><code class="language-js">        var AIterator = function*(){
            yield 1
            yield 2
            yield 3
        }
        var BIterator = function*(){
            yield 4
            yield 5
            yield 6
        }
        
        var CIterator = function*(){
            // 嵌套迭代器，一定不要忘了加*
            yield *AIterator()
            yield *BIterator()
        }
        var c = CIterator()
        for(let value of c){
            console.log(value);
        }
</code></pre>
<p>运行结果：</p>
<pre><code>1
2
3
4
5
6
</code></pre>
<h3 id="异步任务执行器">异步任务执行器</h3>
<p>ES6之前，我们使用异步的操作方式是调用函数并执行回调函数</p>
<p>书上举的例子挺好的，在nodejs中，有一个读取文件的操作，使用的就是回调函数的方式</p>
<pre><code class="language-js">	//fs ----&gt; file System
	var fs = require(&quot;fs&quot;)
	fs.readFile(&quot;xx.json&quot;,function(err,contents){
        //在回调函数中国做一些事情
    })
</code></pre>
<p>那么任务执行器是什么呢？</p>
<p><strong>任务执行器是一个函数，用来循环执行生成器，因为我们知道生成器需要执行N次next()方法，才能运行完，所以我们需要一个自动任务执行器帮我们做这些事情，这就是任务执行器的作用</strong></p>
<p>下面我们编写一个异步任务执行器。</p>
<pre><code class="language-js">  function *aIterator(){
            yield 1
            yield 3
            yield 5
            yield 7
            yield 9
            yield 11
        }


        // 用run函数来替代运行，这个run就是执行器
        function run (fnIter,fn) {
            let iterator = fnIter()
            while(true){
                // next函数中有done值和value值
                let {value,done} = iterator.next();
                if(done){
                    break
                }else{
                    fn(value)
                }
            }
        }
        run(aIterator,(value)=&gt;{
            console.log(value+10);
        })
</code></pre>
<h1 id="16代理proxy">16代理Proxy</h1>
<p>proxy这个词相信你已经听了无数遍了</p>
<p><strong>语法</strong></p>
<pre><code class="language-js">        let pUser =new Proxy(targe,handler)
</code></pre>
<p>target：一个目标对象（可以是任何类型的对象，包括本机数组，函数，甚至另一个代理）用Proxy来包装。</p>
<p>handler：一个对象，其属性是当执行一个操作时定义代理的行为的函数</p>
<h4 id="代理的使用">代理的使用</h4>
<p>**基础demo：**Proxy的demo有很多，我们只分析基础demo，主要看new Proxy({},handler)的操作，指定目标obj对象，然后handler对象执行get()操作，get()返回值的判断是，如果name是target目标对象的属性，则返回target[name]的值，否则返回37，</p>
<pre><code class="language-js">        let user = {
            name: &quot;小明&quot;,
            age: 16
        }

        // 设置代理对象,第一个参数要代理的对象，第二个参数是要做的事情
        let pUser =new Proxy(user,{
            // target就是对象
            // 每次从pUser中获取属性的时候运行该函数
            get(target,attr){
                // console.log(target);
                // console.log(attr);

                // 如果不return 的话是拿不到数据的
                return target[attr]
            },

            // 每次从pUser中设置或者改变属性的时候运行该函数
            set(target,attr,value){
                // console.log(target);
                // console.log(attr);
                // console.log(value); 
                // 如果不设置的话是改变不了的
                target[attr] = value;
            }

            
            
            
        })

       let age =  pUser.age
       pUser.age=123
</code></pre>
<p><strong>代理的运用</strong></p>
<pre><code class="language-js">        let DOM = new Proxy({}, {
            get(target,attr) {
                // console.log(123);
                var domObj = document.createElement(attr)
                return function (attrs,...children) {
                    for(key in attrs){
                        domObj.setAttribute(key,attrs[key])
                    }
                    for(let i =0;i&lt;children.length;i++){
                        if(typeof children[i] ==&quot;string&quot;){
                            children[i] = document.createTextNode(children[i])
                        }
                        domObj.appendChild(children[i])
                    }
                    return domObj
                }
            }
        })
        var d1 =DOM.div({id:&quot;d1&quot;,&quot;class&quot;:&quot;redBg&quot;},&quot;helloWorld&quot;,&quot;你好&quot;)
        document.body.appendChild(d1)

        var ul =DOM.ul(
            {id:&quot;lieBiao&quot;,&quot;class&quot;:&quot;redBg&quot;},
            DOM.li({&quot;class&quot;:&quot;li&quot;},&quot;列表1&quot;),
            DOM.li({&quot;class&quot;:&quot;li&quot;},&quot;列表2&quot;),
            DOM.li({&quot;class&quot;:&quot;li&quot;},&quot;列表3&quot;),
            DOM.li({&quot;class&quot;:&quot;li&quot;},&quot;列表4&quot;),
        )
        document.body.appendChild(ul)

</code></pre>
<h1 id="其他">其他</h1>
<h2 id="深拷贝和浅拷贝的区别以及实现">深拷贝和浅拷贝的区别以及实现</h2>
<p>浅拷贝：假设A复制了B,当修改A时，B也跟着变化了，那么这就是浅拷贝。</p>
<p>深拷贝：A复制了B，当修改A时，B没有发生任何变化，<strong>二者完全不相连</strong>，这就是深拷贝。</p>
<p>在了解深拷贝和浅拷贝之前我们需要先懂得一个概念，</p>
<p>什么是引用数据类型，（重音在“引用”上）</p>
<p>我们都知道<strong>基本数据类型</strong>包括：<span style="color:red">number、string、Boolean、null、Undefined、symbol、BigInt</span></p>
<p>还有一个引用数据类型：Object类（包括无序对象例如<code>{name:&quot;小明&quot;}</code>，数组例如:<code>[1,2,3]</code>以及函数等）</p>
<p><strong>基本数据类型的存储方式——名、值都储存在栈内存中</strong></p>
<p>相当于没有所谓的指向堆地址一说</p>
<p>例如let a = 1;</p>
<figure data-type="image" tabindex="11"><img src="https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124130901890-511917244.jpg" alt="img" loading="lazy"></figure>
<p>当你b=a复制时，栈内存会新开一个内存，例如这样：</p>
<figure data-type="image" tabindex="12"><img src="https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124131822437-430949998.jpg" alt="img" loading="lazy"></figure>
<p>a和b现在没有任何关联，所以修改a的时候，b完全不受影响。</p>
<p>但是这算不上是深拷贝，深拷贝只针对较为复杂的引用数据类型Object。</p>
<p><strong>引用数据类型的存储方式——名和值分开放，名存在栈内存中，值存在堆内存中，但是栈内存会放一个引用的地址指向相应的堆内存</strong></p>
<p>在这之前我们先看一个例子（浅拷贝）：</p>
<pre><code class="language-js">let a=[0,1,2,3,4],
    b=a;
console.log(a===b);
//现在对a[0]进行更改
a[0]=1;
console.log(a,b);
</code></pre>
<p>运行结果：</p>
<figure data-type="image" tabindex="13"><img src="https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124114023703-1953539844.png" alt="img" loading="lazy"></figure>
<p>我们看到b复制了a之后，把a进行修改，b却也跟着改变了，是因为b复制的只是a的引用地址，二者的值其实是同一个</p>
<figure data-type="image" tabindex="14"><img src="https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124133428359-1292133331.jpg" alt="img" loading="lazy"></figure>
<p>以上是a的存储方式</p>
<figure data-type="image" tabindex="15"><img src="https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124133647796-1390255671.jpg" alt="img" loading="lazy"></figure>
<p>当b=a进行拷贝的时候，其实复制的只是a的引用地址，并非堆内存里面的值</p>
<figure data-type="image" tabindex="16"><img src="https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124133934328-67216865.jpg" alt="img" loading="lazy"></figure>
<p>而当我们使<code>a[0]=1</code>进行修改时，由于a和b指向的是同一个地址，所以b自然也收了影响，这就是所谓的浅拷贝</p>
<figure data-type="image" tabindex="17"><img src="https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124140906203-2099568933.jpg" alt="img" loading="lazy"></figure>
<p>如果给b也开辟一个堆内存存放值的话，像基本类型那样，就达到深拷贝的效果了</p>
<p>那么如何实现深拷贝呢</p>
<p><strong>1.递归实现深拷贝</strong></p>
<pre><code class="language-js">        // 使用递归完成深拷贝
        var star = {
            name: &quot;蔡徐坤&quot;,
            gender: 1,
            hobby: [&quot;唱&quot;, &quot;跳&quot;, &quot;rap&quot;, &quot;篮球&quot;],
            friends: [&quot;lawyer&quot;, &quot;chicken&quot;],
            goods: { cloth: &quot;吊带&quot;, weapon: &quot;篮球&quot; }
        }
        var fakeStar = {
            money: 9999
        }

        // 使用递归实现深拷贝
        function deepCopy(obj1, obj2) {
            obj2 = obj2 || {}
            for (let i in obj1) {
                if (typeof obj1[i] != 'object') {
                    // 如果不是引用类型Object，直接复制就可
                    obj2[i] = obj1[i]
                } else {
                    if (obj1[i].constructor === Array) {
                        // 如果是数组
                        obj2[i] = []
                    } else {
                        //如果是对象
                        obj2[i] = {}
                    }
                    //进行递归操作
                    deepCopy(obj1[i], obj2[i])
                }
            }
            return obj2
        }

        fakeStar = deepCopy(star, fakeStar)
        console.log(star, &quot;star&quot;);
        console.log(fakeStar, &quot;fakeStar&quot;);
</code></pre>
<p><strong>2.借用JSON对象的parse和stringify</strong></p>
<pre><code class="language-js">function deepClone(obj){
    let _obj = JSON.stringify(obj),
        objClone = JSON.parse(_obj);
    return objClone
}    
let a=[0,1,[2,3],4],
    b=deepClone(a);
a[0]=1;
a[2][0]=1;
console.log(a,b);
</code></pre>
<figure data-type="image" tabindex="18"><img src="https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124154610578-1742013996.png" alt="img" loading="lazy"></figure>
<p><strong>3.除此之外，还有jquery提供的$.extend()方法</strong></p>
<p><strong>jQuery.extend(<em>[deep]</em>, target, object1, <em>[objectN]</em>)</strong></p>
<h1 id="es6-es2020">es6-es2020</h1>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f623a94c2f6f4cbeb46b1e8d66e75186~tplv-k3u1fbpfcp-watermark.image" alt="ES6缩略" style="zoom: 50%;" />
<h2 id="es2015">es2015</h2>
<h3 id="const-and-let">const and let</h3>
<p>const 声明之后必须马上赋值</p>
<p>let声明之后可以立马赋值也可以使用的时候再赋值</p>
<ul>
<li>不允许重复声明</li>
<li>未定义就会报错：不存在变量提升</li>
<li>暂时性死区：在let and const 声明变量之前 该变量不可以使用</li>
</ul>
<h3 id="解构赋值">解构赋值</h3>
<p>字符串，数值，boolean，对象，数组，函数参数均可以解构赋值。</p>
<ul>
<li>只要=两边模式相同，左边的变量就会被赋值</li>
<li>解构赋值，如果=右边的值不是数组或者对象，就会把右边转为<mark>对象</mark></li>
<li>需要遵循匹配模式</li>
<li>结构不成功时变量的值等undefined</li>
<li>undefined and null 无法转为对象，因此无法进行解构</li>
</ul>
<h3 id="字符串扩展">字符串扩展</h3>
<ul>
<li>可以通过for-of遍历字符串</li>
<li>字符串模板  <code>${ }</code></li>
<li>repeat(),字符串重复n次并且返回新的<code>字符串</code></li>
<li>matchAll():返回正则在String中的所有的匹配</li>
<li>includes</li>
<li>startWith()/endWith()</li>
</ul>
<h3 id="number扩展">Number扩展</h3>
<ul>
<li>新增了一系列方法</li>
</ul>
<h3 id="object扩展">Object扩展</h3>
<ul>
<li>简洁表示:直接写入变量和函数作为对象的属性和方法（{prop,method(){ }}）</li>
<li>Object.assgin()合并对象（浅拷贝）</li>
<li>Object.getPrototype()获取对象的原型对象</li>
<li>Object.setPrototype()修改对象的原型对象</li>
<li>__ proto __：返回或者设置对象的隐式原型</li>
</ul>
<p>属性遍历</p>
<ul>
<li>for-in：遍历对象自身可遍历可枚举属性</li>
<li>Object.keys() 返回自身可枚举属性组成的数组
<ul>
<li>规则
<ol>
<li>首先遍历所有的数值键，按照数值升序排列</li>
<li>遍历所有的字符串键，按照加入时间升序</li>
<li>遍历所有的Symbol，按照加入时间升序</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="array扩展">Array扩展</h3>
<ul>
<li>[...arr]   扩展运算符</li>
<li>Array.form()转为真正的数组
<ol>
<li>类数组：arguments，length，Nodelist</li>
<li>可遍历对象：String，set，map，Generator</li>
</ol>
</li>
<li><strong>find()</strong>：返回第一个符合条件的成员</li>
<li><strong>findIndex()</strong>：返回第一个符合条件的成员索引值</li>
<li><strong>fill()</strong>：根据指定值填充整个数组，返回原数组</li>
<li><strong>keys()</strong>：返回以索引值为遍历器的对象</li>
<li><strong>values()</strong>：返回以属性值为遍历器的对象</li>
<li>es6将数组空位转为undefined</li>
</ul>
<ol>
<li>Math.max.apply(null,[x,y]) =&gt; Math.max(...[x,y])</li>
<li>合并，clone，拼接，转化字符串为数组都可以用到 [ ... ]</li>
</ol>
<h3 id="函数扩展">函数扩展</h3>
<ul>
<li>参数默认值: function(x=1,y=1){}</li>
<li>reset/spread参数():返回函数的多余参数</li>
<li>严格模式：只要函数用了... 解构赋值 扩展运算符，就不能使用严格模式</li>
<li>箭头函数:()=&gt;{}
<ul>
<li>this指向固定化</li>
<li>无自己的this，内部的this就是外层代码块的this，this是定义所在对象的this，不是使用的对象</li>
<li>因为没有this，所以不能用作构造函数，不能使用new</li>
<li>不能使用yield，不能用作Generator函数</li>
<li>不可使用Arguments对象，此对象在函数体内不存在</li>
</ul>
</li>
<li>尾调用优化：</li>
</ul>
<h3 id="symbol">Symbol</h3>
<p>唯一值：const set = Symbol(Str)</p>
<h3 id="set">Set</h3>
<p>唯一and不重复的值</p>
<p>具有iterator的数据结构</p>
<ul>
<li><strong>add()</strong>：添加值，返回实例</li>
<li><strong>delete()</strong>：删除值，返回布尔</li>
<li><strong>has()</strong>：检查值，返回布尔</li>
<li><strong>clear()</strong>：清除所有成员</li>
<li><strong>keys()</strong>：返回以属性值为遍历器的对象</li>
<li><strong>values()</strong>：返回以属性值为遍历器的对象</li>
<li><strong>entries()</strong>：返回以属性值和属性值为遍历器的对象</li>
<li><strong>forEach()</strong>：使用回调函数遍历每个成员</li>
</ul>
<p><strong>使用</strong>：去重String，Array。取交集，并集</p>
<ol>
<li>没有键只有值</li>
<li>添加多个NaN时，只会存在一个NaN</li>
<li>添加相同的对象的时候会认为是不同的对象</li>
<li>遍历顺序：插入顺序</li>
</ol>
<p>WeakSet</p>
<p>成员值只能是对象。</p>
<ul>
<li>add</li>
<li>delete</li>
<li>has</li>
</ul>
<p>存储DOM节点：DOM节点被移除的时候自动从文档中移除不用担心内存泄漏</p>
<p>临时存放一组对象或者是与对象绑定的信息</p>
<p><strong>tips</strong>：weakSet不可遍历，成员都是弱引用，</p>
<h3 id="map">Map</h3>
<p>类似于对象的数据结构，成员是任何类型的值。</p>
<p>属性：constuctor，size</p>
<p>方法：</p>
<ul>
<li><strong>get()</strong>：返回键值对</li>
<li><strong>set()</strong>：添加键值对，返回实例</li>
<li><strong>delete()</strong>：删除键值对，返回布尔</li>
<li><strong>has()</strong>：检查键值对，返回布尔</li>
<li><strong>clear()</strong>：清除所有成员</li>
<li><strong>keys()</strong>：返回以键为遍历器的对象</li>
<li><strong>values()</strong>：返回以值为遍历器的对象</li>
<li><strong>entries()</strong>：返回以键和值为遍历器的对象</li>
<li><strong>forEach()</strong>：使用回调函数遍历每个成员</li>
</ul>
<p>遍历顺序：插入顺序</p>
<p>对一个键多次赋值以后，后面的值将会覆盖前面的值</p>
<p>对同一个对象的引用，被视为一个键</p>
<p>对同样值的两个实例，被视为两个键。</p>
<p>添加多个NaN是作为键时，只会存在一个</p>
<p>Object：字符串-值，Map：值-值</p>
<h3 id="proxy">Proxy</h3>
<p>修改某些操作的默认行为(target,handler)</p>
<h3 id="class">Class</h3>
<p>对一类有着共同特征事物的抽象</p>
<p>类本身指向构造函数，所有的方法定义在prototype上，相当于构造函数的另外一种写法</p>
<p><strong>方法和关键字</strong></p>
<p>constructor : 构造函数</p>
<p>extrends：继承父类</p>
<p>super新建父类的this</p>
<p>get：取值函数，拦截属性的取值行为</p>
<p>set：存值函数</p>
<h3 id="module">Module</h3>
<ul>
<li>
<p>命令</p>
<ul>
<li>
<p>export</p>
<p>：规定模块对外接口</p>
<ul>
<li><strong>默认导出</strong>：<code>export default Person</code>(导入时可指定模块任意名称，无需知晓内部真实名称)</li>
<li><strong>单独导出</strong>：<code>export const name = &quot;Bruce&quot;</code></li>
<li><strong>按需导出</strong>：<code>export { age, name, sex }</code>(推荐)</li>
<li><strong>改名导出</strong>：<code>export { name as newName }</code></li>
</ul>
</li>
<li>
<p>import</p>
<p>：导入模块内部功能</p>
<ul>
<li><strong>默认导入</strong>：<code>import Person from &quot;person&quot;</code></li>
<li><strong>整体导入</strong>：<code>import * as Person from &quot;person&quot;</code></li>
<li><strong>按需导入</strong>：<code>import { age, name, sex } from &quot;person&quot;</code></li>
<li><strong>改名导入</strong>：<code>import { name as newName } from &quot;person&quot;</code></li>
<li><strong>自执导入</strong>：<code>import &quot;person&quot;</code></li>
<li><strong>复合导入</strong>：<code>import Person, { name } from &quot;person&quot;</code></li>
</ul>
</li>
<li>
<p>复合模式</p>
<p>：</p>
<pre><code>export命令
</code></pre>
<p>和</p>
<pre><code>import命令
</code></pre>
<p>结合在一起写成一行，变量实质没有被导入当前模块，相当于对外转发接口，导致当前模块无法直接使用其导入变量</p>
<ul>
<li><strong>默认导入导出</strong>：<code>export { default } from &quot;person&quot;</code></li>
<li><strong>整体导入导出</strong>：<code>export * from &quot;person&quot;</code></li>
<li><strong>按需导入导出</strong>：<code>export { age, name, sex } from &quot;person&quot;</code></li>
<li><strong>改名导入导出</strong>：<code>export { name as newName } from &quot;person&quot;</code></li>
<li><strong>具名改默认导入导出</strong>：<code>export { name as default } from &quot;person&quot;</code></li>
<li><strong>默认改具名导入导出</strong>：<code>export { default as name } from &quot;person&quot;</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>继承：<code>默认导出</code>和<code>改名导出</code>结合使用可使模块具备继承性</p>
</li>
<li>
<p>设计思想：尽量地静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</p>
</li>
<li>
<p>严格模式：ES6模块自动采用严格模式(不管模块头部是否添加<code>use strict</code>)</p>
</li>
</ul>
<blockquote>
<p>模块方案</p>
</blockquote>
<ul>
<li><strong>CommonJS</strong>：用于服务器(动态化依赖)</li>
<li><strong>AMD</strong>：用于浏览器(动态化依赖)</li>
<li><strong>CMD</strong>：用于浏览器(动态化依赖)</li>
<li><strong>UMD</strong>：用于浏览器和服务器(动态化依赖)</li>
<li><strong>ESM</strong>：用于浏览器和服务器(静态化依赖)</li>
</ul>
<p>加载方式</p>
<ul>
<li>运行时加载:整体加载模块生成一个对象，再从对象上获取需要的属性and方法进行加载。
<ul>
<li>只有运行的时候才能得到这对象，无法在编译的时候做静态优化</li>
</ul>
</li>
<li>编译时加载：直接在模块中获取需要的属性和方法进行加载（<strong>按需加载</strong>）
<ul>
<li>在编译的时候就完成了加载哦，效率较高，但无法引用模块本身，可拓展JS高级语法</li>
</ul>
</li>
<li>传统加载:通过<script>加载
<ul>
<li>同步</li>
<li>异步
<ul>
<li>defer：顺序加载</li>
<li>async:乱序加载</li>
</ul>
</li>
</ul>
</li>
<li>模块加载：<script type="module">  默认是异步</li>
</ul>
<p>CommonJS and ESM区别：</p>
<ul>
<li>CommonJs输出值的拷贝，模ESM输出值的引用
<ul>
<li>CommonJS一旦输出一个值，模块内部的变化就影响不到这个值</li>
</ul>
</li>
<li>CommonJS是运行时加载，ESM是编译时加载
<ul>
<li>CommonJS只有在脚本运行完以后才会生成</li>
<li>ESM加载模块不是对象，它的对外接口只是一种静态定义</li>
</ul>
</li>
</ul>
<h3 id="iterator迭代器and-generato生成器">Iterator迭代器and Generato生成器</h3>
<p>Iterator：为不同的数据结构提供统一的访问机制</p>
<p>创建一个指针指向首个成员，按照next()访问下一个成员变量，直到结束位置。</p>
<p>数据结构</p>
<ul>
<li>​	集合：Array，Object，set ，Map</li>
<li>原生具备接口的数据结构：String，Array，Set，Map，TypeArray，arguments</li>
</ul>
<p>Generator：封装多个内部状态的异步编程解决方案。</p>
<pre><code>function* Func(){}
</code></pre>
<p>调用<code>Generator函数</code>(该函数不执行)返回指向内部状态的指针对象(不是运行结果)</p>
<h3 id="promise">Promise</h3>
<p>包含异步操作的结果对象</p>
<p>resolved  pending rejected</p>
<p>特点：对象的状态一经改变就不会再变，状态不受外界影响。</p>
<p>then方法：分别指定resolved和rejected状态的回调函数  then(resolved,rejected)</p>
<p>Promise.all():将多个实例包装成一个新的实例，返回全部实例状态变更后的结果数组。</p>
<ul>
<li>入参：具有迭代器的数据结构</li>
<li>成功：全部成功才会fulfilled</li>
<li>失败：只要有一个失败就是rejected</li>
</ul>
<ol>
<li>只有异步操作可以决定当前状态是哪一个，其他操作无法改变</li>
<li>状态改变只有两种情况pending---&gt;resolved  pending---&gt;rejected</li>
<li>一旦新建Promise对象就会立即执行，无法中途取消</li>
<li>不设置回调函数，内部抛错不会到外部</li>
<li>pending状态的时候无法知道是那个阶段</li>
<li>resolved rejected回触发then回调函数</li>
<li>reject（）等于抛错错误</li>
<li>实例状态的错误会冒泡，一直向后传递直到被捕获为止。</li>
</ol>
<h2 id="es2016">es2016</h2>
<p>数值扩展</p>
<ul>
<li>指数运算符 （**）：相当于指数求幂 Math.pow()</li>
</ul>
<p>数组扩展</p>
<ul>
<li>includes()</li>
</ul>
<h2 id="es2017">es2017</h2>
<p>String扩展</p>
<ul>
<li>padStart() :把指定的字符串填充到字符串头部，返回新字符串</li>
<li>padEnd() :把指定的字符串填充到字符串尾部部，返回新字符串</li>
</ul>
<p>Object扩展</p>
<ul>
<li>Object.values() :返回以值组成的数组</li>
<li>Object.entries():返回以键值组成的数组</li>
<li>Object.getOwnPropertyDescriptors() :返回对象所有的自身属性的描述对象</li>
</ul>
<p>函数：允许函数的最后一个参数有 逗号，</p>
<p>**Async:**使异步函数以同步函数的形式书写</p>
<p>原理：将Generator函数和自动执行器spawn包装在一个函数里</p>
<p>await：等待当前Promise对象状态变更完毕</p>
<ul>
<li>正常：后面是P&quot;romise对象则返回结果，否则返回对应的值</li>
<li>后随Thenable对象，将其等于Promise对象返回其结果</li>
</ul>
<p>应用场景：按顺序执行异步操作。</p>
<p>tips：</p>
<ol>
<li>Async函数返回Promise对象，可以使用then()添加回调函数</li>
<li>nebulareturn值会被后续的then出参</li>
<li>内部抛出错误会导致返回的Promise对象编程rejected，被catch</li>
<li>返回的Promise对象必须等到内部await所有的promise对象执行完毕，或者报错</li>
<li>只要有一个rejected，全部报错</li>
<li>await只能放在async中</li>
<li>数组使用forEach()执行async/await会失效，可以使用for-of或者promise.all(代替)</li>
</ol>
<h2 id="es2018">es2018</h2>
<p>String</p>
<p>放松对标签模板中字符串转义的限制</p>
<p>Object</p>
<p>扩展运算符 ...</p>
<p>转换对象为用逗号分割的参数序列{...obj}</p>
<ul>
<li>clone</li>
<li>合并对象 {...obj1,...obj2 }</li>
<li>转换字符串为对象 {...&quot;hello&quot;}</li>
<li>转换数组为对象{...[1,2]}</li>
<li>修改现有对象部分属性：<code>const obj = { x: 1, ...{ x: 2 } }</code></li>
</ul>
<h3 id="正则reg">正则reg</h3>
<p><strong>s修饰符</strong>：dotAll模式修饰符，使<code>.</code>匹配任意单个字符(<code>dotAll模式</code>)</p>
<p><strong>dotAll</strong>：是否设置<code>s修饰符</code></p>
<p><strong>后行断言</strong>：<code>x</code>只有在<code>y</code>后才匹配</p>
<p><strong>后行否定断言</strong>：<code>x</code>只有不在<code>y</code>后才匹配</p>
<p><strong>Unicode属性转义</strong>：匹配符合<code>Unicode某种属性</code>的所有字符</p>
<ul>
<li>正向匹配：<code>\p{PropRule}</code></li>
<li>反向匹配：<code>\P{PropRule}</code></li>
<li>限制：<code>\p{...}</code>和<code>\P{...}</code>只对<code>Unicode字符</code>有效，使用时需加上<code>u修饰符</code></li>
</ul>
<p><strong>具名组匹配</strong>：为每组匹配指定名字(<code>?&lt;GroupName&gt;</code>)</p>
<p><strong>Promise</strong></p>
<ul>
<li>finally()：指定不管最后状态如何都会指定的回调函数</li>
</ul>
<p><strong>Async</strong></p>
<p>异步迭代器（for-await-of）：循环等待每个Promise对象编程resolved才进入下一步</p>
<h2 id="es2019">es2019</h2>
<p><strong>String</strong></p>
<ul>
<li>JSON.Stringify()可以返回不符合utf-8标准的字符串</li>
<li>trimStart():消除String头部空格，返回新串</li>
<li>trimEnd():消除String尾部空格，返回新串</li>
</ul>
<p><strong>Object</strong></p>
<p>object.fromEntries()返回以键和值组成的对象</p>
<p><strong>Array</strong></p>
<ul>
<li>flat：扁平化数组</li>
<li>flatMap():映射且扁平化数组，返回新的数组</li>
</ul>
<p><strong>Fucntion</strong></p>
<p>toString：返回函数的原始代码</p>
<p>catch（：参数可省略</p>
<p><strong>Symbol</strong></p>
<p>description:返回Symbol的描述</p>
<h2 id="es2020">es2020</h2>
<p><strong>声明</strong></p>
<ul>
<li>globalThis：顶层this，指向全局环境下的this</li>
<li>Node：顶层对象global</li>
<li>webworker：顶层对象是self。</li>
</ul>
<p><strong>BigInt</strong>：任何位数的整数，1n</p>
<ul>
<li>BigInt()：转换普通数组为BigInt类型</li>
<li>BigInt.asIntN():转换BigInt为-2n-1 到2n-1-1</li>
<li>BigInt.parseInt():将一个字符串转换为指定进制的BigInt类型</li>
</ul>
<p>Tips：BigInt可以使用各种进制表示，加上后缀</p>
<p>BigInt与普通整数之间是两种值，并不相等</p>
<p>typeOf bigInt = bigint</p>
<p><strong>Object</strong></p>
<p>链判断操作符：是否存在对象属性      ?.</p>
<p>对象属性 ：obj?. prop</p>
<p>函数调用：func？.(...args)</p>
<p>空判断操作符(??):是否值为undefined or null 是则使用默认值</p>
<p><strong>正则****reg</strong></p>
<p>mathAll().返回所有匹配的遍历器</p>
<p><strong>Module</strong></p>
<p>import()动态导入（返回Promise）</p>
<p><mark>require同步加载</mark></p>
<p><mark>import异步加载</mark></p>
<p><strong>Iterator</strong></p>
<p>for-in遍历顺序</p>
<h3 id="promise-2">Promise</h3>
<ul>
<li><strong>Promise.allSettled()</strong>：将多个实例包装成一个新实例，返回全部实例状态变更后的状态数组(齐变更再返回)</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue]]></title>
        <id>https://Leonhaiwang.github.io/post/vue/</id>
        <link href="https://Leonhaiwang.github.io/post/vue/">
        </link>
        <updated>2021-03-25T08:28:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="vue">vue</h1>
<p>MVC模式：模型（js变量）--视图（HTML，css）--控制器（通过DOM对象绑定事件，将变量进行修改）</p>
<h2 id="mvvm模式-基于mvc框架无control">MVVM模式---基于mvc框架无control</h2>
<p>Model：负责数据储存</p>
<p>View：负责页面展示</p>
<p>View Model:负责业务逻辑，对数据进行加工后交给视图展示</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 视图 --&gt;
    &lt;div id=&quot;app&quot;&gt;
        {{ message }}
      &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;./lib/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var app = new Vue({
    el: '#app',
    //模型部分
    data: {
        message: 'Hello Vue!'
    }
    })
    console.log(app)
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>上面的这种方式效率低，而且容易被用户在浏览器情况下看到未经渲染的数据。用户体验不好，所以还有其他的渲染方式</p>
<h2 id="虚拟dom">虚拟DOM</h2>
<p>传统的DOM开发，是利用jQuery操作DOM，非常耗资源。</p>
<p>在JS内存里面构建类似于DOM的对象，去拼装数据，拼装完整后，把数据整体解析。一次性插入到html中去，----&gt;形成了虚拟Dom</p>
<h2 id="条件渲染">条件渲染</h2>
<h3 id="v-if-and-v-else"><strong>v-if</strong>   and  <strong>v-else</strong></h3>
<p>可以写boolean表达式</p>
<p>v-if和v-else中间不能 有其他的元素</p>
<p><strong>v-if-else</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
  
&lt;/head&gt;
&lt;body&gt;
  
    &lt;div id=&quot;app&quot;&gt;
       &lt;h1&gt;用户名：{{username}}&lt;/h1&gt;

       &lt;h2 v-if = &quot;isVip&quot;&gt;用户类型：VIP&lt;/h2&gt;
       &lt;!-- v-if和v-else中间不能有其他的元素 --&gt;
       &lt;h3 v-else = &quot;else&quot;&gt;else显示&lt;/h3&gt;

       &lt;br&gt;

       &lt;h1&gt;用户允许登录的时间&lt;/h1&gt;
       &lt;h3 v-if = &quot;age &gt; 14&quot;&gt;24hour&lt;/h3&gt;
       &lt;h3 v-else-if = &quot;isMiddle&quot;&gt;8hour&lt;/h3&gt;
       &lt;h3 v-else&gt;2hour&lt;/h3&gt;

      &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;./lib/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var app = new Vue({
    el: '#app',
    data: {
       username:&quot;张三&quot;,
       isVip:true,
       else:false,
       isAdult:true,
       isMiddle:false,
       age:16
    }
    })
    console.log(app)
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="v-show"><strong>v-show</strong></h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
  &lt;style&gt;
      #inner{
          color: chartreuse;
          background-color: cornflowerblue;
          font: 24px;
          width: 200px;
          height: 200px;
      }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
       
        &lt;div id=&quot;inner&quot; v-show = &quot;isShow&quot;&gt;
                helloVue
        &lt;/div&gt;
        &lt;button @click = &quot;show&quot;&gt;
            切换显示内容
        &lt;/button&gt;
      &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;./lib/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var app = new Vue({
    el: '#app',
    data: {
      isShow:false
    },
    methods:{
        show:function(){
            app.isShow = !app.isShow
        }
    }
    })
    
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="v-if-和-v-show的区别">v-if 和 v-show的区别</h3>
<p>v-if：不显示的时候，第一次直接不渲染，如果此时内容已经设置为显示，那么直接将内容从DOM去除，</p>
<p>v-show：不显示的时候，会改为display：none。 但是会渲染</p>
<p><strong>反复需要切换的内容用v-show;只是渲染一次的内容用v-if</strong></p>
<h2 id="列表渲染">列表渲染</h2>
<p>绑定key值，是String不用:</p>
<p>可以在v-for里面加上v-if判断条件</p>
<p>绑定的key值和后面要展示的元素是一一对应的。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
  
&lt;/head&gt;
&lt;body&gt;
  
    &lt;div id=&quot;app&quot;&gt;
        &lt;ul id=&quot;example-1&quot;&gt;
            &lt;li v-for=&quot;item,key in items&quot; :key=&quot;item.name&quot;&gt;
             {{key}} {{ item.name }} {{item.message}}
            &lt;/li&gt;
          &lt;/ul&gt;

          &lt;h3&gt;循环对象&lt;/h3&gt;
          &lt;ul&gt;
              &lt;li v-for = &quot;item,key in items[0]&quot;&gt;
              key:{{key}}  value:{{item}}
              &lt;/li&gt;
          &lt;/ul&gt;
          
          &lt;h3&gt;条件+循环渲染&lt;/h3&gt;
          &lt;ol&gt;
            &lt;li v-for = &quot;item,index in items&quot;  v-if = &quot;item.age%2==0&quot; :key = &quot;index&quot;&gt;
             {{index}}   {{item.age}} {{item.name}}
            &lt;/li&gt;
          &lt;/ol&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;./lib/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var app = new Vue({
    el: '#app',
    data: {
        items: [
      { message: 'Foo' ,name:'name1',age:12},
      { message: 'Bar' ,name:'name2',age:11}
    ]
    }
    })
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h2 id="模板语法">模板语法</h2>
<p>v-once只是插入一次不再更新。一次性插入不再修改</p>
<p>v-html：使得插入的html格式文本生效。</p>
<p>tips：使用v-html的时候，容易受到<mark>xss攻击</mark>（html里面的String容易会有执行命令的Demo，对网站造成攻击）</p>
<p>v:bind：绑定</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
  &lt;style&gt;
      #login{
          background-color: pink;
      }
      #register{
          background-color: cornflowerblue;
      }
      .name{
        background-color: cornflowerblue;
      }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  
    &lt;div id=&quot;app&quot;&gt;
       &lt;h1&gt;{{msg}}&lt;/h1&gt;
       &lt;h1 v-once&gt;{{msg}}&lt;/h1&gt;
       &lt;h1 v-html = &quot;html&quot;&gt;{{html}}&lt;/h1&gt;
       &lt;div :id = &quot;idName&quot;&gt;页面&lt;/div&gt;
        &lt;!-- 模板语言的表达式应用 --&gt;
        &lt;div&gt;
            {{firstName+lastName}}
        &lt;/div&gt;
        &lt;!-- 三元运算符 --&gt;
        &lt;div&gt;
            {{isVip?&quot;yes&quot;:&quot;no&quot;}}
        &lt;/div&gt;
        &lt;!-- 事件的绑定 --&gt;
        &lt;div class=&quot;name&quot;&gt;
            &lt;button v-on:click = &quot;changBG&quot;&gt;按钮&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;./lib/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var app = new Vue({
    el: '#app',
    data: {
       msg:&quot;String&quot;,
       html:'&lt;span&gt;1&lt;/span&gt;',
       idName:&quot;login&quot;,
       firstName:&quot;Z&quot;,
       lastName:&quot;SSS&quot;,
       isVip:true
    },
    methods:{
        changBG:function(){
            document.body.style.background = &quot;pink&quot;
        }
    }
    })
   
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h2 id="计算属性">计算属性</h2>
<p>conputed:将计算之后的结果返回再使用，计算的结果会放在缓存中提高效率</p>
<p>set，get</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;div&gt;
            {{firstName+lastName}}
        &lt;/div&gt;
       &lt;div&gt;
            {{fullname}}
       &lt;/div&gt;
       &lt;div&gt;
           &lt;!-- 逆序显示单词 --&gt;
           &lt;h1&gt;{{word.split(&quot;&quot;).reverse().join('')}}&lt;/h1&gt;
           &lt;h1&gt;{{reverseWord}}&lt;/h1&gt;
       &lt;/div&gt;
       &lt;div&gt;
           &lt;h1&gt;{{oddStudents}}&lt;/h1&gt;
       &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;./lib/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var app = new Vue({
    el: '#app',
    data: {
       firstName:&quot;Z&quot;,
       lastName:&quot;SSS&quot;,
        word:'music',
        items: [
      { message: 'Foo' ,name:'name1',age:12},
      { message: 'Bar' ,name:'name2',age:11}
    ]
    },
    computed:{
        fullname:function(){
            //会将计算的结果进行缓存
            return this.firstName+this.lastName
        },
        reverseWord:{
            get:function(){
                return this.word.split(&quot;&quot;).reverse().join(&quot;&quot;)
            },
            set:function(value){
                this.msg = value.split(&quot;&quot;).reverse().join(&quot;&quot;)
            }
        },
        oddStudents:function(){
            let result  = this.items.filter((item,i)=&gt;{
                return item.age%2==0
            })
            return result
        }
    }
    })
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="computed中的set和get方法">computed中的set和get方法</h3>
<p>一般没有set方法，是一个只读属性。</p>
<p>set参数（newValue），重新赋值。</p>
<pre><code class="language-js">computed: {
        // fullname:function () {
        //     return this.firstName + ' ' + this.lastName
        // }
        fullname:{
            set:function(newValue){
                console.log('----',newValue)
                const names = newValue.spilt(' '),
                this.firstName = names[0]
                this.lastName = names[1]
            },
            get:function(){
                return this.firstName + this.lastName
            }
        }
</code></pre>
<h3 id="method和computed的区别">method和computed的区别</h3>
<p>computed有内部缓存机制不会被频繁的调用，method每次都会被调用</p>
<h2 id="侦听器">侦听器</h2>
<p>监听数据变化的事件</p>
<p>不要滥用wacth：会影响效率内存</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
  &lt;style&gt;
      #login{
          background-color: pink;
      }
      #register{
          background-color: cornflowerblue;
      }
      .name{
        background-color: cornflowerblue;
      }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  
    &lt;div id=&quot;app&quot;&gt;
       
        &lt;div&gt;
            {{msg}}
            &lt;ul&gt;
                &lt;li v-for = 'item in arr'&gt;{{item}}&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;./lib/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var app = new Vue({
    el: '#app',
    data: {
      msg:&quot;信息&quot;,
      arr:[
          'x','y','z','z'
      ]
    },
    
    watch:{
        msg:function(val){
            console.log(val)
        },
        arr:function(val){
            console.log(val)
        }
    }
    })
   
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h2 id="class与style绑定">class与style绑定</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
  &lt;style&gt;
      .active{
          width: 200px;
          height: 200px;
          background-color: cornflowerblue;
      }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  
    &lt;div id=&quot;app&quot;&gt;
      &lt;div class =&quot;page&quot; :class = &quot;{active:isTrue}&quot;&gt;
        &lt;div class=&quot;page&quot; :class = &quot;styObj&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;./lib/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var app = new Vue({
    el: '#app',
    data: {
      isTrue:true,
      styObj:{
          active:true,lao:true
      }
    },
    methods:{
      
    }
    })
   
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h2 id="事件修饰符">事件修饰符</h2>
<p>阻止一些默认的事件：冒泡……</p>
<pre><code class="language-vue">&lt;!-- 阻止单击事件继续传播 --&gt;
&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;

&lt;!-- 提交事件不再重载页面 --&gt;
&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;

&lt;!-- 修饰符可以串联 --&gt;
&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;

&lt;!-- 只有修饰符 --&gt;
&lt;form v-on:submit.prevent&gt;&lt;/form&gt;

&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;
&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;
&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;

&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;
&lt;!-- 即事件不是从内部元素触发的 --&gt;
&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;
</code></pre>
<p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击。</p>
<h2 id="表单绑定">表单绑定</h2>
<p>v-model：一般负责监听用户的输入事件以更新数据</p>
<h2 id="生命周期函数">生命周期函数</h2>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/3868852-b190121b7014e0ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img" loading="lazy"></figure>
<p>beforeCreate</p>
<p>data方法和事件方法methods还未绑定到实例对象上</p>
<p>created---网络请求</p>
<p>数据和方法已经初始化完成，绑定在对象上</p>
<p>beforeMount</p>
<p>渲染之前，根据数据生成的DOM对象是拿不到的，</p>
<p>mounted</p>
<p>渲染之后，可以拿到根据数据生成的dom对象</p>
<p>beforeUpdate</p>
<p>数据更改，但内容未更改之前</p>
<p>updated</p>
<p>数据更改，内容更改完毕</p>
<p>beforeDestory</p>
<p>destroyed、</p>
<figure data-type="image" tabindex="2"><img src="C:%5CUsers%5C13799%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200925194104274.png" alt="image-20200925194104274" loading="lazy"></figure>
<p>const常量，不可以再次赋值</p>
<p>常量的含义是指向的对象不能修改，但是可以改变对象内部的属性。</p>
<h2 id="对象字面量的一个增强的写法">对象字面量的一个增强的写法</h2>
<pre><code class="language-js">    &lt;script&gt;
        // const obj = {
        //     name:&quot;why&quot;,
        //     age:12,
        //     run:function(){

        //     },   
        // }
        //属性的增强写法
        const name = &quot;why&quot;;
        const age = 12;           
        const obj = {
            name:name,
            age:age
        }
        //es6
        const obj = {
            name,
            age
        }
        //函数的增强写法
        //es6
        const obj  = {
            run(){},
            o(){}
        }
    &lt;/script&gt;
</code></pre>
<h2 id="哪些数组的方法是响应式的">哪些数组的方法是响应式的</h2>
<p>push() ,</p>
<p>pop()删除数组中的最后一位元素,</p>
<p>shift()-删除数组中的第一位元素,</p>
<p>unshift()-在数组最前面添加元素,</p>
<p>splice(start，要删除几个元素/),删除</p>
<p>splice(start，替换的个数，用来要替换的元素)  替换</p>
<p>splice(start，0，要插入的元素)  删除</p>
<p>sort(),排序</p>
<p>reverse()，数组内容反转</p>
<p><strong>通过索引值直接来修改不是响应式的</strong></p>
<pre><code>Vue.set.(this.letter,0,'bbbb')
</code></pre>
<h2 id="编程方式命令式编程声明式编程"><strong>编程方式：命令式编程/声明式编程</strong></h2>
<p>面向对象编程（第一公民：对象）/函数式编程（第一公民：函数）链式编程</p>
<h2 id="js中的高阶函数">js中的高阶函数</h2>
<p>函数式编程</p>
<pre><code class="language-js">	&lt;script&gt;
       const nums = [1,2,3,4,566,757,78]
      //  filter中的回调函数，必须要返回一个boolean值，返回true函数内部将会将这次回调的n加入到新的数组中 ，返回false时函数内部会过滤掉这次的n
      let newnums =  nums.filter(function (n) {
        return n &lt; 100
      })
      //map函数遍历函数返回值----返回函数的所有的值
      let newnums2 =  newnums.map(function (n){
        return n * 2 
      })
      //reduce对数组中所有内容进行汇总--两个参数
      newnums2.reduce((preValue,n)=&gt;{
        return preValue+n 
      },0)

      let total = nums.filter(function (n) {
        return n &lt; 100
      }).map(function(n){
        return n * 2
      }).reduce(function (perValue,n) {
        return perValue+n
      },0)
	//****************************************************************************
      let total = nums.filter(n =&gt; n &lt; 100).map(n =&gt; n * 2).reduce((per,n) =&gt; per+n)
    &lt;/script&gt;
</code></pre>
<h2 id="组件化">组件化</h2>
<p>将一个页面完成一个一个的小的功能块。</p>
<h2 id="vue组件化">vue组件化</h2>
<ul>
<li>任何应用都会抽象成一颗组件树</li>
<li>抽象的，可以开发出一个个独立的小组件来构造应用</li>
</ul>
<h3 id="组件的三个使用步骤">组件的三个使用步骤</h3>
<ol>
<li>创建组件构造器  vue.extend()</li>
<li>注册组件 vue.components()</li>
<li>使用组件、</li>
</ol>
<h3 id="全局组件和局部组件">全局组件和局部组件</h3>
<p>全局组件---可以在多个Vue‘实例下面使用</p>
<pre><code class="language-js">//创建组件构造器对象
    const cpn = Vue.extend({
      template:`
        &lt;div&gt;
          &lt;h2&gt;标题&lt;/h2&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;h2&gt;标题&lt;/h2&gt; 
        &lt;/div&gt;
        `
    })
    //注册组件
    Vue.component('my-cpn',cpn)
</code></pre>
<p>局部组件</p>
<pre><code class="language-js">    //创建组件构造器对象
    const cpnC = Vue.extend({
      template:`
        &lt;div&gt;
          &lt;h2&gt;标题&lt;/h2&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;h2&gt;标题&lt;/h2&gt; 
        &lt;/div&gt;
        `
    })
    //注册组件
    //Vue.component('my-cpn',cpn)

    const app = new Vue({
    el: '#app',
    data: {
      msg:&quot;msg&quot;,
    },
    components:{
      //cpn使用组件的标签名
      cpn: cpnC
    }
    })
</code></pre>
<h3 id="父组件和子组件">父组件和子组件</h3>
<pre><code class="language-js">&lt;script&gt;
    //创建第一个组件-----子组件
    const cpnC1 = Vue.extend({
      template:`
        &lt;div&gt;
          &lt;h2&gt;标题11&lt;/h2&gt; 
        
        &lt;/div&gt;
        `
    })
    //创建第二个  -----父组件
    const cpnC2 = Vue.extend({
      template:`
        &lt;div&gt;
          &lt;cpn1&gt;&lt;/cpn1&gt;
          &lt;h2&gt;标题22&lt;/h2&gt; 
        &lt;/div&gt;
        `,
        components:{
          cpn1:cpnC1
        }
    })
    //root组件
    const app = new Vue({
    el: '#app',
    data: {
      msg:&quot;msg&quot;,
    },
    components:{
      cpn2:cpnC2
    }
    })
&lt;/script&gt;
</code></pre>
<p>当在vue中使用父组件的时候，内部会编译好，在解析模板的过程中会解析到子组件，编译完成后就是一个完整的Demo形式</p>
<h3 id="组件的语法糖注册方式">组件的语法糖注册方式</h3>
<pre><code class="language-js">&lt;script&gt;
    //全局组件
    Vue.components('cpn1',
    {
      template:`
        &lt;div&gt;
          &lt;h2&gt;标题11&lt;/h2&gt; 
        &lt;/div&gt;
        `
    })
    const app = new Vue({
    el: '#app',
    data: {
      msg:&quot;msg&quot;,
    },
    components:{
      cpn2:{
        //局部组件语法糖
        template:`
          &lt;div&gt;
            &lt;cpn1&gt;&lt;/cpn1&gt;
            &lt;h2&gt;标题22&lt;/h2&gt; 
          &lt;/div&gt;
          `
    }
    }
    })
&lt;/script&gt;
</code></pre>
<h3 id="组件模板抽离">组件模板抽离</h3>
<p>引用script标签来引入</p>
<pre><code class="language-js">&lt;script type=&quot;text/x-template&quot; id=&quot;cpn&quot;&gt;
    &lt;div&gt;
      &lt;h2&gt;标题11&lt;/h2&gt; 
    &lt;/div&gt;
&lt;/script&gt;
</code></pre>
<p>template标签使用</p>
<pre><code class="language-js">&lt;template id=&quot;cpn&quot;&gt;
  &lt;div&gt;
    &lt;h2&gt;标题22&lt;/h2&gt; 
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>组件内部不能直接访问Vue实例的数据data。</p>
<h3 id="vue组件中存取数据的data">vue组件中存取数据的data</h3>
<p>组件中的data应该是一个<mark>函数类型</mark>？？</p>
<p>函数每次调用都会返回一个新的对象，data中的数据在不同的组件调用的时候不会产生连锁反应。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;cpn&gt;&lt;/cpn&gt;
    {{title}}
  &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;../lib/vue.js&quot;&gt;&lt;/script&gt;
&lt;template id=&quot;w1&quot;&gt;
  &lt;div&gt;
    &lt;h1&gt;{{title}}&lt;/h1&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  Vue.component(&quot;cpn&quot;,{
    template:&quot;#w1&quot;,
    data() {
      return {
        title:'标题'
      }
    },
  })
  const app  = new Vue({
    el:'#app',
    data:{
      title:'组件中标题'
    }
  })
&lt;/script&gt;
&lt;/html&gt;

</code></pre>
<h3 id="父子组件通信">父子组件通信</h3>
<p>父---&gt;子 props</p>
<p>props可以使用不同的形式</p>
<p>类型限制</p>
<p>提供默认值</p>
<h4 id="props中的驼峰标识v-bind不支持驼峰驼峰标识要转成-连接的形式cmoive-c-movie">props中的驼峰标识：v-bind：不支持驼峰，驼峰标识要转成   -   连接的形式cMoive  --&gt;  c-Movie</h4>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;cpn :c-Movie = 'movies' :cmessage = &quot;message&quot;&gt;&lt;/cpn&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;template id=&quot;w1&quot;&gt;
  &lt;div&gt;
    &lt;h1&gt;Zi&lt;/h1&gt;
    &lt;ul&gt;
      &lt;li v-for = &quot;item in cMovie&quot; :key = &quot;item&quot;&gt;{{item}}&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;{{cmessage}}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script src=&quot;../lib/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  const cpn = {
   template:'#w1',
  //  props:['cmovie','cmessage'],
    props:{
      //类型显示
      //提供默认值
      // cmovie:Array,
      // cmessage:String
      cMovie:{
        type:Array,
        default:[],
        required:false
      },
      cmessage:{
        type:String,
        default:'aaaa',
        required:true
      }
    },
   data(){
     return {}
   }
  }
  const app  = new Vue({
    el:'#app',
    data:{
      message:&quot;hello world!&quot;,
      movies:[1,2,3,4,5]
    },
    components:{
      cpn
    }
  })
&lt;/script&gt;
&lt;/html&gt;

</code></pre>
<p>子----&gt;父 $emit Events</p>
<p>使用自定义事件来进行子--&gt;父之间数据的传递</p>
<p>在子组件里面自定义一个事件，使用v-on绑定监听这个事件，发动事件的对象，在父组件中绑定监听这个事件，在父组件的方法中，使用一个事件函数来接受传递的这个值。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!-- 父组件模板 --&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;cpn @itemclick = &quot;cpnClick&quot;&gt;&lt;/cpn&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;!-- //子组件模板 --&gt;
&lt;template id=&quot;w1&quot;&gt;
  &lt;div&gt;
    &lt;button v-for = 'item in categories' 
            @click = &quot;btnClick(item)&quot;&gt;
      {{item.name}}
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script src=&quot;../lib/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  //子组件
  const cpn = {
    template:'#w1',
    data(){
      return {
        categories:[
          {id:'aaa',name:&quot;热门推荐&quot;},
          {id:'bbb',name:&quot;家电家电&quot;},
          {id:'ccc',name:&quot;火锅火锅&quot;},
          {id:'ddd',name:&quot;热门们门&quot;},
          {id:'eee',name:&quot;热门推荐&quot;},
        ]
      }
    },
    methods:{
      btnClick(item){
        //发射   -----自定义事件   v-on可以用于组件间的自定义事件
        this.$emit('itemclick',item)
      }
    }
  }
  const app  = new Vue({
    el:'#app',
    data:{
      message:&quot;hello world!&quot;,
      movies:[1,2,3,4,5]
    },
    methods:{
      cpnClick(item){
        console.log(&quot;ddd&quot;,item)
      }
    },    components:{
      cpn
    }
  })
&lt;/script&gt;
&lt;/html&gt;

</code></pre>
<h3 id="vue中子组件有很多的标签的时候必须包含一个根div">vue中子组件有很多的标签的时候必须包含一个根div</h3>
<h3 id="父子组件访问方式">父子组件访问方式</h3>
<p>$children  通过下标去获取值，不稳定</p>
<p>$refs  给调用的组件加一个ref属性值</p>
<pre><code>&lt;cpn ref = &quot;a&quot;&gt;&lt;/cpn&gt;
this.$refs.a   
</code></pre>
<p>$parent  访问父组件</p>
<p>$root  访问根组件</p>
<h2 id="slot插槽">slot插槽</h2>
<p>扩展性</p>
<p>让使用者决定组件内部的一些内容展示什么</p>
<p>有的页面有很多的不同也有很多的不一样的，</p>
<p>抽取共性，保留不同</p>
<p>基本使用</p>
<p>默认值</p>
<p>如果有多个值替换，所有的值都会替换</p>
<pre><code> &lt;slot&gt; &lt;button&gt;案件&lt;/button&gt;&lt;/slot&gt;
</code></pre>
<pre><code>&lt;cpn&gt;&lt;button&gt;案例1&lt;/button&gt; &lt;/cpn&gt;
</code></pre>
<h3 id="具名插槽的使用">具名插槽的使用</h3>
<pre><code>&lt;slot&gt;left&lt;/slot&gt;
&lt;slot name = &quot;center&quot;&gt;middle&lt;/slot&gt;
&lt;slot&gt;right&lt;/slot&gt;
</code></pre>
<pre><code>  &lt;cpn&gt;&lt;span slot=&quot;center&quot;&gt;myname&lt;/span&gt;&lt;/cpn&gt;
</code></pre>
<h3 id="作用域插槽">作用域插槽</h3>
<p>父组件替换插槽的标签，但是内容由子组件来提供</p>
<pre><code>      &lt;template slot-scope = &quot;slot&quot;&gt;
        &lt;span v-for = &quot;item in slot.data &quot;&gt;{{item}} - &lt;/span&gt;   
        &lt;span&gt;{{slot.data.join(' - ')}}&lt;/span&gt;
      &lt;/template&gt;
</code></pre>
<pre><code>&lt;template id=&quot;wrap&quot;&gt;
  &lt;div&gt;
  &lt;slot :data = &quot;pLanguage&quot;&gt;
    &lt;ul&gt;
      &lt;li v-for = &quot;item in pLanguages&quot;&gt;{{item}}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/slot&gt;
  &lt;/div&gt;
 v                                                                                                                           &lt;/template&gt;
</code></pre>
<h2 id="模块化开发">模块化开发</h2>
<p>CommonJS</p>
<p>核心：导出导入</p>
<h2 id="webpack">webpack</h2>
<p>是一个现代的js应用的静态<strong>模块打包</strong>工具---前端模块化打包工具---更加强调模块化</p>
<p>会自动处理成浏览器都可以识别的代码，并且处理各种依赖</p>
<p>核心：我们可以进行模块化开发，并且帮助我们处理模块间的各种依赖关系</p>
<p>依赖node环境，</p>
<p>安装</p>
<pre><code>npm install webpack@3.6.0
</code></pre>
<h2 id="loader">loader</h2>
<h2 id="cli-脚手架">CLI---脚手架</h2>
<p>CommendLine Interface</p>
<p>可以快速搭建Vue开发环境和对应的Webpack配置</p>
<h2 id="路由">路由</h2>
<p>通过互联的网络把信息从源地址传输到目的地址的活动</p>
<p>路由映射表：[内网ip：电脑MAC地址]</p>
<p>路由和转送：</p>
<p>路由：决定数据包从来源到目的地的路径</p>
<p>转送：将输入端的数据转移到合适的输出端</p>
<h3 id="前端渲染后端渲染">前端渲染后端渲染</h3>
<h4 id="后端渲染由服务器渲染">后端渲染：由服务器渲染</h4>
<p>后端路由阶段：后端处理页面和url之间的关系，一个页面对应一个网址url，url发送到服务器，通过正则对该url进行匹配，最后交给Controller处理，最终生成HTML，css，返回给前端</p>
<p>后端路由缺点：</p>
<ul>
<li>所有的东西都是有后端来做的</li>
<li>html和java代码会混在一起，后期维护较麻烦</li>
</ul>
<h4 id="前后端分离阶段">前后端分离阶段：</h4>
<p>后端只负责提供数据，前端通过Ajax获取数据，并且可以通过js将数据渲染在页面中</p>
<p>前端渲染：浏览器中显示的网页中的大部分代码，都是由前端写的js代码在浏览器中执行，最终渲染出来的网页</p>
<p>优点：</p>
<ul>
<li>责任清晰</li>
<li>后端不必关心多端的接口不同</li>
</ul>
<h4 id="单页面富应用阶段">单页面富应用阶段</h4>
<p>SPA：在前后端分离的基础上加了一层前端路由，前端来维护一套路由规则</p>
<p>整个页面只有一个index.html页面，</p>
<p><strong>前端路由</strong>：配置映射关系，不同的url从全部资源中抽取出需要的资源页面数据展示。<mark>改变url的时候，页面不进行新的刷新</mark></p>
<h3 id="url中的hash">url中的hash</h3>
<p>location.hash('aaa') 页面不会刷新</p>
<p>h5中history改变</p>
<p>history.pushState({},'',home)</p>
<p>history.repalceState({},'',home)</p>
<p>pushState和repalceState区别：replaceState不能保存返回，直接替换</p>
<p>history.go（）  = history.back()   ---- 路由跳转</p>
<h3 id="安装配置router">安装配置router</h3>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2020/10/23/EhDxNZOa9W3oMq1.png" alt="image-20201023165527622" loading="lazy"></figure>
<h3 id="配置路由的映射关系">配置路由的映射关系</h3>
<ol>
<li>创建路由组件</li>
<li>配置路由映射，组件和路由映射之间的关系</li>
<li>使用router-view确定位置</li>
</ol>
<p>router-view决定之后渲染出来的东西在哪，占位，</p>
<h3 id="路由的默认值和history模式">路由的默认值和history模式</h3>
<p>路由的默认定向：重定向</p>
<pre><code class="language-js">{
    path:'/',
    redirect:'/home'
  },
</code></pre>
<p>将hash模式改成history模式</p>
<pre><code class="language-js">const router = new VueRouter({
  routes,
  mode:'history',
  linkActiveClass:'acticeClass'
})
</code></pre>
<p>router-link其他的一些属性</p>
<img src="https://i.loli.net/2020/10/23/zwfIQtcoVuOmpxk.png" alt="image-20201023185453517" style="zoom: 67%;" />
<h3 id="代码实现路由跳转">代码实现路由跳转</h3>
<pre><code class="language-js">this.$router.push('/home')
</code></pre>
<pre><code class="language-js">this.$router.repalce('/home')
</code></pre>
<p>vue中尽量不要通过非路由以外的方法解决</p>
<h3 id="动态路由的使用">动态路由的使用</h3>
<p>在某些情况下，页面的路由path可能是不确定的，</p>
<pre><code class="language-js">{
    path:'/user/:id',
    component:User,
}
</code></pre>
<pre><code class="language-js"> &lt;router-link :to=&quot;'/user/'+id&quot;&gt;&lt;/router-link&gt;
</code></pre>
<p>this.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>i</mi><mi>d</mi><mo>=</mo><mo>=</mo><mo>=</mo><mo>=</mo><mi mathvariant="normal">》</mi></mrow><annotation encoding="application/x-tex">route.params.id  ====》</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord">.</span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">》</span></span></span></span>route拿到活跃对象---- 拿到动态路由后面的绑定值id</p>
<pre><code class="language-js">$route.params.id
</code></pre>
<h3 id="打包文件的说明">打包文件的说明</h3>
<p>app.js当前应用程序开发的所有代码（业务代码</p>
<p>vendor.js 引用第三方的js</p>
<p>manifest：为打包的代码做底层支撑</p>
<h3 id="路由的懒加载">路由的懒加载</h3>
<p>打包程序的时候配置文件非常大，会影响页面加载，<mark>用到时再加载</mark></p>
<p>主要作用就是将路由对应的组件打包成一个个的js代码块，只有在这个路由被访问到的时候，才加载对应的组件</p>
<p>写法：</p>
<pre><code class="language-js">const user  = () =&gt; import('../components/user.vue')
</code></pre>
<pre><code class="language-js">{
    path: '/look',
    component:() =&gt; import('../components/look')
  }
</code></pre>
<img src="https://i.loli.net/2020/10/23/9lRtybiquWpeGST.png" alt="image-20201023194310777" style="zoom:67%;" />
<h3 id="路由的嵌套">路由的嵌套</h3>
<ul>
<li>创建对应的子组件配置</li>
<li>在组件内部使用router-view</li>
</ul>
<pre><code class="language-js">{
    path:'/index',
    component:index,
    children:[{
      path:'Home',
      component:Home
    },
    {
      path:'look',
      component:look
    }
    ]
  },
</code></pre>
<h3 id="路由传参">路由传参</h3>
<h4 id="params简单的值">params：简单的值</h4>
<p>this.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>i</mi><mi>d</mi><mo>=</mo><mo>=</mo><mo>=</mo><mo>=</mo><mi mathvariant="normal">》</mi></mrow><annotation encoding="application/x-tex">route.params.id  ====》</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord">.</span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">》</span></span></span></span>route拿到活跃对象---- 拿到动态路由后面的绑定值id</p>
<pre><code class="language-js">$route.params.id
</code></pre>
<p>配置路由格式:/router/:id</p>
<p>传递的方式:在path后面跟上对应的值</p>
<p>传递后形成的路径：/router/213</p>
<h4 id="query可以传入对象">query:可以传入对象</h4>
<p>传递方式：对象中使用query的key作为传递方式</p>
<p>传递后形成的路径：/router?id =123</p>
<pre><code class="language-js">&lt;router-link :to=&quot;{path:'/profile',query:{name:'1'}}&quot;&gt;&lt;/router-link&gt;
</code></pre>
<p>$route.query.name</p>
<pre><code class="language-js">this.$router.push({path:'/profile',query:{name:'kobe',age:18}})
</code></pre>
<h3 id="url">URL</h3>
<p>协议://主机:端口/路径？查询</p>
<p>scheme://host:port/path?query#fragment</p>
<h3 id="router和route">router和route</h3>
<p>$router：是VueRouter的一个对象，通过Vue.use(VueRouter)和VueRouter构造函数得到一个router的实例对象，这个对象中是一个<mark>全局</mark>的对象，他包含了所有的路由包含了许多关键的对象和属性。</p>
<p>$route：是一个跳转的路由对象，每一个路由都会有一个route对象，是一个<mark>局部</mark>的对象，可以获取对应的name,path,params,query等</p>
<p>所有的组件都继承自vue的原型</p>
<h3 id="全局导航守卫">全局导航守卫</h3>
<pre><code class="language-js">//前置守卫（回调hook）
router.beforeEach((to,from,next) =&gt; {
	//从from跳to
	document.title = to.matched[0].meta.title 
	next()//必须调用
})
</code></pre>
<pre><code class="language-js">//后置钩子---已经跳转完
router.afterEach((to,from) =&gt; {
	
})
</code></pre>
<h3 id="路由独享守卫">路由独享守卫</h3>
<pre><code class="language-js">{
    path:'/test',
    component:test,
    beforeEnter: (to, from, next) =&gt; {
      console.log('----')
    }
</code></pre>
<h3 id="组件内导航">组件内导航</h3>
<pre><code class="language-js">beforeRouteLeave((to,from,next){
	this.path = this.$route.path
})
</code></pre>
<h3 id="keep-alive">keep-alive</h3>
<p>是Vue内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染----保持组件不被频繁的销毁</p>
<p>属性</p>
<p>exclude：字符串或正则表达式，任何匹配的组件都不会被缓存</p>
<p>include:只有匹配的组件会被缓存</p>
<pre><code>destoryed() {
	
}
</code></pre>
<pre><code class="language-html">&lt;keep-alive exclude = &quot;profile,user&quot;&gt;
  &lt;router-view&gt;&lt;/router-view&gt;  
&lt;/keep-alive&gt;
</code></pre>
<h4 id="activated和deactivated">activated和deactivated</h4>
<p>只有在keep-alive之下才能执行，只有该组件被保持了状态的时候才有效</p>
<h2 id="promise">Promise</h2>
<p>是<mark>异步</mark>编程的一种解决方案</p>
<p>应用场景，异步操作，网络请求，封装一个网络请求的函数，不能立即拿到结果，往往会传入另外一个函数，在数据请求成功时，将数据通过传入的函数回调出去，如果是一个简单的请求，不会带来麻烦，但是可能会带来回调地狱</p>
<p>异步操作，对即将进行的异步操作进行Promise封装</p>
<p>步骤</p>
<ul>
<li>构造函数，保存状态信息，执行传入的参数，在执行的时候会传入两个参数，resolve，reject</li>
</ul>
<pre><code class="language-js">    new Promise((resolve,reject) =&gt; {
     //网络请求
        setTimeout(() =&gt; {
        resolve(&quot;ninin&quot;)
      },1000)
    }).then((data)=&gt;{
      //处理
      console.log(data)
      return new Promise((resolve,reject)=&gt;{
        setTimeout(()=&gt;{
          //resolve()
            reject('err message')
        },1000)
      }).then(()=&gt;{
        //处理
      }).catch(err =&gt; {
          //reject‘处理
          console.log(err)
      })
    })
</code></pre>
<p>逻辑清晰，请求代码都放在一个Promise里面</p>
<h3 id="promise三种状态">Promise三种状态</h3>
<p>sync 同步    async 异步</p>
<p>pending：等待状态----&gt;正在进行网络请求的时候</p>
<p>fullfill：满足状态 ----&gt;主动调用了resolve</p>
<p>reject：拒绝状态----&gt;主动调用了reject</p>
<pre><code class="language-js"> new Promise((resolve,reject)=&gt;{
        setTimeout(()=&gt;{
          //resolve()
            reject('err message')
        },1000)
      }).then(()=&gt;{
       	//resolve
      },()=&gt;{
      	//reject
      })
</code></pre>
<pre><code>
</code></pre>
<p>其他的两种简写</p>
<pre><code class="language-js">new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        resolve('111')
      }, 100)
    }).then(res =&gt; {
      return Promise.resolve(res+'222')
    })
</code></pre>
<pre><code class="language-js">new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        resolve('111')
      }, 100)
    }).then(res =&gt; {
      return res+'222'
    })
</code></pre>
<p>reject的使用</p>
<pre><code class="language-js">    new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        resolve('111')
        // reject('mes')
      }, 100)
    }).then(res =&gt; {
      return Promise.reject('msg')
      throw console.error(&quot;mesg&quot;);
    })
</code></pre>
<h3 id="promise的all方法的调用">Promise的all方法的调用</h3>
<p>多个请求才能满足需求</p>
<p>all()方法里面传入一个数组，数组里面传入不同的请求，每个请求都会对应不同的结果，Promise会把不同的结果在.then函数中results保存起来调用</p>
<pre><code class="language-js">    Promise.all([
      new Promise((resolve,reject)=&gt;{
        $ajax({
          url:'1',
          success:(data)=&gt;{
            resolve(data)
          }
        })
      }),
      new Promise((resolve,reject)=&gt;{
        $ajax({
          url:'2',
          success:(data)=&gt;{
            resolve(data)
          }
        })
      })
    ]).then(results =&gt; {
      results[0]
      results[1]
    })
</code></pre>
<h2 id="vuex">vuex</h2>
<p>是一个专门为vue.js应用程序开发的状态管理工具</p>
<p>集中式储存管理应用的所有组件的状态，并且以相应的规则保证状态以一种可预测的方式发生变化</p>
<p><strong>响应式的状态的管理的工具</strong></p>
<p>多个组件之间需要共享一个状态---&gt;多个组件共享的变量全部存在一个对象里面</p>
<h3 id="什么样的状态在vuex中">什么样的状态在vuex中</h3>
<ul>
<li>用户的登录状态token，用户的信息等</li>
<li>状态信息</li>
<li>需要在多个页面中共享的状态</li>
</ul>
<h3 id="配置vuex">配置vuex</h3>
<pre><code class="language-js">import Vue from 'vue'
import Vuex from 'vuex'
//安装插件
Vue.use(Vuex)
//导出创建的对象
export default new Vuex.Store({
  state: {
      counter:1000
  },
  mutations: {
  },
  actions: {
  },
  modules: {
  }
})

</code></pre>
<pre><code class="language-js">$store.state.counter//取出vuex中的值
</code></pre>
<h3 id="全局单例模式">全局单例模式</h3>
<p>将共享的状态抽取出来，统一进行管理，之后每个视图，按照<mark>规定好的规定</mark>，进行访问和修改</p>
<h3 id="vuex状态管理图例">Vuex状态管理图例</h3>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2020/10/27/jmzDIgH971rlaot.png" alt="image-20201027215249768" loading="lazy"></figure>
<h3 id="state数据源存放地">state：数据源存放地</h3>
<p>state单一状态树：单一数据源，即使有很多的信息需要划分，也推荐使用单一数据源管理。将所有需要管理的信息统一放在一个store里面。</p>
<p>vue使用单一状态树来管理，应用层级的全部状态。可以最直接的找到某个状态的片段，在之后的维护调试中都非常的方便</p>
<h3 id="getters数据经过变化以后获取的数据">getters:数据经过变化以后获取的数据</h3>
<pre><code class="language-js"> getters:{
    powerCounter(state){
      return state.counter * state.counter
    },
    more20stu(state) {
      return state.student.filter(s =&gt; s.age &gt; 11)
    },
    more20stuLength(state,getters){
      return getters.more20stu.length
    },
    //传入参数
    moreAgeStu(state){
      return function (age){
        return state.student.filter(s =&gt; s.age &gt; 20)
      }
    }
  },
</code></pre>
<h3 id="mutations">mutations</h3>
<p>mutation中的方法必须是同步的方法，否则跟踪不到</p>
<p>mutation主要包括两部分</p>
<ul>
<li>字符串的事件类型</li>
<li>一个回调函数，该回调函数的第一个参数就是state</li>
</ul>
<pre><code class="language-js">mutations: {
    //方法
    increment(state) {
      state.counter++
    },
    decrement(state) {
      state.counter--
    },
    //传入参数
    incrementCount(state,count){
      state.counter += count
    },
    addStuObj(state,stu) {
      state.student.push(stu)
    }
  },
</code></pre>
<p>在methods中调用this.$store.commit</p>
<p>提交时候可以使用一些参数</p>
<pre><code class="language-js">  methods: {
    addition(){
      this.$store.commit('increment')
    },
    addCount(count){
      //负载
      this.$store.commit('increment',count)
    },
    addStu(){
      const stu = {id:3,name:'name',age:14}
      this.$store.commit('addStuObj',stu)
    }
  },
</code></pre>
<p>mutation提交风格</p>
<p>特殊的提交风格的传入的参数会变成一个对象</p>
<pre><code class="language-js"> addCount(count){
      //负载
      this.$store.commit('incrementCount',count)
      //特殊提交
      this.$store.commit({
        type:'incrementCount',
        count:count
      }) 
    },
</code></pre>
<pre><code class="language-js">incrementCount(state,payload){
      state.counter += payloadcount
    },
</code></pre>
<p>Mutation响应规则</p>
<p>vuex-数据的响应式原理</p>
<p>属性一开始就已经被定义，就会被加入到响应式系统中，响应式系统会监听属性的变化，当属性变化时，会通知所有的界面中用到该属性的地方改变值。</p>
<p>使用Vue的方法操作使数据响应式</p>
<pre><code class="language-js">Vue.set(state.info,&quot;address&quot;,&quot;洛杉矶&quot;)
//该方式做不到响应式
//delete state.info.age
Vue.delete(state.info,'age')
</code></pre>
<p>类型常量</p>
<p>在写mutation的时候，把变量方法名等，统一的放在一个js文件里面再导出为一个常量，这样可以避免写错带来的问题</p>
<pre><code>import {
  INCREMENT
} from '../store/mutatoins-type'
</code></pre>
<pre><code>export const INCREMENT = 'increment'
</code></pre>
<pre><code class="language-js">[INCREMENT](state) {
      state.counter++
    },
</code></pre>
<h3 id="actions">actions</h3>
<p>有异步操作的话都在actions里面进行</p>
<p>actions传入的默认参数是context，操作用context中的commit方法调用上面的方法</p>
<p>action可以返回一个Promise，可以在调用方法中调用Promise中的resolve</p>
<pre><code class="language-js">actions: {
    //context上下文
    aUpdateInfo(context,payload) {
      return new Promise((resolve,reject)=&gt;{
        setTimeout(()=&gt;{
          //用commit
          context.commit('UpdateInfo')
          payload()
          resolve('1111')
        },1000)
      })
    }
</code></pre>
<p>在调用的方法中使用dispatch方法调用action中的方法</p>
<pre><code class="language-js">UpdateInfo() {
      this
      .$store.dispatch('aUpdateInfo','message')
      .then(res =&gt; {
        console.log(res)
      })
    }
</code></pre>
<h3 id="modules">modules</h3>
<p>vuex将store分割成模块，每个模块里面有自己的mutations，actions，getters，state。</p>
<p>模块里面的state使用$store.state.a.name,modules中的state作为a（名字）放在state中</p>
<p>mutations中提交的时候还是按照最普通的方式进行提交，提交的时候会先在store中进行 寻找，没有的话就会去模块中进行寻找</p>
<pre><code class="language-js">const moduleA = {
  state:{
    name:'kobe'
  },
  actions:{
      //对象的解构
    aUpdateName({state,commit,rootstate}){
      // commit只会调用自己模块中的一些东西
      setTimeout(()=&gt;{
        context.commit('updateName','wanglu')
      },1000)
    }
  },
  mutations:{
    updateNAME(state,payload){
      state.name = payload
    }
  },
  getters:{
    fullname(state){
      return state.name + &quot; &quot;
    },
    //rootState指的是根store中的数据
    fullname1(state,rootState){
      return fullname+rootState
    }
  }
}
</code></pre>
<h2 id="axios">Axios</h2>
<ul>
<li>传统的Ajax，比较麻烦，</li>
<li>使用jQuery-Ajax，引入代码量较大</li>
<li>Vue-rosource不再更新</li>
</ul>
<h3 id="基本使用">基本使用</h3>
<p>安装</p>
<pre><code>cnpm i axios --save
</code></pre>
<p>main.js中导入</p>
<p>默认只传一个url是get请求</p>
<pre><code class="language-js">axios({
  url:'httpbin.org/',
  params:{
    type:'pop',
    page:1
  },
  method:'GET'
}).then(res =&gt;{
  console.log(res)
})
</code></pre>
<h3 id="发送并发请求">发送并发请求</h3>
<p>使用axios.all，可以放入多个请求的数组</p>
<p>axios.all([]) 返回的结果是一个数组，使用axios.spread可将数组[res1,res2]展开为res1，res2</p>
<pre><code class="language-js">axios.all([axios({
  url:&quot;http://152.136.185.210:8000/api/w6/home/data&quot;
}), axios({
  url:'http://152.136.185.210:8000/api/w6/home/data',
  method:'GET',
  params:{
    type:'sell',
    page:3
  }
})]).then(
  axios.spread((res1,res2)=&gt;{
    console.log(res1)
    console.log(res2)
  })
)
</code></pre>
<h3 id="axios全局配置在进行网络请求">axios全局配置在进行网络请求</h3>
<pre><code>axios.defaults.baseURL = &quot;&quot;
axios.defaults.timeout = 5000
</code></pre>
<h3 id="配置信息">配置信息</h3>
<figure data-type="image" tabindex="5"><img src="https://i.loli.net/2020/10/29/ArpUky5l9EsOv4a.png" alt="image-20201029175236371" loading="lazy"></figure>
<p>为了应对服务器不在一个IP地址</p>
<p>创建对应的axios实例</p>
<pre><code class="language-js">const instance = axios.create({
  baseURL:'http://152.136.185.210:8000/api/w6',
  timeout:5000
})
instance({
  url:'/home/multi'
}).then(res=&gt;{
  console.log(res)
})
</code></pre>
<h3 id="封装axios">封装axios</h3>
<p>方法一方法二都是回调函数的方式</p>
<p>方法一</p>
<pre><code class="language-js">import axios from 'axios'
export function request(config,success,failure){
  //创建实例
  const instance = axios.create({
    baseURL:'http://152.136.185.210:8000/api/w6',
    timeout:5000
  })
  //发送真正的网络请求
  instance(config)
    .then(res =&gt; {
      success(res)
    })
    .catch(err =&gt; {
      failure(err)
    })
}
</code></pre>
<p>调用</p>
<pre><code class="language-js">import {request} from './network/request'
request({
  url:'/home'
},res =&gt;{
  console.log(res)
},err =&gt; {
  console.log(err)
})
</code></pre>
<p>方法二</p>
<pre><code class="language-js">import axios from 'axios'
export function request(config){
  //创建实例
  const instance = axios.create({
    baseURL:'http://152.136.185.210:8000/api/w6',
    timeout:5000
  })
  //发送真正的网络请求
  instance(config.baseConfig)
    .then(res =&gt; {
      config.success(res)
    })
    .catch(err =&gt; {
      config.failure(err)
    })
}
</code></pre>
<pre><code class="language-js">request({
  baseConfig:{
    url:&quot;&quot;
  },
  success:res =&gt; {

  },
  failure:err =&gt; {

  }
})
</code></pre>
<p>方法三-Promise</p>
<pre><code class="language-js">import axios from 'axios'
export function request(config){
  return new Promise((resolve,reject) =&gt; {
    const instance = axios.create({
      baseURL:'http://152.136.185.210:8000/api/w6',
      timeout:5000
    })
    instance(config)
      .then(res =&gt; {
        resolve(res)
      })
      .catch(err =&gt; {
        reject(err)
      })
  })
}
 
</code></pre>
<pre><code class="language-js">request({
  url:''
}).then(res =&gt; {
  console.log(res)
}).catch(err =&gt; {
  console.log(err)
})
</code></pre>
<p>方法四</p>
<p>instance内部的.then.catch，已经是一个Promise对象，不需要再额外的进行包装Promise。</p>
<pre><code class="language-js">export function request(config){
    const instance = axios.create({
      baseURL:'http://152.136.185.210:8000/api/w6',
      timeout:5000
    })
    return instance(config)//返回一个Promise
}
</code></pre>
<p>axios拦截器的使用</p>
<h3 id="拦截器">拦截器</h3>
<ul>
<li>响应拦截</li>
<li>请求拦截</li>
</ul>
<p>拦截到以后要进行一些操作，然后return回去res</p>
<pre><code class="language-js">import axios from 'axios'
export function request(config){
    //创建axios实例
    const instance = axios.create({
      baseURL:'http://152.136.185.210:8000/api/w6',
      timeout:5000
    })
    //axios拦截器
    //请求拦截
    instance.interceptors.request.use(config =&gt; {
      //操作
      //config中的信息不符合服务器要求
      //每次发送请求的时候都显示一个请求图标
      //某些网络请求必须携带特殊的信息，先登录
      return config
    },err =&gt; {
      console.log(err)
    })
    //响应拦截
    instance.interceptors.response.use(res =&gt; {
      return res.data
    },err =&gt; {
      console.log(err)
    })
    //发送真正的网络请求
    return instance(config)
}
 
</code></pre>
<h2 id="git">git</h2>
<pre><code>1、git init   

    2、git add .

    3、git commit -m &quot;提交描述&quot;

    4、git remote add origin https://github.com/MyJoanna/test.git   （这里的 https://github.com/MyJoanna/test.git 是你的仓库地址）

    5、git push -u origin main
</code></pre>
<h2 id="新项目">新项目</h2>
<h3 id="划分目录结构">划分目录结构</h3>
<figure data-type="image" tabindex="6"><img src="https://i.loli.net/2020/10/30/jvGx4fR5bH8WQ6g.png" alt="image-20201030120210228" loading="lazy"></figure>
<h3 id="统一css文件">统一css文件</h3>
<p>github搜索normalize。下载引入normalcss文件，并且在项目中引入</p>
<p>vue.comfig.js 和 .editorconfig</p>
<p>项目模块的划分，tabbar--&gt;路由映射关系</p>
<pre><code class="language-js">&lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;
</code></pre>
<p>&lt;%= BASE_URL %&gt;动态获取当前文件路径</p>
<p>函数调用 -&gt; 压入函数栈(保存函数调用过程中所有变量)</p>
<p>函数调用结束 -&gt; 弹出函数栈(释放函数所有的变量)</p>
<p>再次调用，变量重新创建，调用结束以后释放所有的变量</p>
<p>Better-scroll</p>
<p>指定某一区域滚动</p>
<pre><code class="language-css">.content{
    background-color: blue;
    height: 150px;
    overflow: hidden;
    overflow-y: scroll;
  }
</code></pre>
<pre><code class="language-vue">&lt;template&gt;
&lt;div&gt;
    &lt;div class=&quot;wrapper&quot; ref=&quot;aaa&quot;&gt;
    &lt;ul class=&quot;content&quot;&gt;
     &lt;li&gt;lo1&lt;/li&gt;
     &lt;li&gt;lo2&lt;/li&gt;
     &lt;li&gt;lo3&lt;/li&gt;
     &lt;li&gt;lo4&lt;/li&gt;
     &lt;li&gt;lo5&lt;/li&gt;
     &lt;li&gt;lo6&lt;/li&gt;
    &lt;/ul&gt;
 &lt;/div&gt;
&lt;/div&gt;

&lt;/template&gt;

&lt;script&gt;
import BScroll from 'better-scroll'

  export default {
    name: &quot;Category&quot;,
    data() {
      return {
        scroll:null
      }
    },
    mounted() {
      this.scroll = new BScroll(this.$refs.aaa,{
      })
    },
  }
&lt;/script&gt;

&lt;style scoped&gt;
  .wrapper{
    background-color: blue;
    height: 150px;
     overflow: hidden;
    /* overflow-y: scroll; */
  }
&lt;/style&gt;

</code></pre>
<p>绑定ref</p>
<p>this.$refs.aaa</p>
<p>ref如果绑定在组件 中，<mark>this.$refs.refname</mark>那么获取到的是一个组件对象，</p>
<p>ref如果绑定在普通的元素中，<mark>this.$refs.refname</mark>那么获取到的是一个元素对象，</p>
<p>vh  viewpoint-height</p>
<p>视口高度</p>
<p>组件不能直接监听点击，如果想要监听点击，需要click.native 监听组件根元素的原生事件</p>
<p>.native 当需要监听一个组件的原生事件时，必须给组件加上.native来监听</p>
<h3 id="事件总线">事件总线</h3>
<p>管理事件。</p>
<p>this.$bus.emit(aaa)</p>
<p>发射事件到事件总线，在其他的位置监听发射的时间aaa，（）=&gt;{}</p>
<pre><code>Vue.prototype.$bus = new Vue()

this.$bus.$emit('事件名称'，参数)

this.$bus.$on('事件名称'，回调函数)
</code></pre>
<h3 id="防抖节流">防抖/节流</h3>
<p>debounce/throttle</p>
<p>防抖函数起作用的过程，</p>
<ul>
<li>如果直接执行refresh函数，会执行30次</li>
<li>可以将refresh函数传入到debounce中，生成一个新的函数</li>
</ul>
<p>settimeout永远放在最后执行，加载到下一次事件循环的尾部执行</p>
<p>如何将时间戳转成时间格式化String</p>
<ul>
<li>将时间戳转成date对象</li>
<li>const date  = new Date() -----*1000</li>
<li>将date进行格式化转成对应的字符串</li>
</ul>
<p>FormatString转成字符串</p>
<h3 id="mixin">mixin</h3>
<p>this.$nextTick(()=&gt;{</p>
<p>})</p>
<p>根据最新的数据</p>
<p>vuex</p>
<p>mapgetters</p>
<p>filter</p>
<p>reduce</p>
<p>fastclick减小点击的延迟</p>
<p>解决移动端300ms延迟的效果</p>
<p>import FastClick from 'fastclick'</p>
<p>FastClick.attach(document.body)</p>
<p>图片的懒加载</p>
<p>图片需要显示在屏幕上时再加载</p>
<p>lazyload</p>
<pre><code>npm i vue-lazyload --S
</code></pre>
<pre><code>import VueLazyLoad from 'vue-lazyload'
Vue.use(VueLazyLoad)
</code></pre>
<ul>
<li>
<p>使用</p>
<pre><code>v-lazy=&quot;showImage&quot;
</code></pre>
</li>
</ul>
<p>图片懒加载占位图</p>
<pre><code>Vue.use(VueLazyLoad,{
  loading:require('./assets/img/tabbar/category.svg')
})
</code></pre>
<p>将所有的px改成vw</p>
<pre><code>npm i postcss-px-to-viewport --save-dev
</code></pre>
<pre><code>module.exports = {
  plugins: {
    autoprefixer: {},
    &quot;postcss-px-to-viewport&quot;: {
      viewportWidth: 375, //视口的宽度，对应的时设计稿的宽度/2，一般为750
      viewportHeight: 667, //视口的高度，对应的是设计稿的高度（也可以不配置）
      unitPrecision: 5, //指定‘px’转换为视口单位值的小数位数（很多时候无法整除）
      viewportUnit: 'vw', //指定需要转换成的视口单位，建议使用vw
      selectorBlankList: ['ignore', 'tab-bar'], //指定不需要转换的类
      minPixelValue: 1, //小于或等于‘1px’不转换为视口单位
      mediaQuery: false,//允许在媒体查询中转换为‘px’
      exclude:[/Tabbar/]  //不需要转化的组件文件名正则，必须是正则表达式
    }
  }
}
</code></pre>
<p>yarn</p>
<h3 id="nginx项目部署">nginx项目部署</h3>
<p>服务器：为用户提供服务。24h</p>
<ul>
<li>window-&gt;nginx</li>
<li>远程部署</li>
</ul>
<h3 id="vue的响应式原理">Vue的响应式原理</h3>
<ul>
<li>
<p>数据发生改变，界面跟着更新，不是理所当然的</p>
</li>
<li>
<p>Vue内部是如何监听data数据改变的</p>
</li>
</ul>
<p>Object.defineProperty -&gt; 监听对象属性的改变</p>
<p>当新建一个Vue对象的时候，把data中的数据挂载到Vue中，遍历循环数据，用defineProperty 方法监听对象属性的变化，defineProperty 中有get和set方法</p>
<pre><code class="language-js">Object.keys(obj).forEach(key =&gt; {
    Object.defineProperty(obj,key,{
        set(newValue) {
        //监听key改变
            value = newValue
            //值发生改变调用--update
            dep.notify()
        },
        get(){
        //获取值
            return value
        }
    })
})
    
</code></pre>
<ul>
<li>当数据发生改变，Vue是如何知道需要通知什么部分页面刷新</li>
</ul>
<p>发布订阅者模式</p>
<pre><code class="language-js">存储对属性有依赖的东西
//发布者
class Dependence{
	constructor() {
        this.subs = []//记录谁要订阅属性，
    },
     addSub(watcher) {
         this.subs.push(watcher)
     },
     notify() {
         //找到所有的订阅者
         this.subs.forEach(item =&gt; {
             item.update()
         })
     }
}
//订阅者
class Watcher{
    constructor() {
        this.name = name
    }
    update() {
        //订阅者更新
        console.log(this.name + &quot;update&quot;)
    }
}
const dep = new Dependence()
const watcher = new Watcher(&quot;订阅者&quot;)
const watcher1 = new Watcher(&quot;订阅者1&quot;)
dep.addSub(watcher)//将订阅者放在数组中

dep.notify()
	
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://i.loli.net/2020/11/13/UgHZd5Eok4qK3rY.png" alt="image-20201113131617496" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://i.loli.net/2020/11/13/tcOjsb5MhNvHxoG.png" alt="image-20201113135203740" loading="lazy"></figure>
]]></content>
    </entry>
</feed>